<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="theme-color" content="#0f172a">
<title>MWA Point Tracker</title>
<link rel="manifest" href="manifest.json">
<script>
window.onerror = function(msg, src, line) {
  var d = document.getElementById('_dbg');
  if (!d) { d = document.createElement('div'); d.id = '_dbg'; d.style.cssText = 'position:fixed;bottom:0;left:0;right:0;z-index:99999;background:red;color:white;padding:8px;font-size:12px;max-height:40vh;overflow:auto;'; document.body.appendChild(d); }
  d.innerHTML += '<div>' + msg + ' (line ' + line + ')</div>';
};
</script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore-compat.js"></script>
<style>
:root {
  --bg: #0f172a;
  --surface: #1e293b;
  --surface2: #334155;
  --border: #475569;
  --text: #f1f5f9;
  --text-dim: #94a3b8;
  --primary: #3b82f6;
  --primary-hover: #2563eb;
  --accent: #10b981;
  --accent2: #f59e0b;
  --danger: #ef4444;
  --purple: #8b5cf6;
  --radius: 10px;
  --bottom-nav: 64px;
  --header-h: 56px;
}

* { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

html, body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: var(--bg);
  color: var(--text);
  min-height: 100vh;
  min-height: 100dvh;
  overflow-x: hidden;
}

/* ===== HEADER ===== */
header {
  background: var(--surface);
  border-bottom: 1px solid var(--border);
  padding: 0 16px;
  height: var(--header-h);
  display: flex;
  align-items: center;
  justify-content: space-between;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  z-index: 100;
}
header > * { flex: 1; }
header > .header-date-btn { flex: 0 0 auto; }

header h1 { font-size: 1.1rem; font-weight: 700; color: var(--primary); min-width: 0; }
.header-pts { text-align: right; line-height: 1.2; }
.header-pts .daily { font-size: 0.95rem; color: var(--accent); font-weight: 700; }
.header-pts .monthly { font-size: 0.7rem; color: var(--text-dim); font-weight: 500; }
.header-pts .pace { font-size: 0.62rem; font-weight: 600; }
.header-pts .pace.ahead { color: var(--accent); }
.header-pts .pace.behind { color: var(--accent2); }
.header-date-btn {
  background: var(--surface2);
  border: 1px solid var(--border);
  border-radius: 8px;
  color: var(--text);
  padding: 8px 18px;
  font-size: 1.05rem;
  font-weight: 600;
  cursor: pointer;
  min-height: 44px;
  display: flex;
  align-items: center;
  justify-content: center;
}

/* ===== BOTTOM NAV ===== */
.bottom-nav {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  height: var(--bottom-nav);
  background: var(--surface);
  border-top: 1px solid var(--border);
  display: flex;
  z-index: 100;
  padding-bottom: env(safe-area-inset-bottom, 0);
}

.bottom-nav button {
  flex: 1;
  background: none;
  border: none;
  color: var(--text-dim);
  font-size: 0.65rem;
  font-weight: 500;
  cursor: pointer;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 3px;
  min-height: 44px;
  padding: 4px 2px;
  transition: color 0.2s;
}

.bottom-nav button .nav-icon { font-size: 1.3rem; line-height: 1; }
.bottom-nav button.active { color: var(--primary); }
.bottom-nav button:active { color: var(--primary); }

/* ===== PAGES ===== */
.page {
  display: none;
  padding: calc(var(--header-h) + 12px) 12px calc(var(--bottom-nav) + 16px);
  max-width: 600px;
  margin: 0 auto;
}
.page.active { display: block; }

/* ===== CARDS ===== */
.card {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 16px;
  margin-bottom: 12px;
}

.card h2 { font-size: 1rem; margin-bottom: 12px; color: var(--text); }
.card h3 { font-size: 0.9rem; margin-bottom: 8px; color: var(--text-dim); }

.card-collapse-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  cursor: pointer;
  min-height: 44px;
}

.card-collapse-header .arrow { transition: transform 0.2s; color: var(--text-dim); }
.card-collapse-header .arrow.open { transform: rotate(180deg); }
.card-collapse-body { overflow: hidden; transition: max-height 0.3s ease; }

/* ===== FORMS ===== */
.form-group { margin-bottom: 12px; }

.form-group label {
  display: block;
  font-size: 0.8rem;
  color: var(--text-dim);
  margin-bottom: 4px;
  font-weight: 500;
}

.form-row { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
.form-row-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px; }

input, select, textarea {
  width: 100%;
  padding: 10px 12px;
  background: var(--surface2);
  border: 1px solid var(--border);
  border-radius: 6px;
  color: var(--text);
  font-size: 16px; /* prevents iOS zoom */
  outline: none;
  transition: border-color 0.2s;
  min-height: 44px;
}

input:focus, select:focus, textarea:focus { border-color: var(--primary); }
textarea { resize: vertical; min-height: 60px; }

.checkbox-group {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 8px 0;
  min-height: 44px;
}

.checkbox-group input[type="checkbox"] {
  width: 22px;
  height: 22px;
  accent-color: var(--primary);
  cursor: pointer;
  flex-shrink: 0;
}

.checkbox-group label {
  font-size: 0.9rem;
  color: var(--text);
  cursor: pointer;
  margin-bottom: 0;
}

/* ===== BUTTONS ===== */
.btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: 12px 20px;
  border: none;
  border-radius: 6px;
  font-size: 0.95rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
  gap: 6px;
  min-height: 44px;
}

.btn-primary { background: var(--primary); color: white; width: 100%; }
.btn-primary:hover { background: var(--primary-hover); }
.btn-primary:active { transform: scale(0.98); }
.btn-accent { background: var(--accent); color: white; }
.btn-danger { background: var(--danger); color: white; padding: 8px 14px; font-size: 0.85rem; }
.btn-sm { padding: 8px 14px; font-size: 0.85rem; }
.btn-outline { background: transparent; border: 1px solid var(--border); color: var(--text-dim); }
.btn-outline:hover { border-color: var(--primary); color: var(--primary); }

/* ===== BADGES ===== */
.point-badge {
  display: inline-block;
  background: var(--primary);
  color: white;
  padding: 3px 10px;
  border-radius: 20px;
  font-size: 0.8rem;
  font-weight: 600;
}
.point-badge.large { font-size: 1.1rem; padding: 4px 14px; }
.point-badge.green { background: var(--accent); }
.point-badge.yellow { background: var(--accent2); color: #1e293b; }

/* ===== SUMMARY GRID ===== */
.summary-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 12px; }

.summary-item {
  background: var(--surface2);
  border-radius: 8px;
  padding: 12px;
  text-align: center;
}

.summary-item .label { font-size: 0.75rem; color: var(--text-dim); margin-bottom: 4px; }
.summary-item .value { font-size: 1.3rem; font-weight: 700; }
.summary-item .value.blue { color: var(--primary); }
.summary-item .value.green { color: var(--accent); }
.summary-item .value.yellow { color: var(--accent2); }
.summary-item .value.purple { color: var(--purple); }

/* (case type grids removed — now using select dropdowns) */

/* ===== LISTS ===== */
.case-list-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px 0;
  border-bottom: 1px solid var(--surface2);
  gap: 8px;
}
.case-list-item:last-child { border-bottom: none; }
.case-list-item .info { flex: 1; min-width: 0; }
.case-list-item .info h4 { font-size: 0.85rem; font-weight: 600; }
.case-list-item .info p { font-size: 0.75rem; color: var(--text-dim); }
.case-list-item .actions { display: flex; align-items: center; gap: 8px; flex-shrink: 0; }

.day-list-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 14px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 8px;
  margin-bottom: 8px;
  cursor: pointer;
  transition: border-color 0.2s;
  min-height: 44px;
}
.day-list-item:hover { border-color: var(--primary); }
.day-list-item:active { border-color: var(--primary); background: var(--surface2); }
.day-list-item .date { font-weight: 600; font-size: 0.9rem; }
.day-list-item .meta { font-size: 0.75rem; color: var(--text-dim); }

/* ===== POINT BREAKDOWN ===== */
.point-breakdown {
  background: var(--surface2);
  border-radius: 8px;
  padding: 12px;
  margin-top: 12px;
}

.point-breakdown .row { display: flex; justify-content: space-between; padding: 4px 0; font-size: 0.8rem; }

.point-breakdown .row.total {
  border-top: 1px solid var(--border);
  margin-top: 6px;
  padding-top: 8px;
  font-weight: 700;
  font-size: 0.9rem;
}

/* ===== MONTH NAV ===== */
.month-nav {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 16px;
  margin-bottom: 16px;
}

.month-nav button {
  background: var(--surface2);
  border: 1px solid var(--border);
  border-radius: 6px;
  color: var(--text);
  padding: 8px 14px;
  cursor: pointer;
  font-size: 1rem;
  min-height: 44px;
  min-width: 44px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.month-nav span { font-weight: 600; font-size: 1rem; min-width: 150px; text-align: center; }

/* ===== CHART ===== */
.chart-container { position: relative; height: 250px; margin: 12px 0; }

/* ===== RECONCILIATION ===== */
.recon-status { padding: 10px 14px; border-radius: 8px; margin-bottom: 8px; font-size: 0.85rem; }
.recon-match { background: rgba(16,185,129,0.15); border: 1px solid var(--accent); color: var(--accent); }
.recon-warn { background: rgba(245,158,11,0.15); border: 1px solid var(--accent2); color: var(--accent2); }
.recon-miss { background: rgba(239,68,68,0.15); border: 1px solid var(--danger); color: var(--danger); }

.recon-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.75rem;
  margin: 8px 0;
}

.recon-table th, .recon-table td {
  padding: 8px 6px;
  text-align: left;
  border-bottom: 1px solid var(--surface2);
}

.recon-table th { color: var(--text-dim); font-weight: 600; font-size: 0.7rem; text-transform: uppercase; }
.recon-table td { vertical-align: top; }
.recon-table tr.match { background: rgba(16,185,129,0.07); }
.recon-table tr.warn { background: rgba(245,158,11,0.07); }
.recon-table tr.miss { background: rgba(239,68,68,0.07); }

/* ===== DIFFERENCE REVIEWER STEPPER ===== */
.diff-stepper { background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius); overflow: hidden; margin: 12px 0; }
.diff-stepper-header { display: flex; justify-content: space-between; align-items: center; padding: 12px 16px; border-bottom: 1px solid var(--border); }
.diff-stepper-header .counter { font-size: 0.85rem; color: var(--text-dim); font-weight: 600; }
.diff-stepper-nav { display: flex; gap: 8px; }
.diff-stepper-nav button { background: var(--surface2); border: 1px solid var(--border); border-radius: 6px; color: var(--text); width: 36px; height: 36px; font-size: 1.1rem; cursor: pointer; display: flex; align-items: center; justify-content: center; }
.diff-stepper-nav button:disabled { opacity: 0.3; cursor: default; }
.diff-stepper-body { padding: 16px; }
.diff-stepper-body .diff-date { font-weight: 600; font-size: 0.95rem; margin-bottom: 4px; }
.diff-stepper-body .diff-acct { font-size: 0.75rem; color: var(--text-dim); margin-bottom: 12px; }
.diff-compare { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 16px; }
.diff-col { background: var(--bg); border-radius: 8px; padding: 12px; }
.diff-col h4 { font-size: 0.7rem; text-transform: uppercase; color: var(--text-dim); margin-bottom: 8px; }
.diff-col .val { font-size: 1.1rem; font-weight: 700; }
.diff-col .detail { font-size: 0.75rem; color: var(--text-dim); margin-top: 4px; }
.diff-actions { display: flex; gap: 8px; flex-wrap: wrap; }
.diff-actions .btn { flex: 1; min-width: 90px; font-size: 0.8rem; padding: 10px 8px; }
.btn-accept-billing { background: var(--primary); color: #fff; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; }
.btn-accept-app { background: var(--accent); color: #fff; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; }
.btn-flag { background: var(--accent2); color: #000; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; }
.diff-stepper.resolved { border-color: var(--accent); }
.diff-stepper.flagged { border-color: var(--accent2); }

/* Add-on tally */
.addon-tally-table { width: 100%; border-collapse: collapse; font-size: 0.75rem; margin: 8px 0; }
.addon-tally-table th, .addon-tally-table td { padding: 8px 6px; text-align: left; border-bottom: 1px solid var(--surface2); }
.addon-tally-table th { color: var(--text-dim); font-weight: 600; font-size: 0.7rem; text-transform: uppercase; }
.addon-tally-table tr.addon-match { background: rgba(16,185,129,0.07); }
.addon-tally-table tr.addon-warn { background: rgba(245,158,11,0.07); }
.addon-tally-table tr.addon-miss { background: rgba(239,68,68,0.07); }
.addon-action-btn { background: var(--surface2); border: 1px solid var(--border); border-radius: 6px; color: var(--text); font-size: 0.7rem; padding: 4px 8px; cursor: pointer; }
.addon-action-btn:hover { background: var(--primary); color: #fff; }
.addon-select { background: var(--surface2); border: 1px solid var(--border); border-radius: 6px; color: var(--text); font-size: 0.7rem; padding: 4px; max-width: 140px; }

/* Flagged issues */
.flagged-list { list-style: none; padding: 0; }
.flagged-list li { padding: 8px 0; border-bottom: 1px solid var(--surface2); font-size: 0.8rem; color: var(--text); }
.flagged-list li:last-child { border-bottom: none; }

/* Email preview */
.email-preview { background: var(--bg); border: 1px solid var(--border); border-radius: 8px; padding: 16px; font-size: 0.8rem; white-space: pre-wrap; font-family: monospace; max-height: 300px; overflow-y: auto; margin: 12px 0; }

/* Flag button */
.flag-btn { background:none; border:none; cursor:pointer; font-size:1rem; padding:2px 4px; color:transparent; -webkit-text-stroke:1.5px #fff; }
.flag-btn.flagged { color:#e74c3c; -webkit-text-stroke:0; }
.flagged-row { border-left: 3px solid #e74c3c !important; }

/* ===== UPLOAD AREA ===== */
.upload-area {
  border: 2px dashed var(--border);
  border-radius: 8px;
  padding: 24px;
  text-align: center;
  cursor: pointer;
  transition: border-color 0.2s;
  min-height: 44px;
}

.upload-area:hover { border-color: var(--primary); }
.upload-area p { color: var(--text-dim); font-size: 0.85rem; margin-top: 8px; }
.upload-area input { display: none; }

/* ===== SHIFT TEMPLATES ===== */
.template-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 12px; }

.template-btn {
  padding: 10px 8px;
  background: var(--surface2);
  border: 1px solid var(--border);
  border-radius: 8px;
  color: var(--text);
  font-size: 0.8rem;
  cursor: pointer;
  text-align: center;
  transition: all 0.2s;
  min-height: 44px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 2px;
}

.template-btn:hover { border-color: var(--primary); }
.template-btn:active { background: rgba(59,130,246,0.15); border-color: var(--primary); }
.template-btn .t-label { font-weight: 600; }
.template-btn .t-time { font-size: 0.7rem; color: var(--text-dim); }

/* ===== TOAST ===== */
.toast {
  position: fixed;
  bottom: calc(var(--bottom-nav) + 16px);
  left: 50%;
  transform: translateX(-50%);
  background: var(--accent);
  color: white;
  padding: 10px 24px;
  border-radius: 8px;
  font-size: 0.85rem;
  font-weight: 600;
  z-index: 200;
  opacity: 0;
  transition: opacity 0.3s;
  pointer-events: none;
  white-space: nowrap;
}
.toast.show { opacity: 1; }

/* ===== MODAL ===== */
.modal-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.6);
  z-index: 300;
  display: flex;
  align-items: flex-end;
  justify-content: center;
  padding: 0;
}

.modal {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 16px 16px 0 0;
  padding: 20px;
  max-width: 600px;
  width: 100%;
  max-height: 85vh;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
}

.modal h2 { margin-bottom: 16px; }

.modal-actions {
  display: flex;
  gap: 8px;
  margin-top: 16px;
  justify-content: flex-end;
}

/* ===== TAB SWITCHER ===== */
.tab-bar {
  display: flex;
  border-bottom: 1px solid var(--border);
  margin-bottom: 12px;
  overflow-x: auto;
}

.tab-btn {
  flex: 1;
  padding: 10px 8px;
  background: none;
  border: none;
  border-bottom: 3px solid transparent;
  color: var(--text-dim);
  font-size: 0.8rem;
  font-weight: 500;
  cursor: pointer;
  white-space: nowrap;
  min-height: 44px;
  transition: all 0.2s;
}

.tab-btn.active { color: var(--primary); border-bottom-color: var(--primary); }

/* ===== MISC ===== */
.empty-state { text-align: center; padding: 40px 20px; color: var(--text-dim); }
.empty-state p { margin-top: 8px; font-size: 0.85rem; }
.divider { height: 1px; background: var(--border); margin: 16px 0; }
.modifiers-section { border: 1px solid var(--border); border-radius: 8px; padding: 8px 12px; margin: 8px 0; }
.modifiers-section summary { cursor: pointer; font-weight: 600; font-size: 0.9rem; color: var(--text-dim); list-style: none; display: flex; align-items: center; gap: 8px; }
.modifiers-section summary::-webkit-details-marker { display: none; }
.modifiers-section summary::before { content: '\25B6'; font-size: 0.65rem; transition: transform 0.2s; }
.modifiers-section[open] summary::before { transform: rotate(90deg); }
.modifier-tags { display: inline-flex; gap: 4px; flex-wrap: wrap; }
.modifier-tags .mod-tag { background: var(--accent); color: #fff; font-size: 0.65rem; padding: 1px 6px; border-radius: 10px; font-weight: 500; }
.hidden { display: none !important; }

/* ===== END TIME WARNING ===== */
.end-time-warning {
  background: rgba(245,158,11,0.15);
  border: 1px solid var(--accent2);
  color: var(--accent2);
  padding: 10px 14px;
  border-radius: 8px;
  margin-bottom: 12px;
  font-size: 0.85rem;
  font-weight: 500;
}
input.warn-empty {
  border-color: var(--accent2) !important;
  box-shadow: 0 0 0 1px var(--accent2);
}

/* ===== MILITARY TIME INPUTS ===== */
input.mil-time {
  font-variant-numeric: tabular-nums;
  letter-spacing: 1px;
  text-align: center;
  font-family: 'SF Mono', 'Menlo', 'Consolas', monospace;
}
input.mil-time.invalid {
  border-color: var(--danger) !important;
}

.settings-field {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px 0;
  border-bottom: 1px solid var(--surface2);
}

.settings-field label { font-size: 0.85rem; color: var(--text-dim); white-space: nowrap; min-width: 60px; }

/* ===== DASHBOARD SUB-TABS ===== */
.dash-sticky-header {
  position: fixed;
  top: var(--header-h);
  left: 0;
  right: 0;
  z-index: 50;
  background: var(--bg);
  padding: 0 12px 4px;
  max-width: 600px;
  margin: 0 auto;
}
#dtab-caselogs .case-log-search { margin-bottom: 4px; }
.dash-tab-bar {
  display: flex;
  border-bottom: 1px solid var(--border);
  overflow-x: auto;
  gap: 0;
}
.dash-tab-btn {
  flex: 1;
  padding: 10px 6px;
  background: none;
  border: none;
  border-bottom: 3px solid transparent;
  color: var(--text-dim);
  font-size: 0.75rem;
  font-weight: 500;
  cursor: pointer;
  white-space: nowrap;
  min-height: 44px;
  transition: all 0.2s;
  text-align: center;
}
.dash-tab-btn.active { color: var(--primary); border-bottom-color: var(--primary); }

/* ===== DATA ENTRY PAGE ===== */
.de-sticky-header {
  position: fixed;
  top: var(--header-h);
  left: 0;
  right: 0;
  z-index: 50;
  background: var(--bg);
  padding: 8px 12px 4px;
  max-width: 600px;
  margin: 0 auto;
}

.daily-tally {
  display: flex;
  align-items: center;
  justify-content: space-between;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 10px 16px;
  margin-bottom: 8px;
}
.daily-tally .tally-label { font-size: 0.85rem; color: var(--text-dim); font-weight: 500; }
.daily-tally .tally-value { font-size: 1.1rem; color: var(--accent); font-weight: 700; }

.shift-summary-bar {
  display: flex;
  align-items: center;
  justify-content: space-between;
  background: var(--surface);
  border: 1px solid var(--primary);
  border-radius: var(--radius);
  padding: 12px 16px;
  margin-bottom: 0;
  cursor: pointer;
  transition: background 0.15s;
}
.shift-summary-bar:hover { background: rgba(59,130,246,0.1); }
.shift-summary-bar .ssb-info { display: flex; align-items: center; gap: 10px; flex: 1; min-width: 0; }
.shift-summary-bar .ssb-badge {
  background: var(--primary);
  color: #fff;
  font-size: 0.72rem;
  font-weight: 600;
  padding: 3px 8px;
  border-radius: 4px;
  white-space: nowrap;
}
.shift-summary-bar .ssb-badge.vacation { background: var(--purple); }
.shift-summary-bar .ssb-times { font-size: 0.82rem; color: var(--text-dim); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.shift-summary-bar .ssb-edit { color: var(--primary); font-size: 0.8rem; font-weight: 600; white-space: nowrap; margin-left: 8px; }

.de-case-list { margin-top: 8px; }
.de-case-list-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px 0;
  border-bottom: 1px solid var(--surface2);
  gap: 8px;
}
.de-case-list-item:last-child { border-bottom: none; }
.de-case-list-item:hover { background: rgba(59,130,246,0.06); }
.de-case-list-item:active { background: rgba(59,130,246,0.12); }
.de-case-list-item .de-info { flex: 1; min-width: 0; }
.de-case-list-item .de-name { font-size: 0.82rem; font-weight: 600; color: var(--text); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.de-case-list-item .de-detail { font-size: 0.72rem; color: var(--text-dim); }
.de-case-list-item .de-actions { display: flex; align-items: center; gap: 8px; }
.de-case-list-item .de-pts { font-size: 0.82rem; color: var(--accent); font-weight: 700; white-space: nowrap; }

/* ===== DAY DETAIL MODAL ===== */
.dd-shift-bar {
  display: flex;
  align-items: center;
  gap: 10px;
  background: var(--surface2);
  border-radius: 6px;
  padding: 10px 12px;
  margin-bottom: 12px;
}
.dd-shift-bar .dd-badge {
  background: var(--primary);
  color: #fff;
  font-size: 0.72rem;
  font-weight: 600;
  padding: 3px 8px;
  border-radius: 4px;
  white-space: nowrap;
}
.dd-shift-bar .dd-badge.vacation { background: var(--purple); }
.dd-shift-bar .dd-times { font-size: 0.82rem; color: var(--text-dim); flex: 1; }
.dd-summary {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
  margin-bottom: 12px;
}
.dd-summary-item {
  background: var(--surface);
  border-radius: 6px;
  padding: 8px 10px;
  text-align: center;
}
.dd-summary-item .dd-label { font-size: 0.68rem; color: var(--text-dim); margin-bottom: 2px; }
.dd-summary-item .dd-value { font-size: 1rem; font-weight: 700; }
.dd-summary-item .dd-value.blue { color: var(--primary); }
.dd-summary-item .dd-value.green { color: var(--accent); }
.dd-summary-item .dd-value.yellow { color: var(--accent2); }
.dd-case-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px 0;
  border-bottom: 1px solid var(--surface2);
  gap: 8px;
}
.dd-case-item:last-child { border-bottom: none; }
.dd-case-item .dd-case-info { flex: 1; min-width: 0; }
.dd-case-item .dd-case-name { font-size: 0.82rem; font-weight: 600; color: var(--text); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.dd-case-item .dd-case-detail { font-size: 0.72rem; color: var(--text-dim); }
.dd-case-item .dd-case-actions { display: flex; align-items: center; gap: 6px; }
.dd-case-item .dd-case-pts { font-size: 0.82rem; color: var(--accent); font-weight: 700; white-space: nowrap; }

/* ===== DAILY CALENDAR ===== */
.daily-cal { display: grid; grid-template-columns: repeat(7, 1fr); gap: 2px; width: 100%; box-sizing: border-box; }
.daily-cal-header { font-size: 0.6rem; color: var(--text-dim); text-align: center; padding: 2px 0; font-weight: 600; }
.daily-cal-cell { background: var(--surface); border-radius: 5px; padding: 4px 2px; text-align: center; min-height: 44px; position: relative; cursor: pointer; transition: background 0.15s; overflow: hidden; }
.daily-cal-cell:active:not(.empty) { background: rgba(59,130,246,0.15); }
.daily-cal-cell.empty { background: transparent; }
.daily-cal-cell.today { border: 2px solid var(--primary); }
.daily-cal-cell.vacation { background: rgba(139,92,246,0.15); }
.daily-cal-day { font-size: 0.6rem; color: var(--text-dim); margin-bottom: 1px; }
.daily-cal-pts { font-size: 0.75rem; font-weight: 700; color: var(--text); }
.daily-cal-pts.zero { color: var(--text-dim); font-weight: 400; }
.daily-cal-type { font-size: 0.5rem; color: var(--accent); margin-top: 1px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

/* ===== CASE LOG TABLE ===== */
.case-log-wrap { overflow-x: auto; -webkit-overflow-scrolling: touch; margin: 0 -12px; padding: 0 12px; }
.case-log-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.68rem;
}
.case-log-table thead { position: sticky; top: 0; z-index: 2; }
.case-log-table th {
  background: var(--surface);
  color: var(--text-dim);
  font-weight: 600;
  font-size: 0.62rem;
  text-transform: uppercase;
  padding: 3px 3px;
  text-align: left;
  border-bottom: 2px solid var(--border);
  white-space: nowrap;
}
.case-log-table td {
  padding: 3px 3px;
  border-bottom: 1px solid var(--surface2);
  vertical-align: middle;
}
.case-log-table .cl-del { color: var(--danger); cursor: pointer; font-size: 0.9rem; padding: 2px 4px; line-height: 1; }
.case-log-table tr { cursor: pointer; transition: background 0.15s; }
.case-log-table tbody tr:hover { background: rgba(59,130,246,0.08); }
.case-log-table tbody tr:active { background: rgba(59,130,246,0.15); }
.case-log-table .cl-cb { width: 16px; height: 16px; accent-color: var(--primary); cursor: pointer; margin: 0; }
.case-log-table th:first-child, .case-log-table td:first-child { width: 28px; text-align: center; }
#clDeleteSelectedBtn {
  background: var(--danger);
  color: white;
  border: none;
  border-radius: 6px;
  padding: 6px 14px;
  font-size: 0.75rem;
  font-weight: 600;
  cursor: pointer;
  margin-bottom: 6px;
}
#clDeleteSelectedBtn:hover { opacity: 0.9; }

.case-log-search {
  width: 100%;
  padding: 8px 12px;
  background: var(--surface2);
  border: 1px solid var(--border);
  border-radius: 6px;
  color: var(--text);
  font-size: 14px;
  margin-bottom: 12px;
  outline: none;
  min-height: 44px;
}
.case-log-search:focus { border-color: var(--primary); }

/* ===== SHIFT LOG TABLE ===== */
.shift-log-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.72rem;
  min-width: 900px;
}
.shift-log-table thead { position: sticky; top: 0; z-index: 2; }
.shift-log-table th {
  background: var(--surface);
  color: var(--text-dim);
  font-weight: 600;
  font-size: 0.68rem;
  text-transform: uppercase;
  padding: 8px 6px;
  text-align: left;
  border-bottom: 2px solid var(--border);
  white-space: nowrap;
}
.shift-log-table td {
  padding: 6px 6px;
  border-bottom: 1px solid var(--surface2);
  vertical-align: middle;
}
.shift-log-table tr { cursor: pointer; transition: background 0.15s; }
.shift-log-table tbody tr.sl-alt { background: rgba(148,163,184,0.06); }
.shift-log-table tbody tr:hover { background: rgba(59,130,246,0.08); }
.shift-log-table tbody tr:active { background: rgba(59,130,246,0.15); }
.sl-sub-row td { border-top: none; }
.sl-sub-row td:empty, .sl-sub-row td[data-blank] { color: transparent; }
.shift-log-table .sl-check { width: 28px; text-align: center; }
.shift-log-table .sl-check input[type="checkbox"] { width: 16px; height: 16px; cursor: pointer; accent-color: var(--primary); }
.shift-log-table .sl-del-cell { width: 28px; text-align: center; }
.shift-log-table .sl-del-btn { background: none; border: none; color: var(--danger); cursor: pointer; font-size: 1rem; padding: 2px 4px; line-height: 1; opacity: 0.7; transition: opacity 0.15s; }
.shift-log-table .sl-del-btn:hover { opacity: 1; }
.sl-delete-bar { display: flex; align-items: center; gap: 12px; padding: 8px 12px; margin-bottom: 8px; background: rgba(239,68,68,0.08); border: 1px solid var(--danger); border-radius: 8px; }
.sl-delete-bar .sl-del-count { font-size: 0.82rem; color: var(--text); font-weight: 600; }
.sl-delete-bar .sl-del-action { background: var(--danger); color: white; border: none; border-radius: 6px; padding: 6px 14px; font-size: 0.8rem; font-weight: 600; cursor: pointer; transition: opacity 0.15s; }
.sl-delete-bar .sl-del-action:hover { opacity: 0.9; }
.sl-badge {
  display: inline-block;
  padding: 2px 6px;
  border-radius: 4px;
  font-size: 0.65rem;
  font-weight: 600;
  white-space: nowrap;
}
.sl-badge-or { background: rgba(16,185,129,0.2); color: #34d399; }
.sl-badge-ob { background: rgba(59,130,246,0.2); color: #60a5fa; }
.sl-badge-call { background: rgba(245,158,11,0.2); color: #fbbf24; }
.sl-badge-endo { background: rgba(139,92,246,0.2); color: #a78bfa; }
.sl-badge-sf { background: rgba(236,72,153,0.2); color: #f472b6; }
.sl-badge-other { background: rgba(148,163,184,0.2); color: #94a3b8; }
.sl-badge-vac { background: rgba(100,116,139,0.15); color: #64748b; }
.sl-summary-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.78rem;
}
.sl-summary-table th {
  text-align: left;
  color: var(--text-dim);
  font-weight: 600;
  font-size: 0.7rem;
  padding: 4px 8px;
  border-bottom: 1px solid var(--border);
}
.sl-summary-table td {
  padding: 4px 8px;
  border-bottom: 1px solid var(--surface2);
}
.sl-summary-table tr:last-child td {
  font-weight: 700;
  border-top: 2px solid var(--border);
  border-bottom: none;
}
.sl-pager-row { background: rgba(245,158,11,0.06); }

/* ===== TOGGLE SWITCH ===== */
.toggle-row { display: flex; align-items: center; gap: 8px; font-size: 0.8rem; color: var(--text-dim); }
.toggle-switch { position: relative; width: 36px; height: 20px; flex-shrink: 0; }
.toggle-switch input { opacity: 0; width: 0; height: 0; }
.toggle-switch .slider { position: absolute; inset: 0; background: var(--surface2); border-radius: 10px; cursor: pointer; transition: 0.2s; border: 1px solid var(--border); }
.toggle-switch .slider::before { content: ''; position: absolute; width: 14px; height: 14px; left: 2px; top: 2px; background: var(--text-dim); border-radius: 50%; transition: 0.2s; }
.toggle-switch input:checked + .slider { background: var(--primary); border-color: var(--primary); }
.toggle-switch input:checked + .slider::before { transform: translateX(16px); background: #fff; }

/* ===== EFFICIENCY ITEMS ===== */
.efficiency-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 6px 0;
  border-bottom: 1px solid rgba(71,85,105,0.3);
  font-size: 0.82rem;
}
.efficiency-item:last-child { border-bottom: none; }
.efficiency-item .eff-label { flex: 1; min-width: 0; }
.efficiency-item .eff-value { font-weight: 700; margin-left: 8px; white-space: nowrap; }
.efficiency-item .eff-value.good { color: var(--accent); }
.efficiency-item .eff-value.bad { color: var(--danger); }

/* ===== TREND ARROWS ===== */
.trend-up { color: var(--accent); font-weight: 700; }
.trend-down { color: var(--danger); font-weight: 700; }
.trend-flat { color: var(--text-dim); font-weight: 700; }

/* ===== HEATMAP BARS ===== */
.heatmap-row {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 4px 0;
  font-size: 0.8rem;
}
.heatmap-row .hm-label { width: 36px; color: var(--text-dim); font-size: 0.75rem; flex-shrink: 0; }
.heatmap-bar {
  height: 20px;
  background: var(--primary);
  border-radius: 3px;
  min-width: 2px;
  transition: width 0.3s;
}
.heatmap-bar.green { background: var(--accent); }
.heatmap-row .hm-value { font-size: 0.75rem; color: var(--text-dim); min-width: 40px; text-align: right; }

/* ===== CASE MIX ITEMS ===== */
.case-mix-item {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 5px 0;
  font-size: 0.8rem;
}
.case-mix-item .cm-label { width: 110px; flex-shrink: 0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.case-mix-bar-wrap { flex: 1; height: 16px; background: var(--surface2); border-radius: 3px; overflow: hidden; }
.case-mix-bar { height: 100%; background: var(--primary); border-radius: 3px; transition: width 0.3s; }
.case-mix-item .cm-count { min-width: 32px; text-align: right; font-size: 0.75rem; color: var(--text-dim); }

/* ===== COLLAPSIBLE SECTIONS ===== */
.collapse-section { margin-bottom: 8px; }
.collapse-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  cursor: pointer;
  min-height: 44px;
  padding: 8px 0;
  border-bottom: 1px solid var(--surface2);
}
.collapse-header h3 { font-size: 0.88rem; margin: 0; }
.collapse-header .arrow { transition: transform 0.2s; color: var(--text-dim); }
.collapse-header .arrow.open { transform: rotate(180deg); }
.collapse-body { overflow: hidden; transition: max-height 0.3s ease; max-height: 0; }

/* ===== PROCEDURE AUTOCOMPLETE ===== */
.proc-autocomplete { position: relative; }
.proc-suggestions {
  position: absolute; top: 100%; left: 0; right: 0; z-index: 100;
  background: var(--surface); border: 1px solid var(--border); border-top: none;
  border-radius: 0 0 8px 8px; max-height: 180px; overflow-y: auto;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
}
.proc-suggestions .proc-item {
  padding: 10px 12px; cursor: pointer; font-size: 0.85rem;
  display: flex; justify-content: space-between; align-items: center;
}
.proc-suggestions .proc-item:hover, .proc-suggestions .proc-item.active {
  background: var(--primary); color: #fff;
}
.proc-suggestions .proc-item .proc-units {
  font-size: 0.75rem; color: var(--text-dim); margin-left: 8px;
}
.proc-suggestions .proc-item:hover .proc-units,
.proc-suggestions .proc-item.active .proc-units { color: rgba(255,255,255,0.7); }

/* ===== TIME ENTRY ROWS ===== */
.time-entry-row {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}
.time-entry-row input { flex: 1; }
.time-entry-row .te-label { font-size: 0.8rem; color: var(--text-dim); flex-shrink: 0; }
.remove-entry-btn {
  background: var(--danger);
  color: white;
  border: none;
  border-radius: 6px;
  width: 36px;
  height: 36px;
  font-size: 1.1rem;
  cursor: pointer;
  flex-shrink: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 36px;
}
.remove-entry-btn:disabled { opacity: 0.3; cursor: default; }
.add-entry-btn {
  background: transparent;
  border: 1px dashed var(--border);
  border-radius: 6px;
  color: var(--primary);
  padding: 8px;
  width: 100%;
  font-size: 0.85rem;
  cursor: pointer;
  margin-bottom: 12px;
  min-height: 38px;
  transition: border-color 0.2s;
}
.add-entry-btn:hover { border-color: var(--primary); }

/* ===== SCAN PAGE ===== */
.scan-capture-area {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 12px;
  padding: 16px;
  border: 2px dashed var(--border);
  border-radius: var(--radius);
  text-align: center;
  cursor: pointer;
  transition: border-color 0.2s;
}
.scan-capture-area:hover { border-color: var(--primary); }
.scan-capture-area .scan-icon { font-size: 2.5rem; }
.scan-capture-area p { margin: 0; font-size: 0.85rem; color: var(--text-dim); }
.scan-preview-img {
  max-width: 100%;
  max-height: 200px;
  border-radius: var(--radius);
  margin-top: 8px;
  object-fit: contain;
}
.scan-status {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 10px 14px;
  border-radius: var(--radius);
  font-size: 0.85rem;
  margin-top: 8px;
}
.scan-status.processing { background: rgba(59,130,246,0.12); color: var(--primary); }
.scan-status.success { background: rgba(16,185,129,0.12); color: var(--accent); }
.scan-status.error { background: rgba(239,68,68,0.12); color: var(--danger); }
.scan-status .spinner {
  width: 16px; height: 16px;
  border: 2px solid transparent;
  border-top-color: var(--primary);
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
}
@keyframes spin { to { transform: rotate(360deg); } }
.scan-case-card {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 12px;
  margin-bottom: 10px;
}
.scan-case-card .scc-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
}
.scan-case-card .scc-header h4 { margin: 0; font-size: 0.9rem; }
.scan-case-card .scc-remove {
  background: none; border: none; color: var(--danger);
  font-size: 1.1rem; cursor: pointer; padding: 4px;
}
.scan-case-card .scc-row {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
  margin-bottom: 6px;
}
.scan-case-card .scc-field { font-size: 0.8rem; }
.scan-case-card .scc-field label { display: block; color: var(--text-dim); font-size: 0.72rem; margin-bottom: 2px; }
.scan-case-card .scc-field input,
.scan-case-card .scc-field select {
  width: 100%;
  padding: 6px 8px;
  background: var(--bg);
  border: 1px solid var(--border);
  border-radius: 6px;
  color: var(--text);
  font-size: 0.82rem;
}
.scan-case-card .scc-tags {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  margin-top: 6px;
}
.scan-case-card .scc-tag {
  font-size: 0.72rem;
  padding: 2px 8px;
  border-radius: 10px;
  background: var(--surface2);
  color: var(--text-dim);
}
.scan-case-card .scc-tag.active { background: rgba(59,130,246,0.2); color: var(--primary); }
.scan-case-card .scc-tag.emergency { background: rgba(239,68,68,0.2); color: var(--danger); }
.scan-case-card .scc-tag.shared { background: rgba(139,92,246,0.2); color: var(--purple); }

/* ===== AUTH OVERLAY ===== */
.auth-overlay {
  position: fixed;
  inset: 0;
  z-index: 9999;
  background: var(--bg);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 24px;
  text-align: center;
}
.auth-overlay h1 { font-size: 1.6rem; margin-bottom: 8px; }
.auth-overlay p { color: var(--text-dim); font-size: 0.85rem; margin-bottom: 24px; max-width: 340px; }
.auth-overlay .auth-disclaimer {
  background: rgba(245,158,11,0.1);
  border: 1px solid rgba(245,158,11,0.3);
  border-radius: var(--radius);
  padding: 12px 16px;
  margin-bottom: 24px;
  max-width: 340px;
  font-size: 0.78rem;
  color: var(--accent2);
  text-align: left;
}
.google-sign-in-btn {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 10px 24px;
  background: #fff;
  color: #333;
  border: none;
  border-radius: 8px;
  font-size: 0.9rem;
  font-weight: 600;
  cursor: pointer;
  transition: box-shadow 0.2s;
}
.google-sign-in-btn:hover { box-shadow: 0 2px 8px rgba(0,0,0,0.3); }
.google-sign-in-btn svg { width: 20px; height: 20px; }
.auth-loading { color: var(--text-dim); font-size: 0.85rem; }
.sync-indicator {
  font-size: 0.7rem;
  color: var(--text-dim);
  padding: 2px 6px;
  border-radius: 4px;
  display: inline-block;
}
.sync-indicator.syncing { color: var(--primary); }
.sync-indicator.synced { color: var(--accent); }
.sync-indicator.error { color: var(--danger); }
.account-card {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  margin-bottom: 12px;
}
.account-card img {
  width: 36px; height: 36px;
  border-radius: 50%;
}
.account-card .ac-info { flex: 1; min-width: 0; }
.account-card .ac-name { font-size: 0.85rem; font-weight: 600; }
.account-card .ac-email { font-size: 0.72rem; color: var(--text-dim); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

/* ===== BOTTOM NAV — 5 items ===== */
.bottom-nav button { font-size: 0.6rem; }
.bottom-nav button .nav-icon { font-size: 1.15rem; }

@media (max-width: 480px) {
  .form-row { grid-template-columns: 1fr; }
  .form-row-3 { grid-template-columns: 1fr 1fr; }
  .template-grid { grid-template-columns: 1fr; }
}
</style>
</head>
<body>

<!-- ===== AUTH OVERLAY ===== -->
<div class="auth-overlay" id="authOverlay">
  <h1>MWA Point Tracker</h1>
  <p>Track anesthesia cases, shifts, and production points.</p>
  <div class="auth-disclaimer">
    <strong>Important:</strong> Do not store any patient-identifiable information (names, MRNs, account numbers, DOBs) in this app. Only record procedure types, times, and point data.
  </div>
  <button class="google-sign-in-btn" id="googleSignInBtn">
    <svg viewBox="0 0 24 24"><path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92a5.06 5.06 0 0 1-2.2 3.32v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.1z"/><path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/><path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/><path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/></svg>
    Sign in with Google
  </button>
  <p id="authError" style="color:var(--danger);font-size:0.8rem;margin-top:12px;" class="hidden"></p>
  <p class="auth-loading hidden" id="authLoading">Signing in...</p>
</div>

<!-- ===== HEADER ===== -->
<header>
  <h1>MWA Points</h1>
  <button class="header-date-btn" id="headerDateBtn"></button>
  <span class="header-pts" id="headerPoints"><span class="daily">0 pts</span><br><span class="monthly">0 mo</span></span>
</header>

<!-- ===== PAGES ===== -->

<!-- DATA ENTRY PAGE -->
<div class="page active" id="page-dataentry">
  <!-- Sticky header: tally + summary bar -->
  <div class="de-sticky-header" id="deStickyHeader">
    <div class="daily-tally" id="deTallyBar">
      <span class="tally-label">Daily Points</span>
      <span class="tally-value" id="deTallyValue">0</span>
    </div>
    <div class="shift-summary-bar hidden" id="deShiftSummaryBar">
      <div class="ssb-info">
        <span class="ssb-badge" id="deSSBBadge">OR</span>
        <span class="ssb-times" id="deSSBTimes">07:00 - 17:00</span>
      </div>
      <span class="ssb-edit">Edit &#9998;</span>
    </div>
  </div>
  <div id="deStickyHeaderSpacer"></div>

  <!-- Shift section (all existing shift HTML, IDs preserved) -->
  <div id="deShiftSection">
    <button class="btn btn-sm btn-outline hidden" id="backToShiftLogsBtn" onclick="navigateToShiftLogs()" style="margin-bottom:10px;font-size:0.8rem;">&larr; Back to Shift Logs</button>
    <div class="hidden" id="editShiftBanner" style="background:rgba(59,130,246,0.15); border:1px solid var(--primary); border-radius:var(--radius); padding:10px 14px; margin-bottom:12px; font-size:0.82rem; color:var(--primary); font-weight:600;"></div>
    <div class="end-time-warning hidden" id="endTimeWarning">
      Shift end time is missing — AR points will be 0 until an end time is entered.
    </div>
    <div class="card">
      <div class="card-collapse-header" id="templateCollapseHeader">
        <h2>Quick Templates</h2>
        <span class="arrow" id="templateArrow">&#9660;</span>
      </div>
      <div class="card-collapse-body" id="templateCollapseBody" style="max-height:0;">
        <div class="template-grid" id="templateGrid" style="padding-top:12px;"></div>
      </div>
    </div>

    <div class="card">
      <h2>Shift Setup</h2>

      <div class="form-group" style="display:none;">
        <label>Date</label>
        <input type="date" id="shiftDate">
      </div>

      <div class="form-group">
        <label>Assignment Type</label>
        <select id="shiftAssignmentType">
          <option value="OR">OR / General</option>
          <option value="OB_restricted">UVH OB</option>
          <option value="cardiac_liver">Cardiac / Liver</option>
          <option value="mole">Mole</option>
          <option value="1st_call">1st Call</option>
          <option value="2nd_call">2nd Call</option>
          <option value="3rd_call">3rd Call</option>
          <option value="4th_call">4th Call</option>
          <option value="endo">Endo</option>
          <option value="SF1">SF 1</option>
          <option value="SF2">SF 2</option>
          <option value="ACS">ACS</option>
          <option value="NORA">NORA</option>
          <option value="pre_call">Pre-Call</option>
          <option value="CRNA_supervision">CRNA Supervision</option>
          <option value="forced_off">Forced Off</option>
          <option value="vacation">Vacation / Off</option>
        </select>
      </div>

      <div id="vacationRangeSection" class="hidden">
        <div class="form-group">
          <label>Vacation End Date <span style="font-size:0.75rem;color:var(--text-dim);">(optional — leave blank for single day)</span></label>
          <input type="date" id="vacationEndDate" class="settings-input">
        </div>
      </div>

      <div class="form-group" id="timeEntriesGroup">
        <label id="timeEntriesLabel">Time Entries</label>
        <div id="timeEntriesContainer">
          <div class="time-entry-row">
            <input type="text" inputmode="numeric" placeholder="HH:MM" maxlength="5" class="mil-time te-start" value="07:00">
            <span class="te-label">to</span>
            <input type="text" inputmode="numeric" placeholder="HH:MM" maxlength="5" class="mil-time te-end" value="17:00">
            <button type="button" class="remove-entry-btn" disabled>&times;</button>
          </div>
        </div>
        <button type="button" class="add-entry-btn" id="addTimeEntryBtn">+ Add Time Entry</button>
      </div>

      <div class="checkbox-group">
        <input type="checkbox" id="shiftHoliday">
        <label for="shiftHoliday">Holiday</label>
      </div>

      <div class="checkbox-group hidden" id="shiftForcedOffGroup">
        <input type="checkbox" id="shiftForcedOff">
        <label for="shiftForcedOff">Forced Off (no cases)</label>
      </div>

      <div id="cardiacLiverOptions" class="hidden">
        <div class="divider"></div>
        <h3>Subspecialty Options</h3>
        <div class="checkbox-group">
          <input type="checkbox" id="subspecCoverage">
          <label for="subspecCoverage">Subspecialty coverage (45 pts/day)</label>
        </div>
        <div class="form-group">
          <label>TEE Exams Performed</label>
          <input type="number" id="teeCount" value="0" min="0">
        </div>
      </div>

      <div id="supervisionOverlaySection" class="hidden">
        <div class="divider"></div>
        <h3>CRNA Supervision</h3>
        <div class="checkbox-group">
          <input type="checkbox" id="supervisionOverlayCheck">
          <label for="supervisionOverlayCheck">Add CRNA supervision period (7 pts/hr)</label>
        </div>
        <div class="form-row hidden" id="supervisionTimes">
          <div class="form-group">
            <label>Supervision Start</label>
            <input type="text" inputmode="numeric" placeholder="HH:MM" maxlength="5" class="mil-time" id="supervisionStart">
          </div>
          <div class="form-group">
            <label>Supervision End</label>
            <input type="text" inputmode="numeric" placeholder="HH:MM" maxlength="5" class="mil-time" id="supervisionEnd">
          </div>
        </div>
      </div>

      <div id="preCallOverlaySection" class="hidden">
        <div class="divider"></div>
        <h3>Pre-Call</h3>
        <div class="checkbox-group">
          <input type="checkbox" id="preCallOverlayCheck">
          <label for="preCallOverlayCheck">Add pre-call OR period</label>
        </div>
        <div class="form-row hidden" id="preCallTimes">
          <div class="form-group">
            <label>Pre-Call Start</label>
            <input type="text" inputmode="numeric" placeholder="HH:MM" maxlength="5" class="mil-time" id="preCallStartInput">
          </div>
          <div class="form-group">
            <label>Pre-Call End</label>
            <input type="text" inputmode="numeric" placeholder="HH:MM" maxlength="5" class="mil-time" id="preCallEndInput">
          </div>
        </div>
      </div>

      <div id="tempCoverageSection" class="hidden">
        <div class="divider"></div>
        <h3>Temporary Coverage</h3>
        <div class="checkbox-group">
          <input type="checkbox" id="tempCoverageCheck">
          <label for="tempCoverageCheck">Add temporary coverage period</label>
        </div>
        <div class="hidden" id="tempCoverageForm">
          <div class="form-group" style="margin-top:8px;">
            <label>Direction</label>
            <div style="display:flex;gap:16px;">
              <label style="display:flex;align-items:center;gap:4px;font-size:0.85rem;cursor:pointer;">
                <input type="radio" name="tcDirection" value="covered" checked> Someone covering for me
              </label>
              <label style="display:flex;align-items:center;gap:4px;font-size:0.85rem;cursor:pointer;">
                <input type="radio" name="tcDirection" value="covering"> I'm covering for someone
              </label>
            </div>
          </div>
          <div class="form-row" style="margin-top:8px;">
            <div class="form-group">
              <label>Coverage Start</label>
              <input type="text" inputmode="numeric" placeholder="HH:MM" maxlength="5" class="mil-time" id="tcStart">
            </div>
            <div class="form-group">
              <label>Coverage End</label>
              <input type="text" inputmode="numeric" placeholder="HH:MM" maxlength="5" class="mil-time" id="tcEnd">
            </div>
          </div>
          <div id="tcTimeEntriesSection" class="hidden">
            <div class="form-group" style="margin-top:8px;">
              <label>Work Time Entries <span style="font-size:0.75rem;color:var(--text-dim);">(clock-in during coverage)</span></label>
              <div id="tcTimeEntriesContainer"></div>
              <button type="button" class="add-entry-btn" id="addTCTimeEntryBtn">+ Add Coverage Entry</button>
            </div>
          </div>
        </div>
      </div>

      <div id="eveningAssignmentSection" class="hidden">
        <div class="divider"></div>
        <div class="form-group">
          <label>Evening Assignment</label>
          <select id="eveningAssignmentType">
            <option value="">None</option>
            <option value="mole">Mole</option>
            <option value="OB_restricted">UVH OB</option>
          </select>
        </div>
        <div id="eveningTimeSection" class="hidden">
          <div class="form-group">
            <label>Evening Time Entries <span style="font-size:0.75rem;color:var(--text-dim);">(leave blank if no clock-in)</span></label>
            <div id="eveningTimeEntriesContainer"></div>
            <button type="button" class="add-entry-btn" id="addEveningTimeEntryBtn">+ Add Evening Entry</button>
          </div>
        </div>
      </div>

      <div style="margin-top: 16px; display:flex; gap:10px; align-items:center;">
        <button class="btn btn-primary" id="saveShiftBtn">Save Shift</button>
        <button class="btn btn-outline btn-sm hidden" id="switchToCaseEntryBtn" style="font-size:0.8rem;">Add Cases &rarr;</button>
        <button class="btn btn-danger btn-sm hidden" id="deleteShiftDE" style="margin-left:auto;">Delete Shift</button>
      </div>
    </div>
  </div>

  <!-- Case section (hidden until shift is saved) -->
  <div id="deCaseSection" class="hidden">
    <button class="btn btn-outline btn-sm" id="switchToShiftEntryBtn" style="margin-bottom:10px;font-size:0.8rem;">&larr; Edit Shift</button>
    <div class="card">
      <div class="card-collapse-header" id="quickProcCollapseHeader">
        <h2>Quick Procedures</h2>
        <span class="arrow" id="quickProcArrow">&#9660;</span>
      </div>
      <div class="card-collapse-body" id="quickProcCollapseBody" style="max-height:0;">
        <div class="template-grid" style="padding-top:12px;">
          <button class="template-btn" data-qproc="colonoscopy">
            <span class="t-label">Colonoscopy</span>
            <span class="t-time">4 base units</span>
          </button>
          <button class="template-btn" data-qproc="egd">
            <span class="t-label">EGD</span>
            <span class="t-time">5 base units</span>
          </button>
          <button class="template-btn" data-qproc="double">
            <span class="t-label">Double / EGD+Colo</span>
            <span class="t-time">5 base units</span>
          </button>
          <button class="template-btn" data-qproc="tonsils">
            <span class="t-label">Tonsils</span>
            <span class="t-time">5 base units</span>
          </button>
        </div>
      </div>
    </div>

    <div class="card">
      <h2>Log a Case</h2>

      <div class="form-group">
        <label>Case Type</label>
        <select id="caseTypeSelect">
          <option value="standard" selected>Standard Case</option>
          <option value="labor_epidural">Labor Epidural</option>
          <option value="acute_pain_procedure">Acute Pain Procedure</option>
          <option value="epidural_blood_patch">Epidural Blood Patch</option>
          <option value="emergency_intubation">Emergency Intubation</option>
          <option value="01996">Epidural Rounding (01996)</option>
          <option value="99231">Pain Rounding (99231)</option>
          <option value="tee">TEE Exam</option>
          <option value="aps_rounding">APS Rounding</option>
        </select>
      </div>

      <div id="standardFields">
        <div class="form-group proc-autocomplete">
          <label>Procedure Name</label>
          <input type="text" id="caseProcedure" placeholder="e.g., Lap Chole, Total Knee" autocomplete="off">
          <div class="proc-suggestions hidden" id="procSuggestions"></div>
        </div>

        <div class="form-row">
          <div class="form-group">
            <label>ASA Base Units</label>
            <input type="number" id="caseBaseUnits" min="0" step="1" placeholder="Units">
          </div>
          <div class="form-group">
            <label>Physical Status</label>
            <select id="casePhysicalStatus">
              <option value="P1">P1</option>
              <option value="P2" selected>P2</option>
              <option value="P3">P3</option>
              <option value="P4">P4</option>
              <option value="P5">P5</option>
            </select>
          </div>
        </div>

        <div class="form-row">
          <div class="form-group">
            <label>Anesthesia Start</label>
            <input type="text" inputmode="numeric" placeholder="HH:MM" maxlength="5" class="mil-time" id="caseStart">
          </div>
          <div class="form-group">
            <label>Anesthesia End</label>
            <input type="text" inputmode="numeric" placeholder="HH:MM" maxlength="5" class="mil-time" id="caseEnd">
          </div>
        </div>

        <details class="modifiers-section" id="modifiersSection">
          <summary>Modifiers <span class="modifier-tags" id="modifierTags"></span></summary>
          <div style="padding:8px 0 4px;">
            <div class="checkbox-group">
              <input type="checkbox" id="caseEmergency">
              <label for="caseEmergency">Emergency Case (+1 pt)</label>
            </div>
            <div class="checkbox-group">
              <input type="checkbox" id="caseHighRiskPeds">
              <label for="caseHighRiskPeds">High Risk Pediatrics (1.33x time)</label>
            </div>
            <div class="checkbox-group hidden" id="orCaseRow">
              <input type="checkbox" id="caseORCase">
              <label for="caseORCase">OR Case (use OR rates, no OB doubling)</label>
            </div>
            <div class="checkbox-group">
              <input type="checkbox" id="caseShared">
              <label for="caseShared">Shared/Split Case</label>
            </div>
            <div class="form-group hidden" id="sharedPctRow">
              <label>Startup Points Credit %</label>
              <input type="number" id="caseSharedPct" min="0" max="100" value="50" step="1">
            </div>
          </div>
        </details>

        <details class="modifiers-section">
          <summary>Additional Procedures</summary>
          <div style="padding:8px 0 4px;">
            <div class="form-group">
              <label>Nerve Block</label>
              <select id="caseNerveBlock">
                <option value="none">None</option>
                <option value="brachial_plexus">Brachial Plexus (3 pts)</option>
                <option value="other">Other (2.6 pts)</option>
                <option value="it_morphine">IT Morphine (3 pts)</option>
              </select>
            </div>
            <div class="form-row">
              <div class="checkbox-group">
                <input type="checkbox" id="caseCentralLine">
                <label for="caseCentralLine">Central Line (0.8 pts)</label>
              </div>
              <div class="checkbox-group">
                <input type="checkbox" id="caseArterialLine">
                <label for="caseArterialLine">Arterial Line (0.6 pts)</label>
              </div>
            </div>
            <div class="form-row">
              <div class="checkbox-group">
                <input type="checkbox" id="casePAC">
                <label for="casePAC">PAC (2 pts)</label>
              </div>
              <div class="checkbox-group">
                <input type="checkbox" id="caseTEEAddOn">
                <label for="caseTEEAddOn">TEE (0.4 pts)</label>
              </div>
            </div>
            <div class="checkbox-group">
              <input type="checkbox" id="caseITMorphine">
              <label for="caseITMorphine">IT Morphine (3 pts)</label>
            </div>
          </div>
        </details>
      </div>

      <div id="laborEpiduralFields" class="hidden">
        <div class="form-row">
          <div class="form-group">
            <label>Epidural Start</label>
            <input type="text" inputmode="numeric" placeholder="HH:MM" maxlength="5" class="mil-time" id="laborStart">
          </div>
          <div class="form-group">
            <label>Epidural End</label>
            <input type="text" inputmode="numeric" placeholder="HH:MM" maxlength="5" class="mil-time" id="laborEnd">
          </div>
        </div>
      </div>

      <div id="apsRoundingFields" class="hidden">
        <div class="form-row">
          <div class="form-group">
            <label>Epidural Rounds (3 pts each)</label>
            <input type="number" id="apsEpiduralCount" min="0" step="1" value="0">
          </div>
          <div class="form-group">
            <label>Pain Rounds (2 pts each)</label>
            <input type="number" id="apsPainCount" min="0" step="1" value="0">
          </div>
        </div>
      </div>

      <div id="simpleFields" class="hidden">
        <div class="form-group">
          <label>Procedure Notes (optional)</label>
          <input type="text" id="simpleNotes" placeholder="Optional notes">
        </div>
      </div>

      <div class="form-group">
        <label>Notes (optional)</label>
        <textarea id="caseNotes" placeholder="Surgeon, location, or other notes"></textarea>
      </div>

      <div id="casePointPreview" class="point-breakdown hidden">
        <div class="row"><span>Estimated Points</span><span id="previewPoints">--</span></div>
      </div>

      <div style="margin-top: 16px;">
        <button class="btn btn-primary" id="saveCaseBtn">Save Case</button>
      </div>
    </div>
  </div>

  <!-- Daily case list -->
  <div class="card" id="deCaseListCard">
    <h2>Cases Today <span id="deCaseCount" style="font-size:0.8rem;color:var(--text-dim);font-weight:400;"></span></h2>
    <div class="de-case-list" id="deCaseList">
      <p style="color:var(--text-dim);font-size:0.85rem;">No cases logged yet.</p>
    </div>
  </div>
</div>

<!-- TODAY PAGE -->
<div class="page" id="page-today">
  <div id="todayBackBar" class="hidden" style="display:none;align-items:center;gap:8px;margin-bottom:8px;">
    <button class="btn btn-outline btn-sm" id="todayBackBtn" style="padding:4px 12px;font-size:0.8rem;">&larr; Daily</button>
  </div>
  <div class="card">
    <div style="display:flex;align-items:center;justify-content:space-between;">
      <h2 id="todayTitle" style="margin:0;">Today's Summary</h2>
      <button class="btn btn-outline btn-sm hidden" id="todayEditShiftBtn" style="padding:4px 10px;font-size:0.72rem;">Edit Shift</button>
    </div>
    <div class="summary-grid">
      <div class="summary-item">
        <div class="label">Availability (AR)</div>
        <div class="value blue" id="todayAR">0</div>
      </div>
      <div class="summary-item">
        <div class="label">Productivity</div>
        <div class="value green" id="todayProd">0</div>
      </div>
      <div class="summary-item">
        <div class="label">Call / Other</div>
        <div class="value yellow" id="todayCall">0</div>
      </div>
      <div class="summary-item">
        <div class="label">Total Points</div>
        <div class="value" id="todayTotal">0</div>
      </div>
    </div>
  </div>

  <div class="card" id="todayBreakdownCard">
    <h2>Point Breakdown</h2>
    <div id="todayBreakdown"></div>
  </div>

  <div class="card">
    <h2>Cases <span id="todayCaseCount"></span></h2>
    <div id="todayCaseList">
      <div class="empty-state">
        <p>No cases logged yet.</p>
      </div>
    </div>
  </div>
</div>

<!-- RECONCILE PAGE -->
<div class="page" id="page-reconcile">
  <div class="tab-bar">
    <button class="tab-btn active" data-rtab="qgenda">QGenda Time</button>
    <button class="tab-btn" data-rtab="production">Production</button>
  </div>

  <!-- QGenda Tab -->
  <div id="rtab-qgenda">
    <div class="card">
      <h2>QGenda Time Reconciliation</h2>
      <p style="font-size:0.8rem;color:var(--text-dim);margin-bottom:12px;">
        Upload your QGenda time punch export (.xlsx or .csv) or screenshot to compare against your tracked shifts.
      </p>
      <div class="upload-area" id="qgendaUploadArea">
        <div style="font-size:2rem;">&#128196;</div>
        <p>Tap to upload QGenda .xlsx, .csv, or screenshot</p>
        <input type="file" id="qgendaFile" accept=".xlsx,.xls,.csv,.png,.jpg,.jpeg">
      </div>
    </div>

    <div class="month-nav" style="margin-top:12px;">
      <button id="qPrevMonth">&larr;</button>
      <span id="qMonthLabel">January 2026</span>
      <button id="qNextMonth">&rarr;</button>
    </div>

    <div id="qgendaResults"></div>
  </div>

  <!-- Production Tab -->
  <div id="rtab-production" class="hidden">
    <div class="card">
      <h2>Production Reconciliation</h2>
      <p style="font-size:0.8rem;color:var(--text-dim);margin-bottom:12px;">
        Upload your Charge Detail PDF or screenshot to compare billing production against your tracked cases.
      </p>
      <div class="upload-area" id="prodUploadArea">
        <div style="font-size:2rem;">&#128196;</div>
        <p>Tap to upload Charge Detail PDF or screenshot</p>
        <input type="file" id="prodFile" accept=".pdf,.png,.jpg,.jpeg">
      </div>
    </div>

    <div class="month-nav" style="margin-top:12px;">
      <button id="pPrevMonth">&larr;</button>
      <span id="pMonthLabel">January 2026</span>
      <button id="pNextMonth">&rarr;</button>
    </div>

    <div id="prodResults"></div>
  </div>

</div>

<!-- DASHBOARD PAGE -->
<div class="page" id="page-dashboard">
  <div class="dash-sticky-header" id="dashStickyHeader">
    <div class="dash-tab-bar">
      <button class="dash-tab-btn active" data-dtab="daily">Daily</button>
      <button class="dash-tab-btn" data-dtab="caselogs">Case Logs</button>
      <button class="dash-tab-btn" data-dtab="shiftlogs">Shift Logs</button>
      <button class="dash-tab-btn" data-dtab="projections">Projections</button>
      <button class="dash-tab-btn" data-dtab="time">Time</button>
      <button class="dash-tab-btn" data-dtab="analytics">Analytics</button>
    </div>
  </div>
  <div id="dashStickyHeaderSpacer"></div>

  <!-- Case Logs Tab -->
  <div id="dtab-caselogs" class="hidden">
    <div class="month-nav">
      <button id="clPrevMonth">&larr;</button>
      <span id="clMonthLabel">January 2026</span>
      <button id="clNextMonth">&rarr;</button>
    </div>
    <input type="text" class="case-log-search" id="caseLogSearch" placeholder="Search cases...">
    <button id="clDeleteSelectedBtn" class="hidden">Delete Selected (<span id="clDeleteSelectedCount">0</span>)</button>
    <div class="case-log-wrap">
      <div id="caseLogTableContainer">
        <div class="empty-state"><p>No cases for this month.</p></div>
      </div>
    </div>
  </div>

  <!-- Shift Logs Tab -->
  <div id="dtab-shiftlogs" class="hidden">
    <div class="month-nav">
      <button id="slPrevMonth">&larr;</button>
      <span id="slMonthLabel">January 2026</span>
      <button id="slNextMonth">&rarr;</button>
    </div>
    <div class="card" id="shiftLogSummary"></div>
    <input type="text" class="case-log-search" id="shiftLogSearch" placeholder="Search shifts...">
    <div id="slDeleteBar" class="sl-delete-bar hidden">
      <span class="sl-del-count" id="slDeleteCount">0 selected</span>
      <button class="sl-del-action" onclick="deleteSelectedShifts()">Delete Selected</button>
    </div>
    <div class="case-log-wrap">
      <div id="shiftLogTableContainer">
        <div class="empty-state"><p>No shifts for this month.</p></div>
      </div>
    </div>
  </div>

  <!-- Projections Tab -->
  <div id="dtab-projections" class="hidden">
    <!-- Point Value Input -->
    <div class="card" style="display:flex; align-items:center; gap:12px; padding:12px 16px;">
      <label style="font-size:0.85rem; font-weight:600; white-space:nowrap;">$/point</label>
      <input type="number" id="dashPointValue" min="0" step="0.01" placeholder="e.g. 55.00" style="max-width:120px;">
    </div>

    <!-- Stabilization Card -->
    <div class="card">
      <h2>Stabilization-Weighted Points</h2>
      <p style="font-size:0.8rem; color:var(--text-dim); margin-bottom:12px;">
        Weighted: 10% current + 40% prior + 25% 2-mo + 15% 3-mo + 10% 4-mo
      </p>
      <div class="summary-grid">
        <div class="summary-item">
          <div class="label">Raw This Month</div>
          <div class="value blue" id="stabRaw">0</div>
        </div>
        <div class="summary-item">
          <div class="label">Stabilized</div>
          <div class="value green" id="stabWeighted">0</div>
        </div>
      </div>
      <div id="stabPaycheckRow" style="margin-top:12px; text-align:center;">
        <div style="font-size:1.3rem; font-weight:700; color:var(--accent2);" id="stabPaycheck">&mdash;</div>
        <div style="font-size:0.75rem; color:var(--text-dim); margin-top:4px;" id="stabPaycheckLabel">Projected next month's paycheck</div>
      </div>
    </div>

    <!-- Monthly Trend Chart -->
    <div class="card">
      <h2>Monthly Trend</h2>
      <div class="chart-container">
        <canvas id="monthlyChart"></canvas>
      </div>
      <div id="monthlyChartSummary" style="margin-top:10px; font-size:0.82rem; color:var(--text-dim); text-align:center;"></div>
    </div>

    <!-- Projected Annual Income -->
    <div class="card">
      <h2>Projected Annual Income</h2>
      <div class="summary-grid">
        <div class="summary-item">
          <div class="label">3-Month Rolling Avg</div>
          <div class="value blue" id="projRollingAvg">0</div>
        </div>
        <div class="summary-item">
          <div class="label">Annual Projection</div>
          <div class="value green" id="projAnnualIncome">&mdash;</div>
        </div>
      </div>
      <div class="summary-grid" style="margin-top:8px;">
        <div class="summary-item">
          <div class="label">YTD Revenue</div>
          <div class="value yellow" id="projYTDRevenue">&mdash;</div>
        </div>
        <div class="summary-item">
          <div class="label">Projected Remaining</div>
          <div class="value purple" id="projRemaining">&mdash;</div>
        </div>
      </div>
      <div id="projYTDDetail" style="margin-top:8px; font-size:0.78rem; color:var(--text-dim); text-align:center;"></div>
    </div>

    <!-- Pace Tracker -->
    <div class="card">
      <h2>Monthly Pace</h2>
      <div class="summary-grid">
        <div class="summary-item">
          <div class="label">This Month So Far</div>
          <div class="value blue" id="paceCurrentPts">0</div>
        </div>
        <div class="summary-item">
          <div class="label">Projected End-of-Month</div>
          <div class="value green" id="paceProjected">0</div>
        </div>
      </div>
      <div style="margin-top:8px;">
        <div style="background:var(--surface2); border-radius:6px; height:10px; overflow:hidden;">
          <div id="paceBar" style="height:100%; background:var(--primary); border-radius:6px; transition:width 0.3s; width:0%;"></div>
        </div>
        <div id="paceLabel" style="font-size:0.75rem; color:var(--text-dim); margin-top:4px; text-align:center;"></div>
      </div>
    </div>

    <!-- Stabilization Pipeline -->
    <div class="card">
      <h2>Income Pipeline</h2>
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
        <p style="font-size:0.78rem; color:var(--text-dim); margin:0;">
          Estimated paychecks from recorded data
        </p>
        <label class="toggle-row">
          <span>Include projections</span>
          <span class="toggle-switch">
            <input type="checkbox" id="pipelineProjectToggle">
            <span class="slider"></span>
          </span>
        </label>
      </div>
      <div class="chart-container">
        <canvas id="pipelineChart"></canvas>
      </div>
      <div id="pipelineSummary" style="margin-top:8px; font-size:0.78rem; color:var(--text-dim); text-align:center;"></div>
    </div>

    <!-- Points Per Shift Type -->
    <div class="card collapse-section">
      <div class="collapse-header" onclick="toggleCollapse('projPtsPerType')">
        <h3>Avg Points by Shift Type</h3>
        <span class="arrow" id="projPtsPerTypeArrow">&#9660;</span>
      </div>
      <div class="collapse-body" id="projPtsPerTypeBody">
        <div id="ptsPerTypeContent" style="padding-top:12px;"></div>
      </div>
    </div>

    <!-- Collapsible: Breakdown Chart -->
    <div class="card collapse-section">
      <div class="collapse-header" onclick="toggleCollapse('projBreakdown')">
        <h3>Points Breakdown (This Month)</h3>
        <span class="arrow" id="projBreakdownArrow">&#9660;</span>
      </div>
      <div class="collapse-body" id="projBreakdownBody">
        <div class="chart-container" style="margin-top:12px;">
          <canvas id="breakdownChart"></canvas>
        </div>
      </div>
    </div>

    <!-- Collapsible: Shift Efficiency -->
    <div class="card collapse-section">
      <div class="collapse-header" onclick="toggleCollapse('projEfficiency')">
        <h3>Most / Least Efficient Shifts</h3>
        <span class="arrow" id="projEfficiencyArrow">&#9660;</span>
      </div>
      <div class="collapse-body" id="projEfficiencyBody">
        <div id="efficiencyContent" style="padding-top:12px;"></div>
      </div>
    </div>

    <!-- Collapsible: Case Type Efficiency -->
    <div class="card collapse-section">
      <div class="collapse-header" onclick="toggleCollapse('projCaseEff')">
        <h3>Most Efficient Case Types</h3>
        <span class="arrow" id="projCaseEffArrow">&#9660;</span>
      </div>
      <div class="collapse-body" id="projCaseEffBody">
        <div id="caseEffContent" style="padding-top:12px;"></div>
      </div>
    </div>

    <!-- Collapsible: Month-over-Month -->
    <div class="card collapse-section">
      <div class="collapse-header" onclick="toggleCollapse('projMoM')">
        <h3>Month-over-Month Change</h3>
        <span class="arrow" id="projMoMArrow">&#9660;</span>
      </div>
      <div class="collapse-body" id="projMoMBody">
        <div id="momContent" style="padding-top:12px;"></div>
      </div>
    </div>
  </div>

  <!-- Time Tab -->
  <div id="dtab-time" class="hidden">
    <!-- Summary Cards -->
    <div class="card">
      <h2>Time Summary (Past 3 Months)</h2>
      <div class="summary-grid">
        <div class="summary-item">
          <div class="label">Avg Hours/Month</div>
          <div class="value blue" id="timeAvgMonth">0</div>
        </div>
        <div class="summary-item">
          <div class="label">Avg Hours/Week</div>
          <div class="value green" id="timeAvgWeek">0</div>
        </div>
        <div class="summary-item">
          <div class="label">Avg Shift Start</div>
          <div class="value yellow" id="timeAvgStart">--:--</div>
        </div>
        <div class="summary-item">
          <div class="label">Avg Shift End</div>
          <div class="value purple" id="timeAvgEnd">--:--</div>
        </div>
      </div>
    </div>

    <!-- Production Trend -->
    <div class="card">
      <h2>Monthly Production Trend</h2>
      <div class="chart-container">
        <canvas id="productionTrendChart"></canvas>
      </div>
    </div>

    <!-- Collapsible: Day-of-Week Breakdown -->
    <div class="card collapse-section">
      <div class="collapse-header" onclick="toggleCollapse('timeDOW')">
        <h3>Day-of-Week Breakdown</h3>
        <span class="arrow" id="timeDOWArrow">&#9660;</span>
      </div>
      <div class="collapse-body" id="timeDOWBody">
        <div id="dowContent" style="padding-top:12px;"></div>
      </div>
    </div>

    <!-- Collapsible: Weekend vs Weekday -->
    <div class="card collapse-section">
      <div class="collapse-header" onclick="toggleCollapse('timeWknd')">
        <h3>Weekend vs Weekday</h3>
        <span class="arrow" id="timeWkndArrow">&#9660;</span>
      </div>
      <div class="collapse-body" id="timeWkndBody">
        <div id="wkndContent" style="padding-top:12px;"></div>
      </div>
    </div>

    <!-- Collapsible: Night & Call Frequency -->
    <div class="card collapse-section">
      <div class="collapse-header" onclick="toggleCollapse('timeNight')">
        <h3>Night &amp; Call Shift Frequency</h3>
        <span class="arrow" id="timeNightArrow">&#9660;</span>
      </div>
      <div class="collapse-body" id="timeNightBody">
        <div id="nightContent" style="padding-top:12px;"></div>
      </div>
    </div>
  </div>

  <!-- Analytics Tab -->
  <div id="dtab-analytics" class="hidden">
    <!-- Case Mix -->
    <div class="card">
      <h2>Case Mix</h2>
      <div id="caseMixContent">
        <div class="empty-state"><p>No case data.</p></div>
      </div>
    </div>

    <!-- Collapsible: Add-on Utilization -->
    <div class="card collapse-section">
      <div class="collapse-header" onclick="toggleCollapse('analAddOns')">
        <h3>Additional Procedure Utilization</h3>
        <span class="arrow" id="analAddOnsArrow">&#9660;</span>
      </div>
      <div class="collapse-body" id="analAddOnsBody">
        <div id="addOnContent" style="padding-top:12px;"></div>
      </div>
    </div>

    <!-- Collapsible: Top Procedures by Points/Hour -->
    <div class="card collapse-section">
      <div class="collapse-header" onclick="toggleCollapse('analTopProc')">
        <h3>Top Procedures by Pts/Hr</h3>
        <span class="arrow" id="analTopProcArrow">&#9660;</span>
      </div>
      <div class="collapse-body" id="analTopProcBody">
        <div id="topProcContent" style="padding-top:12px;"></div>
      </div>
    </div>

    <!-- Collapsible: Average Units per Case -->
    <div class="card collapse-section">
      <div class="collapse-header" onclick="toggleCollapse('analAvgUnits')">
        <h3>Average Units per Case</h3>
        <span class="arrow" id="analAvgUnitsArrow">&#9660;</span>
      </div>
      <div class="collapse-body" id="analAvgUnitsBody">
        <div id="avgUnitsContent" style="padding-top:12px;"></div>
      </div>
    </div>

    <!-- Shift Type Distribution -->
    <div class="card collapse-section">
      <div class="collapse-header" onclick="toggleCollapse('analShiftDist')">
        <h3>Shift Type Distribution</h3>
        <span class="arrow" id="analShiftDistArrow">&#9660;</span>
      </div>
      <div class="collapse-body" id="analShiftDistBody">
        <div class="chart-container" style="margin-top:12px;">
          <canvas id="shiftDistChart"></canvas>
        </div>
      </div>
    </div>
  </div>

  <!-- Daily Totals Tab -->
  <div id="dtab-daily">
    <div class="month-nav">
      <button id="dailyPrevMonth">&larr;</button>
      <span id="dailyMonthLabel">January 2026</span>
      <button id="dailyNextMonth">&rarr;</button>
    </div>
    <div id="dailyCalendarContainer" style="margin-top:12px;"></div>
    <div id="dailyMonthSummary" style="margin-top:12px;font-size:0.85rem;color:var(--text-dim);text-align:center;"></div>
  </div>
</div>

<!-- SETTINGS PAGE -->
<div class="page" id="page-settings">
  <!-- Settings -->
  <div class="card">
    <h2>Settings</h2>
    <div class="settings-field">
      <label>Name</label>
      <input type="text" id="settingsName" placeholder="Your name (labels exports)">
    </div>
    <div class="settings-field" style="margin-top:12px;">
      <label>Point Value ($/pt)</label>
      <input type="number" id="settingsPointValue" min="0" step="0.01" style="max-width:140px;">
    </div>
    <label class="toggle-row" style="margin-top:12px;">
      <span>December advance paycheck</span>
      <span class="toggle-switch">
        <input type="checkbox" id="decAdvanceToggle" checked>
        <span class="slider"></span>
      </span>
    </label>
    <p style="font-size:0.72rem;color:var(--text-dim);margin-top:4px;">
      December includes January's paycheck advance; January shows $0.
    </p>
  </div>

  <!-- History -->
  <div class="card">
    <h2>Monthly History</h2>
    <div class="month-nav">
      <button id="prevMonth">&larr;</button>
      <span id="historyMonth">January 2026</span>
      <button id="nextMonth">&rarr;</button>
    </div>
    <div class="summary-grid">
      <div class="summary-item">
        <div class="label">Monthly Total</div>
        <div class="value blue" id="monthTotal">0</div>
      </div>
      <div class="summary-item">
        <div class="label">Days Worked</div>
        <div class="value green" id="monthDays">0</div>
      </div>
    </div>
    <div id="historyList">
      <div class="empty-state"><p>No shifts recorded for this month.</p></div>
    </div>
  </div>

  <!-- Monthly Override -->
  <div class="card">
    <h2>Monthly Point Override</h2>
    <p style="font-size:0.8rem;color:var(--text-dim);margin-bottom:12px;">
      Override calculated points for a month to match QGenda or billing records.
    </p>
    <div class="month-nav">
      <button id="ovPrevMonth">&larr;</button>
      <span id="ovMonthLabel">January 2026</span>
      <button id="ovNextMonth">&rarr;</button>
    </div>
    <div style="display:flex;gap:12px;margin-top:12px;">
      <div style="flex:1;">
        <label style="display:block;font-size:0.75rem;color:var(--text-dim);margin-bottom:4px;">Time Points</label>
        <input type="number" id="overrideTimePoints" min="0" step="0.01" placeholder="Calculated: —" style="width:100%;padding:8px 10px;border-radius:6px;border:1px solid var(--border);background:var(--surface);color:var(--text);font-size:0.85rem;min-height:40px;">
      </div>
      <div style="flex:1;">
        <label style="display:block;font-size:0.75rem;color:var(--text-dim);margin-bottom:4px;">Production Points</label>
        <input type="number" id="overrideProdPoints" min="0" step="0.01" placeholder="Calculated: —" style="width:100%;padding:8px 10px;border-radius:6px;border:1px solid var(--border);background:var(--surface);color:var(--text);font-size:0.85rem;min-height:40px;">
      </div>
    </div>
    <div style="margin-top:10px;display:flex;gap:8px;">
      <button class="btn btn-primary btn-sm" id="saveOverrideBtn">Save Override</button>
      <button class="btn btn-outline btn-sm" id="clearOverrideBtn">Clear</button>
    </div>
    <div id="overrideStatus" style="font-size:0.75rem;color:var(--text-dim);margin-top:8px;"></div>
  </div>

  <!-- Monthly Stipends -->
  <div class="card">
    <h2>Monthly Stipends</h2>
    <p style="font-size:0.8rem;color:var(--text-dim);margin-bottom:12px;">
      Add fixed dollar amounts per month (e.g., medical director stipend, teaching pay). These contribute to revenue totals but not point calculations.
    </p>
    <div class="month-nav">
      <button id="stipPrevMonth">&larr;</button>
      <span id="stipMonthLabel">January 2026</span>
      <button id="stipNextMonth">&rarr;</button>
    </div>
    <div id="stipendEntries" style="margin-top:12px;"></div>
    <button type="button" class="add-entry-btn" id="addStipendBtn">+ Add Stipend</button>
    <div style="margin-top:8px;display:flex;gap:8px;">
      <button class="btn btn-primary btn-sm" id="saveStipendBtn">Save Stipends</button>
      <button class="btn btn-outline btn-sm" id="clearStipendBtn">Clear All</button>
    </div>
    <div id="stipendStatus" style="font-size:0.75rem;color:var(--text-dim);margin-top:8px;"></div>
  </div>

  <!-- Import Data -->
  <div class="card">
    <h2>Import Shifts from QGenda</h2>
    <p style="font-size:0.8rem;color:var(--text-dim);margin-bottom:12px;">
      Upload a QGenda time punch export (.xlsx, .csv, or screenshot) to import shifts into the tracker.
      Dates with existing shifts will be skipped.
    </p>
    <details style="font-size:0.75rem;color:var(--text-dim);margin-bottom:12px;">
      <summary style="cursor:pointer;color:var(--accent);font-weight:600;">Required CSV/Excel format</summary>
      <div style="margin-top:8px;padding:8px;background:var(--surface);border-radius:6px;line-height:1.6;">
        <strong>Required columns (exact header names):</strong><br>
        Schedule Date, Effective Clock In Date, Effective Clock In Time,
        Effective Clock Out Date, Effective Clock Out Time, Duration,
        Scheduled Task Abbreviation<br><br>
        <strong>Optional columns:</strong> Location Name, Notes<br><br>
        <strong>Example row:</strong><br>
        <code style="font-size:0.7rem;">1/5/2026 | 7:40 | 1/5/2026 | 17:03 | 9.38 | UVH 15</code><br><br>
        Times should be in 24-hour format (7:00, 17:03) or Excel time values.
        Dates should be M/D/YYYY or YYYY-MM-DD.
        Multiple entries per date are grouped into one shift with multiple time entries.
      </div>
    </details>
    <div class="upload-area" id="importTimeUploadArea">
      <div style="font-size:2rem;">&#128197;</div>
      <p>Tap to upload QGenda .xlsx, .csv, or screenshot</p>
      <input type="file" id="importTimeFile" accept=".xlsx,.xls,.csv,.png,.jpg,.jpeg">
    </div>
    <div id="importTimePreview"></div>
    <div id="importTimeAction" class="hidden" style="margin-top:12px;">
      <button class="btn btn-primary" id="importShiftsBtn" style="width:100%;">Import Shifts</button>
    </div>
    <hr style="border-color:var(--border);margin:16px 0;">
    <h2>Import Cases</h2>
    <p style="font-size:0.8rem;color:var(--text-dim);margin-bottom:12px;">
      Upload cases from Excel (.xlsx), CSV (Google Sheet export), PDF (Charge Detail), or screenshot.
      Duplicate cases (same date + start time) will be skipped.
    </p>
    <details style="font-size:0.75rem;color:var(--text-dim);margin-bottom:12px;">
      <summary style="cursor:pointer;color:var(--accent);font-weight:600;">Required CSV format</summary>
      <div style="margin-top:8px;padding:8px;background:var(--surface);border-radius:6px;line-height:1.6;">
        <strong>Columns (in order, comma-separated):</strong><br>
        Date, Surgeon, Startup (base units), Start, End, Time (min),
        Modifiers, Block, Shared?, Points Earned<br><br>
        <strong>Example row:</strong><br>
        <code style="font-size:0.7rem;">1/5,A Hill,6,8:02:00 AM,11:08:00 AM,186.00,,,,21.6</code><br><br>
        <strong>Date:</strong> M/D or M/D/YYYY (year inferred from current date if omitted)<br>
        <strong>Start/End:</strong> H:MM AM/PM or H:MM:SS AM/PM or 24-hour HH:MM<br>
        <strong>Modifiers:</strong> "E" for emergency, or numeric modifier point value<br>
        <strong>Block:</strong> Nerve block point value (2.6 = other, 3.0 = brachial plexus)<br>
        <strong>Shared?:</strong> "Y" if shared/split case<br>
        Header row is optional and will be auto-skipped.
        Shifts are auto-created for dates without an existing shift.
      </div>
    </details>
    <div class="upload-area" id="csvUploadArea">
      <div style="font-size:2rem;">&#128203;</div>
      <p>Tap to upload .xlsx, .csv, .pdf, or screenshot</p>
      <input type="file" id="csvFile" accept=".xlsx,.xls,.csv,.pdf,.png,.jpg,.jpeg">
    </div>
    <div id="csvImportResults"></div>
  </div>

  <!-- Flagged Items -->
  <div class="card" id="flaggedItemsCard">
    <details>
      <summary style="cursor:pointer;font-weight:600;font-size:1.1rem;">
        Flagged Items — Missing Time Punches
        <span id="flaggedCount" style="font-size:0.8rem;color:var(--text-dim);margin-left:8px;">(0)</span>
      </summary>
      <div id="flaggedEmailPreview" style="margin-top:12px;"></div>
      <div style="margin-top:8px;display:flex;gap:8px;">
        <button class="btn btn-primary btn-sm" id="copyFlaggedEmailBtn">Copy to Clipboard</button>
        <button class="btn btn-outline btn-sm" id="clearAllFlagsBtn">Clear All Flags</button>
      </div>
      <div id="flaggedCopyStatus" style="font-size:0.75rem;color:var(--text-dim);margin-top:8px;"></div>
    </details>
  </div>

  <!-- Account -->
  <div class="card" id="accountCard">
    <h2>Account</h2>
    <div class="account-card" id="accountInfo">
      <img id="accountPhoto" src="" alt="">
      <div class="ac-info">
        <div class="ac-name" id="accountName"></div>
        <div class="ac-email" id="accountEmail"></div>
      </div>
      <span class="sync-indicator synced" id="syncStatus">Synced</span>
    </div>
    <button class="btn btn-outline btn-sm" id="signOutBtn">Sign Out</button>
  </div>

  <!-- Export / Import -->
  <div class="card">
    <h2>Data Management</h2>
    <div style="display:flex; gap:8px; flex-wrap:wrap;">
      <button class="btn btn-outline btn-sm" id="exportCSVBtn">Export CSV</button>
      <button class="btn btn-outline btn-sm" id="exportAllBtn">Export JSON</button>
      <label class="btn btn-outline btn-sm" style="cursor:pointer;">
        Import JSON
        <input type="file" id="importFile" accept=".json" style="display:none;">
      </label>
      <button class="btn btn-danger btn-sm" id="clearAllBtn">Clear All Data</button>
    </div>
    <div style="margin-top:12px;">
      <button class="btn btn-outline btn-sm" id="loadTestDataBtn" style="border-color:var(--accent2);color:var(--accent2);">Load Test Data (3 months)</button>
    </div>
  </div>
</div>

<!-- ==================== SCAN PAGE ==================== -->
<div class="page" id="page-scan">
  <div class="card">
    <h2>Scan Billing Sheet</h2>
    <div class="form-group">
      <label style="font-size:0.8rem;color:var(--text-dim);">Sheet Date</label>
      <input type="date" id="scanDate">
    </div>
    <div class="scan-capture-area" id="scanCaptureArea">
      <span class="scan-icon">&#128247;</span>
      <p>Tap to take a photo or select an image</p>
      <input type="file" id="scanFileInput" accept="image/*" capture="environment" style="display:none;">
    </div>
    <img id="scanPreviewImg" class="scan-preview-img hidden" alt="Preview">
    <div id="scanStatus" class="hidden"></div>
    <div style="margin-top:8px;display:flex;gap:8px;" id="scanActions" class="hidden">
      <button class="btn btn-outline btn-sm" id="scanRetakeBtn" style="flex:1;">Retake</button>
      <button class="btn btn-sm" id="scanProcessBtn" style="flex:1;background:var(--primary);color:#fff;">Process</button>
    </div>
  </div>

  <div id="scanResultsArea" class="hidden">
    <div class="card" style="background:var(--surface);border:1px solid var(--border);">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
        <h3 style="margin:0;font-size:0.95rem;">Parsed Cases</h3>
        <span id="scanCaseCount" style="font-size:0.8rem;color:var(--text-dim);"></span>
      </div>
      <p style="font-size:0.75rem;color:var(--text-dim);margin-bottom:12px;">Review and edit before importing. Remove any incorrect entries.</p>
      <div id="scanCaseCards"></div>
    </div>
    <div style="padding:0 16px 16px;">
      <button class="btn btn-sm" id="scanImportBtn" style="width:100%;background:var(--accent);color:#fff;font-size:0.95rem;padding:12px;">Import Cases</button>
    </div>
  </div>
</div>

<!-- Day detail modal -->
<div class="modal-overlay hidden" id="dayModal">
  <div class="modal">
    <h2 id="dayModalTitle">Day Details</h2>
    <div id="dayModalContent"></div>
    <div class="modal-actions">
      <button class="btn btn-outline btn-sm" id="closeDayModal">Close</button>
    </div>
  </div>
</div>

<!-- Date picker modal -->
<div class="modal-overlay hidden" id="datePickerModal">
  <div class="modal">
    <h2>Select Working Date</h2>
    <div class="form-group">
      <input type="date" id="globalDatePicker">
    </div>
    <div class="modal-actions">
      <button class="btn btn-outline btn-sm" id="cancelDatePicker">Cancel</button>
      <button class="btn btn-sm" id="todayDatePicker" style="width:auto;background:var(--accent2);color:#fff;">Today</button>
      <button class="btn btn-primary btn-sm" id="applyDatePicker" style="width:auto;">Apply</button>
    </div>
  </div>
</div>

<!-- Case edit modal -->
<div class="modal-overlay hidden" id="caseEditModal">
  <div class="modal">
    <h2>Edit Case</h2>
    <div class="form-group">
      <label>Case Type</label>
      <select id="editCaseTypeSelect">
        <option value="standard" selected>Standard Case</option>
        <option value="labor_epidural">Labor Epidural</option>
        <option value="acute_pain_procedure">Acute Pain Procedure</option>
        <option value="epidural_blood_patch">Epidural Blood Patch</option>
        <option value="emergency_intubation">Emergency Intubation</option>
        <option value="01996">Epidural Rounding (01996)</option>
        <option value="99231">Pain Rounding (99231)</option>
        <option value="tee">TEE Exam</option>
        <option value="aps_rounding">APS Rounding</option>
      </select>
    </div>
    <div id="editStandardFields">
      <div class="form-group">
        <label>Procedure Name</label>
        <input type="text" id="editCaseProcedure" placeholder="e.g., Lap Chole">
      </div>
      <div class="form-row">
        <div class="form-group">
          <label>ASA Base Units</label>
          <input type="number" id="editCaseBaseUnits" min="0" step="1" placeholder="Units">
        </div>
        <div class="form-group">
          <label>Physical Status</label>
          <select id="editCasePhysicalStatus">
            <option value="P1">P1</option>
            <option value="P2" selected>P2</option>
            <option value="P3">P3</option>
            <option value="P4">P4</option>
            <option value="P5">P5</option>
          </select>
        </div>
      </div>
      <div class="form-row">
        <div class="form-group">
          <label>Anesthesia Start</label>
          <input type="text" inputmode="numeric" placeholder="HH:MM" maxlength="5" class="mil-time" id="editCaseStart">
        </div>
        <div class="form-group">
          <label>Anesthesia End</label>
          <input type="text" inputmode="numeric" placeholder="HH:MM" maxlength="5" class="mil-time" id="editCaseEnd">
        </div>
      </div>
      <div class="checkbox-group">
        <input type="checkbox" id="editCaseEmergency">
        <label for="editCaseEmergency">Emergency Case (+1 pt)</label>
      </div>
      <div class="checkbox-group">
        <input type="checkbox" id="editCaseAcutePain">
        <label for="editCaseAcutePain">Acute Pain Procedure</label>
      </div>
      <div class="form-group hidden" id="editAcutePainUnitsRow">
        <label>MWA Acute Pain Unit Value</label>
        <input type="number" id="editCaseAcutePainUnits" min="0" step="0.1" value="0">
      </div>
      <div class="checkbox-group">
        <input type="checkbox" id="editCaseHighRiskPeds">
        <label for="editCaseHighRiskPeds">High Risk Pediatrics (1.33x time)</label>
      </div>
      <div class="checkbox-group hidden" id="editORCaseRow">
        <input type="checkbox" id="editCaseORCase">
        <label for="editCaseORCase">OR Case (use OR rates, no OB doubling)</label>
      </div>

      <div class="checkbox-group">
        <input type="checkbox" id="editCaseShared">
        <label for="editCaseShared">Shared/Split Case</label>
      </div>
      <div class="form-group hidden" id="editSharedPctRow">
        <label>Startup Points Credit %</label>
        <input type="number" id="editCaseSharedPct" min="0" max="100" value="50" step="1">
      </div>

      <div class="divider"></div>
      <h3>Additional Procedures</h3>
      <div class="form-group">
        <label>Nerve Block</label>
        <select id="editNerveBlock">
          <option value="none">None</option>
          <option value="brachial_plexus">Brachial Plexus (3 pts)</option>
          <option value="other">Other (2.6 pts)</option>
        </select>
      </div>
      <div class="form-row">
        <div class="checkbox-group">
          <input type="checkbox" id="editCentralLine">
          <label for="editCentralLine">Central Line (0.8 pts)</label>
        </div>
        <div class="checkbox-group">
          <input type="checkbox" id="editArterialLine">
          <label for="editArterialLine">Arterial Line (0.6 pts)</label>
        </div>
      </div>
      <div class="form-row">
        <div class="checkbox-group">
          <input type="checkbox" id="editPAC">
          <label for="editPAC">PAC (2 pts)</label>
        </div>
        <div class="checkbox-group">
          <input type="checkbox" id="editTEEAddOn">
          <label for="editTEEAddOn">TEE (0.4 pts)</label>
        </div>
      </div>
      <div class="checkbox-group">
        <input type="checkbox" id="editITMorphine">
        <label for="editITMorphine">IT Morphine (3 pts)</label>
      </div>
    </div>
    <div id="editLaborEpiduralFields" class="hidden">
      <div class="form-row">
        <div class="form-group">
          <label>Epidural Start</label>
          <input type="text" inputmode="numeric" placeholder="HH:MM" maxlength="5" class="mil-time" id="editLaborStart">
        </div>
        <div class="form-group">
          <label>Epidural End</label>
          <input type="text" inputmode="numeric" placeholder="HH:MM" maxlength="5" class="mil-time" id="editLaborEnd">
        </div>
      </div>
    </div>
    <div id="editApsRoundingFields" class="hidden">
      <div class="form-row">
        <div class="form-group">
          <label>Epidural Rounds (3 pts each)</label>
          <input type="number" id="editApsEpiduralCount" min="0" step="1" value="0">
        </div>
        <div class="form-group">
          <label>Pain Rounds (2 pts each)</label>
          <input type="number" id="editApsPainCount" min="0" step="1" value="0">
        </div>
      </div>
    </div>
    <div id="editSimpleFields" class="hidden">
      <div class="form-group">
        <label>Procedure Notes (optional)</label>
        <input type="text" id="editSimpleNotes" placeholder="Optional notes">
      </div>
    </div>
    <div class="form-group">
      <label>Notes (optional)</label>
      <textarea id="editCaseNotes" placeholder="Notes"></textarea>
    </div>
    <div class="modal-actions" style="justify-content:space-between;">
      <button class="btn btn-danger btn-sm" id="deleteCaseEdit">Delete</button>
      <div style="display:flex;gap:8px;">
        <button class="btn btn-outline btn-sm" id="cancelCaseEdit">Cancel</button>
        <button class="btn btn-primary btn-sm" id="saveCaseEdit" style="width:auto;">Save</button>
      </div>
    </div>
  </div>
</div>

<!-- Shift edit modal -->
<div class="modal-overlay hidden" id="shiftEditModal">
  <div class="modal">
    <h2 id="shiftEditTitle">Edit Shift</h2>
    <div class="form-group">
      <label>Assignment Type</label>
      <select id="editShiftType">
        <option value="OR">OR / General</option>
        <option value="OB_restricted">UVH OB</option>
        <option value="cardiac_liver">Cardiac / Liver</option>
        <option value="mole">Mole</option>
        <option value="1st_call">1st Call</option>
        <option value="2nd_call">2nd Call</option>
        <option value="3rd_call">3rd Call</option>
        <option value="4th_call">4th Call</option>
        <option value="endo">Endo</option>
        <option value="SF1">SF 1</option>
        <option value="SF2">SF 2</option>
        <option value="ACS">ACS</option>
        <option value="NORA">NORA</option>
        <option value="pre_call">Pre-Call</option>
        <option value="CRNA_supervision">CRNA Supervision</option>
        <option value="forced_off">Forced Off</option>
        <option value="vacation">Vacation / Off</option>
      </select>
    </div>
    <div class="form-group">
      <label><input type="checkbox" id="editShiftHoliday"> Holiday</label>
    </div>
    <div id="editShiftTimeEntries"></div>
    <button class="btn btn-outline btn-sm" id="editShiftAddEntry" style="margin-top:8px;">+ Add Time Entry</button>
    <div class="modal-actions">
      <button class="btn btn-danger btn-sm" id="deleteShiftBtn">Delete</button>
      <button class="btn btn-outline btn-sm" id="cancelShiftEdit">Cancel</button>
      <button class="btn btn-primary btn-sm" id="saveShiftEdit">Save</button>
    </div>
  </div>
</div>

<!-- Day Detail Modal -->
<div class="modal-overlay hidden" id="dayDetailModal">
  <div class="modal" style="max-width:420px;">
    <h2 id="dayDetailTitle">Day Summary</h2>
    <div id="dayDetailBody"></div>
    <div class="modal-actions">
      <button class="btn btn-outline btn-sm" id="closeDayDetail">Close</button>
    </div>
  </div>
</div>

<!-- Import confirmation modal -->
<div class="modal-overlay hidden" id="importConfirmModal">
  <div class="modal">
    <h2 id="importConfirmTitle">Confirm Import</h2>
    <div id="importConfirmBody"></div>
    <div class="modal-actions">
      <button class="btn btn-outline btn-sm" id="cancelImport">Cancel</button>
      <button class="btn btn-primary btn-sm" id="confirmImport" style="width:auto;">Import</button>
    </div>
  </div>
</div>

<!-- Toast -->
<div class="toast" id="toast"></div>

<!-- BOTTOM NAV -->
<div class="bottom-nav">
  <button class="active" data-page="dataentry">
    <span class="nav-icon">&#128221;</span>
    <span>Data Entry</span>
  </button>
  <button data-page="today">
    <span class="nav-icon">&#11088;</span>
    <span>Today</span>
  </button>
  <button data-page="dashboard">
    <span class="nav-icon">&#128202;</span>
    <span>Dashboard</span>
  </button>
  <button data-page="scan">
    <span class="nav-icon">&#128247;</span>
    <span>Scan</span>
  </button>
  <button data-page="settings">
    <span class="nav-icon">&#9881;</span>
    <span>Settings</span>
  </button>
</div>

<script>
// ================================================================
// FIREBASE INIT
// ================================================================
firebase.initializeApp({
  apiKey: "AIzaSyC_6NTHRa4lHUpbsms3RgN-REfr3tN4Uho",
  authDomain: "mwa-point-tracker.firebaseapp.com",
  projectId: "mwa-point-tracker",
  storageBucket: "mwa-point-tracker.firebasestorage.app",
  messagingSenderId: "523311146529",
  appId: "1:523311146529:web:1b8a66fd270ab1b58ba560"
});

const auth = firebase.auth();
const db = firebase.firestore();
// Enable offline persistence so Firestore works offline
db.enablePersistence({ synchronizeTabs: true }).catch(() => {});

let currentUser = null;
let firestoreSyncEnabled = false;
let syncDebounceTimer = null;

// ================================================================
// DATA STORE
// ================================================================
const STORAGE_KEY = 'mwa_point_tracker';
const SETTINGS_KEY = 'mwa_settings';
const QGENDA_KEY = 'mwa_qgenda';
const PROD_KEY = 'mwa_production';
const RECON_DECISIONS_KEY = 'mwa_recon_decisions';
const SHIFT_RECON_DECISIONS_KEY = 'mwa_shift_recon_decisions';

function loadData() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (raw) {
      const d = JSON.parse(raw);
      if (!d.overrides) d.overrides = {};
      if (!d.stipends) d.stipends = {};
      return d;
    }
  } catch(e) {}
  return { shifts: {}, cases: [], overrides: {}, stipends: {} };
}

function saveData(d) {
  localStorage.setItem(STORAGE_KEY, JSON.stringify(d));
  syncToFirestore('data', d);
}

function loadSettings() {
  try {
    const raw = localStorage.getItem(SETTINGS_KEY);
    if (raw) return JSON.parse(raw);
  } catch(e) {}
  return { name: '', templates: [] };
}

function saveSettings(s) {
  localStorage.setItem(SETTINGS_KEY, JSON.stringify(s));
  syncToFirestore('settings', s);
}

function syncToFirestore(docName, payload) {
  if (!firestoreSyncEnabled || !currentUser) return;
  updateSyncStatus('syncing');
  clearTimeout(syncDebounceTimer);
  syncDebounceTimer = setTimeout(() => {
    const docRef = db.collection('users').doc(currentUser.uid).collection('data').doc(docName);
    docRef.set(JSON.parse(JSON.stringify(payload))).then(() => {
      updateSyncStatus('synced');
    }).catch(err => {
      console.error('Firestore sync error:', err);
      updateSyncStatus('error');
    });
  }, 500);
}

function updateSyncStatus(status) {
  const el = document.getElementById('syncStatus');
  if (!el) return;
  el.className = 'sync-indicator ' + status;
  if (status === 'syncing') el.textContent = 'Syncing...';
  else if (status === 'synced') el.textContent = 'Synced';
  else if (status === 'error') el.textContent = 'Sync error';
}

async function loadFromFirestore(uid) {
  try {
    const dataDoc = await db.collection('users').doc(uid).collection('data').doc('data').get();
    const settingsDoc = await db.collection('users').doc(uid).collection('data').doc('settings').get();

    if (dataDoc.exists) {
      const d = dataDoc.data();
      if (!d.overrides) d.overrides = {};
      if (!d.stipends) d.stipends = {};
      // Ensure cases is an array
      if (!Array.isArray(d.cases)) d.cases = [];
      data = d;
      localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
      return 'loaded';
    } else {
      // No cloud data — check if there's local data to migrate
      const localData = loadData();
      const hasLocalData = localData.cases.length > 0 || Object.keys(localData.shifts).length > 0;
      if (hasLocalData) {
        // Upload local data to cloud
        await db.collection('users').doc(uid).collection('data').doc('data').set(JSON.parse(JSON.stringify(localData)));
        data = localData;
        return 'migrated';
      }
      return 'empty';
    }
  } catch(err) {
    console.error('Firestore load error:', err);
    return 'error';
  }
}

async function loadSettingsFromFirestore(uid) {
  try {
    const doc = await db.collection('users').doc(uid).collection('data').doc('settings').get();
    if (doc.exists) {
      const s = doc.data();
      settings = s;
      localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
    } else {
      // Migrate local settings
      const localSettings = loadSettings();
      if (localSettings.name || localSettings.pointValue) {
        await db.collection('users').doc(uid).collection('data').doc('settings').set(JSON.parse(JSON.stringify(localSettings)));
      }
      settings = localSettings;
    }
  } catch(err) {
    console.error('Settings load error:', err);
  }
}

let data = loadData();
let settings = loadSettings();

// Data migration (idempotent)
function migrateData(d) {
  let changed = false;
  // Migrate eModifier → isEmergency on cases
  d.cases.forEach(c => {
    if (c.eModifier) {
      c.isEmergency = true;
      delete c.eModifier;
      changed = true;
    }
  });
  // Migrate OB_unrestricted → OR on shifts
  Object.values(d.shifts).forEach(s => {
    if (s.assignmentType === 'OB_unrestricted') {
      s.assignmentType = 'OR';
      changed = true;
    }
    // Ensure supervision overlay fields
    if (s.supervisionStart === undefined) { s.supervisionStart = ''; changed = true; }
    if (s.supervisionEnd === undefined) { s.supervisionEnd = ''; changed = true; }
    if (s.preCallStart === undefined) { s.preCallStart = ''; changed = true; }
    if (s.preCallEnd === undefined) { s.preCallEnd = ''; changed = true; }
    if (s.tempCoverage === undefined) { s.tempCoverage = []; changed = true; }
  });
  // Ensure isORCase on all cases
  d.cases.forEach(c => {
    if (c.isORCase === undefined) { c.isORCase = false; changed = true; }
  });
  // Migrate shifts to timeEntries array
  Object.values(d.shifts).forEach(s => {
    if (!s.timeEntries) {
      s.timeEntries = [];
      if (s.startTime) {
        s.timeEntries.push({ start: s.startTime, end: s.endTime || '' });
      }
      changed = true;
    }
  });
  // Ensure flagged field on shifts
  Object.values(d.shifts).forEach(s => {
    if (s.flagged === undefined) { s.flagged = false; changed = true; }
  });
  // Ensure flagged field on cases
  d.cases.forEach(c => {
    if (c.flagged === undefined) { c.flagged = false; changed = true; }
  });
  // Ensure overrides object exists
  if (!d.overrides) { d.overrides = {}; changed = true; }
  if (changed) saveData(d);
}
migrateData(data);

// ================================================================
// CONSTANTS & HELPERS
// ================================================================
const UNRESTRICTED_CALL_TYPES = new Set(['mole','1st_call','2nd_call','3rd_call','4th_call','endo','SF1','SF2']);

// Returns true if the given minute is eligible for unrestricted call pay (3.5 pts/hr)
// minuteOfDay: 0-1439, isWeekendOrHoliday: boolean
function isUnrestrictedCallEligible(assignmentType, minuteOfDay, isWeekendOrHoliday) {
  switch (assignmentType) {
    case 'SF1':
    case 'SF2':
    case '1st_call':
    case '2nd_call':
    case '3rd_call':
      return isWeekendOrHoliday ? true : (minuteOfDay >= 1020); // after 17:00
    case '4th_call':
      return isWeekendOrHoliday; // weekend only shift
    case 'mole':
      return isWeekendOrHoliday ? true : (minuteOfDay >= 1140); // after 19:00
    case 'endo':
      return !isWeekendOrHoliday && (minuteOfDay >= 1020); // weekday after 17:00 only
    default:
      return false; // OR, OB, Cardiac/Liver, NORA, ACS, CRNA Supervision
  }
}

// Returns the pager pay eligible window {start, end} in minutes for a shift type.
// end can be >1440 for cross-midnight windows. Returns null if not eligible.
function getPagerPayWindow(assignmentType, isWkndOrHol) {
  switch (assignmentType) {
    case 'SF1': case 'SF2':
    case '1st_call': case '2nd_call': case '3rd_call':
    case '4th_call':
      // Weekday: 17:00–07:00 next day (14 hrs); Weekend/Holiday: 07:00–07:00 next day (24 hrs)
      return isWkndOrHol ? { start: 420, end: 1860 } : { start: 1020, end: 1860 };
    case 'mole':
      // Weekday: 17:00–07:00 next day (14 hrs); Weekend/Holiday: 07:00–07:00 next day (24 hrs)
      return isWkndOrHol ? { start: 420, end: 1860 } : { start: 1020, end: 1860 };
    case 'endo':
      // Weekday: 17:00–07:00 next day (14 hrs); Weekend/Holiday: same as mole (07:00–07:00)
      return isWkndOrHol ? { start: 420, end: 1860 } : { start: 1020, end: 1860 };
    default:
      return null;
  }
}

function getAssignmentTypeName(type) {
  const names = {
    OR: 'OR / General', OB_restricted: 'UVH OB', cardiac_liver: 'Cardiac / Liver',
    mole: 'Mole', '1st_call': '1st Call', '2nd_call': '2nd Call', '3rd_call': '3rd Call', '4th_call': '4th Call',
    endo: 'Endo', SF1: 'SF 1', SF2: 'SF 2', ACS: 'ACS', NORA: 'NORA',
    pre_call: 'Pre-Call',
    CRNA_supervision: 'CRNA Supervision',
    forced_off: 'Forced Off',
    vacation: 'Vacation / Off'
  };
  return names[type] || type;
}

// ================================================================
// UTILITY
// ================================================================
function genId() {
  return Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
}

function showToast(msg) {
  const t = document.getElementById('toast');
  t.textContent = msg;
  t.classList.add('show');
  setTimeout(() => t.classList.remove('show'), 2000);
}

function formatDate(dateStr) {
  const d = new Date(dateStr + 'T12:00:00');
  return d.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });
}

function formatDateShort(dateStr) {
  const d = new Date(dateStr + 'T12:00:00');
  return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
}

function todayStr() {
  const d = new Date();
  return d.getFullYear() + '-' + String(d.getMonth()+1).padStart(2,'0') + '-' + String(d.getDate()).padStart(2,'0');
}

function timeToMinutes(timeStr) {
  if (!timeStr) return 0;
  const [h, m] = timeStr.split(':').map(Number);
  return h * 60 + m;
}

function isWeekend(dateStr) {
  const d = new Date(dateStr + 'T12:00:00');
  const day = d.getDay();
  return day === 0 || day === 6;
}

function round2(n) {
  return Math.round(n * 100) / 100;
}

// ================================================================
// MILITARY TIME INPUT HANDLING
// ================================================================
function formatMilTimeInput(val) {
  const digits = val.replace(/[^0-9]/g, '');
  if (digits.length === 0) return '';
  if (digits.length <= 2) {
    const h = parseInt(digits);
    if (h > 23) return '';
    return digits;
  }
  let h, m;
  if (digits.length === 3) {
    h = parseInt(digits.substring(0, 1));
    m = parseInt(digits.substring(1, 3));
    if (h > 2 || m > 59) return digits.substring(0, 2) + ':' + digits.substring(2);
    return '0' + digits.substring(0, 1) + ':' + digits.substring(1, 3);
  }
  h = parseInt(digits.substring(0, 2));
  m = parseInt(digits.substring(2, 4));
  if (h > 23) h = 23;
  if (m > 59) m = 59;
  return String(h).padStart(2, '0') + ':' + String(m).padStart(2, '0');
}

function isValidMilTime(val) {
  if (!val) return true; // empty is allowed
  return /^([01]\d|2[0-3]):[0-5]\d$/.test(val);
}

function bindMilTimeInput(input) {
  input.addEventListener('input', function() {
    const digits = this.value.replace(/[^0-9]/g, '');
    // When 4+ digits entered (e.g. "1900"), format immediately to "19:00"
    if (digits.length >= 4 && !this.value.includes(':')) {
      this.value = formatMilTimeInput(this.value);
      this.setSelectionRange(this.value.length, this.value.length);
      return;
    }
    // Auto-insert colon after 2 digits while typing
    if (digits.length >= 2 && !this.value.includes(':')) {
      const pos = this.selectionStart;
      this.value = digits.substring(0, 2) + ':' + digits.substring(2, 4);
      this.setSelectionRange(pos + 1, pos + 1);
    }
  });

  input.addEventListener('blur', function() {
    if (this.value) {
      this.value = formatMilTimeInput(this.value);
    }
    this.classList.toggle('invalid', this.value && !isValidMilTime(this.value));
  });

  // Allow typing only digits and colon
  input.addEventListener('keypress', function(e) {
    if (e.key.length === 1 && !/[0-9:]/.test(e.key)) {
      e.preventDefault();
    }
  });
}

function initMilTimeInputs() {
  document.querySelectorAll('input.mil-time').forEach(input => bindMilTimeInput(input));
}

// ================================================================
// DYNAMIC TIME ENTRIES
// ================================================================
function createTimeEntryRow(start, end) {
  const row = document.createElement('div');
  row.className = 'time-entry-row';
  row.innerHTML = `
    <input type="text" inputmode="numeric" placeholder="HH:MM" maxlength="5" class="mil-time te-start" value="${start || ''}">
    <span class="te-label">to</span>
    <input type="text" inputmode="numeric" placeholder="HH:MM" maxlength="5" class="mil-time te-end" value="${end || ''}">
    <span class="te-next-day" style="display:none;color:var(--accent2);font-size:0.7rem;font-weight:600;">+1d</span>
    <button type="button" class="remove-entry-btn">&times;</button>
  `;
  row.querySelectorAll('input.mil-time').forEach(input => bindMilTimeInput(input));
  // Show +1d indicator when end time < start time (cross-midnight)
  const startInput = row.querySelector('.te-start');
  const endInput = row.querySelector('.te-end');
  const nextDayBadge = row.querySelector('.te-next-day');
  function updateCrossMidnight() {
    const s = timeToMinutes(startInput.value);
    const e = timeToMinutes(endInput.value);
    nextDayBadge.style.display = (!isNaN(s) && !isNaN(e) && e <= s && endInput.value) ? 'inline' : 'none';
  }
  startInput.addEventListener('input', updateCrossMidnight);
  endInput.addEventListener('input', updateCrossMidnight);
  updateCrossMidnight();
  row.querySelector('.remove-entry-btn').addEventListener('click', function() {
    row.remove();
    updateRemoveButtons();
  });
  return row;
}

function addTimeEntry() {
  const container = document.getElementById('timeEntriesContainer');
  const row = createTimeEntryRow('', '');
  container.appendChild(row);
  updateRemoveButtons();
  // Focus the new start input
  row.querySelector('.te-start').focus();
}

function updateRemoveButtons() {
  const rows = document.querySelectorAll('#timeEntriesContainer .time-entry-row');
  rows.forEach(row => {
    const btn = row.querySelector('.remove-entry-btn');
    btn.disabled = rows.length <= 1;
  });
}

function collectTimeEntries() {
  const rows = document.querySelectorAll('#timeEntriesContainer .time-entry-row');
  const entries = [];
  rows.forEach(row => {
    const start = row.querySelector('.te-start').value.trim();
    const end = row.querySelector('.te-end').value.trim();
    if (start || end) entries.push({ start, end });
  });
  return entries;
}

function populateTimeEntries(entries) {
  const container = document.getElementById('timeEntriesContainer');
  container.innerHTML = '';
  if (!entries || entries.length === 0) entries = [{ start: '07:00', end: '' }];
  entries.forEach(e => {
    container.appendChild(createTimeEntryRow(e.start, e.end));
  });
  updateRemoveButtons();
}

document.getElementById('addTimeEntryBtn').addEventListener('click', addTimeEntry);

// ================================================================
// POINT CALCULATION ENGINE (preserved from v1)
// ================================================================
function getARRate(assignmentType, isHol, isWknd, timeMinutes) {
  const isDaytime = timeMinutes >= 420 && timeMinutes < 1020;
  let baseRate;
  if (assignmentType === 'SF1') {
    // SF1: 13/hr during 0700-1700 on non-holiday weekdays only; General rate otherwise
    baseRate = (!isHol && !isWknd && isDaytime) ? 13 : 20;
  } else {
    const isOB = assignmentType === 'OB_restricted';
    baseRate = isOB ? 13 : 20;
  }
  if (isHol || isWknd) {
    if (isDaytime) return baseRate * 1.10;
    else return baseRate * 1.25;
  } else {
    if (isDaytime) return baseRate;
    else if (timeMinutes >= 1020 && timeMinutes < 1380) return baseRate * 1.10;
    else return baseRate * 1.25;
  }
}

function calcARPoints(shift) {
  if (shift.assignmentType === 'vacation') return 0;
  if (shift.forcedOff || shift.assignmentType === 'forced_off') return 56;
  const isHol = shift.isHoliday;
  const isWknd = isWeekend(shift.date);
  const isWkndOrHol = isHol || isWknd;
  const pagerWindow = getPagerPayWindow(shift.assignmentType, isWkndOrHol);

  // Temp coverage (covering): pager + AR scoped entirely to coverage interval
  if (shift.tempCoverage && shift.tempCoverage.length > 0 && shift.tempCoverage[0].type === 'covering') {
    const tc = shift.tempCoverage[0];
    if (!tc.start || !tc.end) return 0;
    let tcStart = timeToMinutes(tc.start);
    let tcEnd = timeToMinutes(tc.end);
    if (tcEnd <= tcStart) tcEnd += 1440;
    const pagerPts = ((tcEnd - tcStart) / 60) * 3.5;
    let arPts = 0;
    (tc.timeEntries || []).forEach(e => {
      if (!e.start || !e.end) return;
      let es = timeToMinutes(e.start);
      let ee = timeToMinutes(e.end);
      if (ee <= es) ee += 1440;
      for (let m = es; m < ee; m++) {
        arPts += getARRate(shift.assignmentType, isHol, isWknd, m % 1440) / 60;
      }
    });
    return round2(pagerPts + arPts);
  }

  const entries = shift.timeEntries || [];
  const hasEntries = entries.length > 0 && (entries.length > 1 || entries[0].start);
  const lastEntry = hasEntries ? entries[entries.length - 1] : null;
  const hasEnd = hasEntries && (entries.length > 1 || (lastEntry && lastEntry.end));

  // No time entries: return pager pay only if eligible
  if (!hasEntries || !hasEnd) {
    if (pagerWindow) {
      const pagerMinutes = pagerWindow.end - pagerWindow.start;
      return round2((pagerMinutes / 60) * 3.5);
    }
    return 0;
  }

  const isSF = ['SF1','SF2'].includes(shift.assignmentType);

  // Build OR-case time ranges for SF1/SF2
  let orRanges = [];
  if (isSF) {
    const shiftCases = data.cases.filter(c => c.shiftDate === shift.date && c.isORCase);
    shiftCases.forEach(c => {
      let cs = timeToMinutes(c.startTime);
      let ce = timeToMinutes(c.endTime);
      if (ce <= cs) ce += 1440;
      orRanges.push({ start: cs, end: ce });
    });
  }

  // Build clocked-in ranges from timeEntries
  const clockedRanges = [];
  entries.forEach(e => {
    if (!e.start) return;
    const s = timeToMinutes(e.start);
    let en = e.end ? timeToMinutes(e.end) : s; // no end = zero duration
    if (en <= s && e.end) en += 1440;
    clockedRanges.push({ start: s, end: en });
  });
  // Fix cross-midnight ordering: if an entry starts before the previous entry, it's the next day
  for (let i = 1; i < clockedRanges.length; i++) {
    if (clockedRanges[i].start < clockedRanges[i-1].start) {
      clockedRanges[i].start += 1440;
      clockedRanges[i].end += 1440;
    }
  }

  if (clockedRanges.length === 0) {
    if (pagerWindow) {
      const pagerMinutes = pagerWindow.end - pagerWindow.start;
      return round2((pagerMinutes / 60) * 3.5);
    }
    return 0;
  }

  // Full span: first entry start → last entry end
  const spanStart = clockedRanges[0].start;
  const spanEnd = clockedRanges[clockedRanges.length - 1].end;
  if (spanEnd <= spanStart) {
    if (pagerWindow) {
      const pagerMinutes = pagerWindow.end - pagerWindow.start;
      return round2((pagerMinutes / 60) * 3.5);
    }
    return 0;
  }

  // Build pre-call range (OR rates during pre-call period)
  let preCallRange = null;
  if (shift.preCallStart && shift.preCallEnd) {
    let pcs = timeToMinutes(shift.preCallStart);
    let pce = timeToMinutes(shift.preCallEnd);
    if (pce <= pcs) pce += 1440;
    preCallRange = { start: pcs, end: pce };
  }

  // Pre-call split: treat pre-call and evening as independent sub-shifts
  if (preCallRange) {
    // Split clocked ranges into pre-call and evening portions
    let preCallAR = 0;
    let eveningAR = 0;
    for (let m = spanStart; m < spanEnd; m++) {
      const normalizedMin = m % 1440;
      let clockedIn = false;
      for (const r of clockedRanges) {
        if (m >= r.start && m < r.end) { clockedIn = true; break; }
      }
      if (clockedIn) {
        if (m >= preCallRange.start && m < preCallRange.end) {
          preCallAR += getARRate('OR', isHol, isWknd, normalizedMin) / 60;
        } else {
          let rateType = shift.assignmentType;
          if (isSF) {
            for (const r of orRanges) {
              if (m >= r.start && m < r.end) { rateType = 'OR'; break; }
            }
          }
          eveningAR += getARRate(rateType, isHol, isWknd, normalizedMin) / 60;
        }
      }
    }
    // Pre-call minimum: weekday non-holiday → 4hr × OR rate (20) = 80 pts
    if (!isHol && !isWknd) {
      preCallAR = Math.max(preCallAR, 20 * 4);
    }
    // Evening minimum: based on evening assignment type (mole: no minimum)
    if (!isHol && !isWknd && shift.assignmentType !== 'mole') {
      const isOBRate = ['OB_restricted','SF1'].includes(shift.assignmentType);
      const eveningMin = isOBRate ? 13 * 4 : 20 * 4;
      eveningAR = Math.max(eveningAR, eveningMin);
    }
    let arPoints = preCallAR + eveningAR;

    // Pager pay: guaranteed full window duration
    let callPoints = 0;
    if (pagerWindow) {
      const pagerMinutes = pagerWindow.end - pagerWindow.start;
      callPoints = (pagerMinutes / 60) * 3.5;
    }
    const tcPts = calcTempCoveragePoints(shift);
    callPoints += tcPts.pagerAdj;
    arPoints += tcPts.ar;
    return round2(arPoints + callPoints);
  }

  // Non-pre-call: single-shift logic
  let arPoints = 0;

  for (let m = spanStart; m < spanEnd; m++) {
    const normalizedMin = m % 1440;

    // Is this minute within a clocked-in range?
    let clockedIn = false;
    for (const r of clockedRanges) {
      if (m >= r.start && m < r.end) { clockedIn = true; break; }
    }

    if (clockedIn) {
      // Normal AR rate — override to OR during SF OR-case windows
      let rateType = shift.assignmentType;
      if (isSF) {
        for (const r of orRanges) {
          if (m >= r.start && m < r.end) { rateType = 'OR'; break; }
        }
      }
      arPoints += getARRate(rateType, isHol, isWknd, normalizedMin) / 60;
    }
  }

  // Pager pay: guaranteed full window duration (does not stop when clocked in)
  let callPoints = 0;
  if (pagerWindow) {
    const pagerMinutes = pagerWindow.end - pagerWindow.start;
    callPoints = (pagerMinutes / 60) * 3.5;
  }

  // Temp coverage adjustment
  const tcPts = calcTempCoveragePoints(shift);
  callPoints += tcPts.pagerAdj;
  arPoints += tcPts.ar;

  // Guaranteed minimums for clocked-in time (weekday, non-mole)
  if (!isHol && !isWknd && shift.assignmentType !== 'mole') {
    const isOBRate = ['OB_restricted','SF1'].includes(shift.assignmentType);
    const minPoints = isOBRate ? 13 * 4 : 20 * 4;
    arPoints = Math.max(arPoints, minPoints);
  }

  return round2(arPoints + callPoints);
}

// Separate getter for breakdown display purposes
function calcARBreakdown(shift) {
  if (shift.assignmentType === 'vacation') return { ar: 0, call: 0 };
  if (shift.forcedOff || shift.assignmentType === 'forced_off') return { ar: 56, call: 0 };
  const isHol = shift.isHoliday;
  const isWknd = isWeekend(shift.date);
  const isWkndOrHol = isHol || isWknd;
  const pagerWindow = getPagerPayWindow(shift.assignmentType, isWkndOrHol);

  // Temp coverage (covering): pager + AR scoped entirely to coverage interval
  if (shift.tempCoverage && shift.tempCoverage.length > 0 && shift.tempCoverage[0].type === 'covering') {
    const tc = shift.tempCoverage[0];
    if (!tc.start || !tc.end) return { ar: 0, call: 0 };
    let tcStart = timeToMinutes(tc.start);
    let tcEnd = timeToMinutes(tc.end);
    if (tcEnd <= tcStart) tcEnd += 1440;
    const pagerPts = ((tcEnd - tcStart) / 60) * 3.5;
    let arPts = 0;
    (tc.timeEntries || []).forEach(e => {
      if (!e.start || !e.end) return;
      let es = timeToMinutes(e.start);
      let ee = timeToMinutes(e.end);
      if (ee <= es) ee += 1440;
      for (let m = es; m < ee; m++) {
        arPts += getARRate(shift.assignmentType, isHol, isWknd, m % 1440) / 60;
      }
    });
    return { ar: round2(arPts), call: round2(pagerPts) };
  }

  const entries = shift.timeEntries || [];
  const hasEntries = entries.length > 0 && (entries.length > 1 || entries[0].start);
  const lastEntry = hasEntries ? entries[entries.length - 1] : null;
  const hasEnd = hasEntries && (entries.length > 1 || (lastEntry && lastEntry.end));

  // No time entries: return pager pay only if eligible
  if (!hasEntries || !hasEnd) {
    if (pagerWindow) {
      const pagerMinutes = pagerWindow.end - pagerWindow.start;
      return { ar: 0, call: round2((pagerMinutes / 60) * 3.5) };
    }
    return { ar: 0, call: 0 };
  }

  const isSF = ['SF1','SF2'].includes(shift.assignmentType);

  let orRanges = [];
  if (isSF) {
    const shiftCases = data.cases.filter(c => c.shiftDate === shift.date && c.isORCase);
    shiftCases.forEach(c => {
      let cs = timeToMinutes(c.startTime);
      let ce = timeToMinutes(c.endTime);
      if (ce <= cs) ce += 1440;
      orRanges.push({ start: cs, end: ce });
    });
  }

  const clockedRanges = [];
  entries.forEach(e => {
    if (!e.start) return;
    const s = timeToMinutes(e.start);
    let en = e.end ? timeToMinutes(e.end) : s;
    if (en <= s && e.end) en += 1440;
    clockedRanges.push({ start: s, end: en });
  });
  // Fix cross-midnight ordering: if an entry starts before the previous entry, it's the next day
  for (let i = 1; i < clockedRanges.length; i++) {
    if (clockedRanges[i].start < clockedRanges[i-1].start) {
      clockedRanges[i].start += 1440;
      clockedRanges[i].end += 1440;
    }
  }

  if (clockedRanges.length === 0) {
    if (pagerWindow) {
      const pagerMinutes = pagerWindow.end - pagerWindow.start;
      return { ar: 0, call: round2((pagerMinutes / 60) * 3.5) };
    }
    return { ar: 0, call: 0 };
  }

  const spanStart = clockedRanges[0].start;
  const spanEnd = clockedRanges[clockedRanges.length - 1].end;
  if (spanEnd <= spanStart) {
    if (pagerWindow) {
      const pagerMinutes = pagerWindow.end - pagerWindow.start;
      return { ar: 0, call: round2((pagerMinutes / 60) * 3.5) };
    }
    return { ar: 0, call: 0 };
  }

  // Build pre-call range (OR rates during pre-call period)
  let preCallRange = null;
  if (shift.preCallStart && shift.preCallEnd) {
    let pcs = timeToMinutes(shift.preCallStart);
    let pce = timeToMinutes(shift.preCallEnd);
    if (pce <= pcs) pce += 1440;
    preCallRange = { start: pcs, end: pce };
  }

  // Pre-call split: treat pre-call and evening as independent sub-shifts
  if (preCallRange) {
    let preCallAR = 0;
    let eveningAR = 0;
    for (let m = spanStart; m < spanEnd; m++) {
      const normalizedMin = m % 1440;
      let clockedIn = false;
      for (const r of clockedRanges) {
        if (m >= r.start && m < r.end) { clockedIn = true; break; }
      }
      if (clockedIn) {
        if (m >= preCallRange.start && m < preCallRange.end) {
          preCallAR += getARRate('OR', isHol, isWknd, normalizedMin) / 60;
        } else {
          let rateType = shift.assignmentType;
          if (isSF) {
            for (const r of orRanges) {
              if (m >= r.start && m < r.end) { rateType = 'OR'; break; }
            }
          }
          eveningAR += getARRate(rateType, isHol, isWknd, normalizedMin) / 60;
        }
      }
    }
    // Pre-call minimum: weekday non-holiday → 4hr × OR rate (20) = 80 pts
    if (!isHol && !isWknd) {
      preCallAR = Math.max(preCallAR, 20 * 4);
    }
    // Evening minimum: based on evening assignment type (mole: no minimum)
    if (!isHol && !isWknd && shift.assignmentType !== 'mole') {
      const isOBRate = ['OB_restricted','SF1'].includes(shift.assignmentType);
      const eveningMin = isOBRate ? 13 * 4 : 20 * 4;
      eveningAR = Math.max(eveningAR, eveningMin);
    }
    let arPoints = preCallAR + eveningAR;

    let callPoints = 0;
    if (pagerWindow) {
      const pagerMinutes = pagerWindow.end - pagerWindow.start;
      callPoints = (pagerMinutes / 60) * 3.5;
    }
    const tcPtsBd = calcTempCoveragePoints(shift);
    callPoints += tcPtsBd.pagerAdj;
    arPoints += tcPtsBd.ar;
    return { ar: round2(arPoints), call: round2(callPoints), preCallAR: round2(preCallAR), eveningAR: round2(eveningAR) };
  }

  // Non-pre-call: single-shift logic
  let arPoints = 0;

  for (let m = spanStart; m < spanEnd; m++) {
    const normalizedMin = m % 1440;
    let clockedIn = false;
    for (const r of clockedRanges) {
      if (m >= r.start && m < r.end) { clockedIn = true; break; }
    }
    if (clockedIn) {
      let rateType = shift.assignmentType;
      if (isSF) {
        for (const r of orRanges) {
          if (m >= r.start && m < r.end) { rateType = 'OR'; break; }
        }
      }
      arPoints += getARRate(rateType, isHol, isWknd, normalizedMin) / 60;
    }
  }

  // Pager pay: guaranteed full window duration (does not stop when clocked in)
  let callPoints = 0;
  if (pagerWindow) {
    const pagerMinutes = pagerWindow.end - pagerWindow.start;
    callPoints = (pagerMinutes / 60) * 3.5;
  }

  // Temp coverage adjustment
  const tcPtsBd = calcTempCoveragePoints(shift);
  callPoints += tcPtsBd.pagerAdj;
  arPoints += tcPtsBd.ar;

  if (!isHol && !isWknd && shift.assignmentType !== 'mole') {
    const isOBRate = ['OB_restricted','SF1'].includes(shift.assignmentType);
    const minPoints = isOBRate ? 13 * 4 : 20 * 4;
    arPoints = Math.max(arPoints, minPoints);
  }

  return { ar: round2(arPoints), call: round2(callPoints) };
}

function getTimeMultiplier(physicalStatus, isHol, isWknd, caseStartMin, isHighRiskPeds) {
  const isWeekdayDay = !isHol && !isWknd && caseStartMin >= 420 && caseStartMin < 1020;
  const isWeekdayEve = !isHol && !isWknd && caseStartMin >= 1020 && caseStartMin < 1380;
  const isWeekendDay = (isHol || isWknd) && caseStartMin >= 420 && caseStartMin < 1020;
  let multiplier = 1.0;
  if (physicalStatus === 'P4') {
    if (isWeekdayDay) multiplier = 1.33;
  } else if (physicalStatus === 'P5') {
    if (isWeekdayDay) multiplier = 1.83;
    else if (isWeekdayEve || isWeekendDay) multiplier = 1.5;
  }
  if (isHighRiskPeds && isWeekdayDay && multiplier < 1.33) multiplier = 1.33;
  return multiplier;
}

function calcAddOnPoints(caseData) {
  let pts = 0;
  if (caseData.nerveBlock === 'brachial_plexus') pts += 3;
  else if (caseData.nerveBlock === 'other') pts += 2.6;
  else if (caseData.nerveBlock === 'it_morphine') pts += 3;
  if (caseData.hasCentralLine) pts += 0.8;
  if (caseData.hasArterialLine) pts += 0.6;
  if (caseData.hasPAC) pts += 2;
  if (caseData.hasTEEAddOn) pts += 0.4;
  if (caseData.hasITMorphine) pts += 3;
  return pts;
}

function calcCasePoints(caseData, shift) {
  const ct = caseData.caseType;
  if (ct === 'epidural_blood_patch') return 5;
  if (ct === 'emergency_intubation') return 4;
  if (ct === '01996') return 3;
  if (ct === '99231') return 2;
  if (ct === 'tee') return 22;

  if (ct === 'acute_pain_procedure') {
    return round2(calcAddOnPoints(caseData));
  }

  if (ct === 'aps_rounding') {
    const epi = (parseInt(caseData.epiduralRounds) || 0) * 3;
    const pain = (parseInt(caseData.painRounds) || 0) * 2;
    return round2(epi + pain);
  }

  if (ct === 'labor_epidural') {
    let cs = timeToMinutes(caseData.startTime);
    let ce = timeToMinutes(caseData.endTime);
    if (ce <= cs) ce += 1440;
    const durationHrs = Math.min((ce - cs) / 60, 24);
    let pts = 0;
    if (durationHrs > 0) pts += Math.min(durationHrs, 1) * 7.5;
    if (durationHrs > 1) pts += Math.min(durationHrs - 1, 1) * 2.5;
    if (durationHrs > 2) pts += (durationHrs - 2) * 1.25;
    return round2(pts * 2); // always OB doubled
  }

  const addOnPts = calcAddOnPoints(caseData);
  const baseUnits = parseFloat(caseData.baseUnits) || 0;
  let basePoints = 0.5 * baseUnits;
  if (caseData.isSharedCase) {
    basePoints *= (parseFloat(caseData.sharedStartupPct) || 50) / 100;
  }
  let caseStartMin = timeToMinutes(caseData.startTime);
  let caseHours = 0;
  if (caseData.endTime) {
    let caseEndMin = timeToMinutes(caseData.endTime);
    if (caseEndMin <= caseStartMin) caseEndMin += 1440;
    caseHours = (caseEndMin - caseStartMin) / 60;
  }
  const isHol = shift ? shift.isHoliday : false;
  const isWknd = shift ? isWeekend(shift.date) : false;
  const timeMultiplier = getTimeMultiplier(caseData.physicalStatus, isHol, isWknd, caseStartMin, caseData.isHighRiskPeds);
  const adjustedHours = caseHours * timeMultiplier;
  const timePoints = adjustedHours * 6;
  const medicalPoints = caseData.isMedicalProc ? 0.20 * (parseFloat(caseData.medicalUnits) || 0) : 0;
  const acutePainPoints = caseData.isAcutePain ? 0.375 * (parseFloat(caseData.acutePainUnits) || 0) : 0;
  const emergencyPoints = caseData.isEmergency ? 1 : 0;
  let total = basePoints + timePoints + medicalPoints + acutePainPoints + emergencyPoints + addOnPts;
  const isOBShift = shift && ['OB_restricted','SF1','SF2'].includes(shift.assignmentType);
  if (isOBShift && !caseData.isORCase) total *= 2;
  return round2(total);
}

function getCaseBreakdown(caseData, shift) {
  const ct = caseData.caseType;
  const bd = [];
  if (ct === 'epidural_blood_patch') { bd.push({label:'Epidural Blood Patch', pts:5}); return bd; }
  if (ct === 'emergency_intubation') { bd.push({label:'Emergency Intubation', pts:4}); return bd; }
  if (ct === '01996') { bd.push({label:'Epidural Rounding (01996)', pts:3}); return bd; }
  if (ct === '99231') { bd.push({label:'Pain Rounding (99231)', pts:2}); return bd; }
  if (ct === 'tee') { bd.push({label:'TEE Exam', pts:22}); return bd; }

  if (ct === 'aps_rounding') {
    const epiN = parseInt(caseData.epiduralRounds) || 0;
    const painN = parseInt(caseData.painRounds) || 0;
    if (epiN > 0) bd.push({label: `Epidural Rounds (${epiN} x 3)`, pts: round2(epiN * 3)});
    if (painN > 0) bd.push({label: `Pain Rounds (${painN} x 2)`, pts: round2(painN * 2)});
    return bd;
  }

  if (ct === 'labor_epidural') {
    let cs = timeToMinutes(caseData.startTime);
    let ce = timeToMinutes(caseData.endTime);
    if (ce <= cs) ce += 1440;
    const durationHrs = Math.min((ce - cs) / 60, 24);
    let subtotal = 0;
    if (durationHrs > 0) {
      const p = round2(Math.min(durationHrs, 1) * 7.5);
      bd.push({label: `1st Hour (${round2(Math.min(durationHrs, 1))}h x 7.5)`, pts: p});
      subtotal += p;
    }
    if (durationHrs > 1) {
      const p = round2(Math.min(durationHrs - 1, 1) * 2.5);
      bd.push({label: `2nd Hour (${round2(Math.min(durationHrs - 1, 1))}h x 2.5)`, pts: p});
      subtotal += p;
    }
    if (durationHrs > 2) {
      const hrs = round2(durationHrs - 2);
      const p = round2(hrs * 1.25);
      bd.push({label: `Additional (${hrs}h x 1.25)`, pts: p});
      subtotal += p;
    }
    bd.push({label: 'OB Doubled (x2)', pts: round2(subtotal)});
    return bd;
  }

  const baseUnits = parseFloat(caseData.baseUnits) || 0;
  let halfBase = 0.5 * baseUnits;
  if (caseData.isSharedCase) {
    const pct = parseFloat(caseData.sharedStartupPct) || 50;
    halfBase *= pct / 100;
    bd.push({label: `Base (shared ${pct}%) (${baseUnits} x 0.5 x ${pct}%)`, pts: round2(halfBase)});
  } else {
    bd.push({label: `Half Base Units (${baseUnits} x 0.5)`, pts: round2(halfBase)});
  }
  let caseStartMin = timeToMinutes(caseData.startTime);
  let caseHours = 0;
  if (caseData.endTime) {
    let caseEndMin = timeToMinutes(caseData.endTime);
    if (caseEndMin <= caseStartMin) caseEndMin += 1440;
    caseHours = round2((caseEndMin - caseStartMin) / 60);
  }
  const isHol = shift ? shift.isHoliday : false;
  const isWknd = shift ? isWeekend(shift.date) : false;
  const tm = getTimeMultiplier(caseData.physicalStatus, isHol, isWknd, caseStartMin, caseData.isHighRiskPeds);
  const adjustedHours = round2(caseHours * tm);
  const timePoints = round2(adjustedHours * 6);
  let tl = `Time (${caseHours}h x 6 pts/hr`;
  if (tm > 1) tl += ` x ${tm}`;
  tl += ')';
  if (caseHours > 0) bd.push({label: tl, pts: timePoints});
  if (caseData.isMedicalProc) {
    const mu = parseFloat(caseData.medicalUnits) || 0;
    bd.push({label: `Medical Proc (20% x ${mu})`, pts: round2(0.20 * mu)});
  }
  if (caseData.isAcutePain) {
    const au = parseFloat(caseData.acutePainUnits) || 0;
    bd.push({label: `Acute Pain (37.5% x ${au})`, pts: round2(0.375 * au)});
  }
  if (caseData.isEmergency) bd.push({label: 'Emergency', pts: 1});
  if (caseData.nerveBlock === 'brachial_plexus') bd.push({label: 'Nerve Block (Brachial Plexus)', pts: 3});
  else if (caseData.nerveBlock === 'other') bd.push({label: 'Nerve Block (Other)', pts: 2.6});
  if (caseData.hasCentralLine) bd.push({label: 'Central Line', pts: 0.8});
  if (caseData.hasArterialLine) bd.push({label: 'Arterial Line', pts: 0.6});
  if (caseData.hasPAC) bd.push({label: 'PAC', pts: 2});
  if (caseData.hasTEEAddOn) bd.push({label: 'TEE', pts: 0.4});
  if (caseData.hasITMorphine) bd.push({label: 'IT Morphine', pts: 3});
  const isOBShift = shift && ['OB_restricted','SF1','SF2'].includes(shift.assignmentType);
  if (isOBShift && !caseData.isORCase) {
    const subtotal = bd.reduce((s,r) => s + r.pts, 0);
    bd.push({label: 'OB Doubled (x2)', pts: round2(subtotal)});
  }
  return bd;
}

function calcSupervisionPoints(shift) {
  const isHol = shift.isHoliday;
  const isWknd = isWeekend(shift.date);
  // Standalone CRNA_supervision type: AR rate + 7 per hour, minute-by-minute
  if (shift.assignmentType === 'CRNA_supervision') {
    const entries = shift.timeEntries || [];
    let clockedRanges = [];
    entries.forEach(e => {
      if (!e.start || !e.end) return;
      let s = timeToMinutes(e.start);
      let en = timeToMinutes(e.end);
      if (en <= s) en += 1440;
      clockedRanges.push({ start: s, end: en });
    });
    if (clockedRanges.length === 0 && shift.startTime && shift.endTime) {
      let startMin = timeToMinutes(shift.startTime);
      let endMin = timeToMinutes(shift.endTime);
      if (endMin <= startMin) endMin += 1440;
      clockedRanges.push({ start: startMin, end: endMin });
    }
    let pts = 0;
    clockedRanges.forEach(r => {
      for (let m = r.start; m < r.end; m++) {
        pts += (getARRate('OR', isHol, isWknd, m % 1440) + 7) / 60;
      }
    });
    return round2(pts);
  }
  // Overlay on OR/SF1/SF2: +7/hr only (base AR already counted in calcARPoints)
  if (shift.supervisionStart && shift.supervisionEnd) {
    let startMin = timeToMinutes(shift.supervisionStart);
    let endMin = timeToMinutes(shift.supervisionEnd);
    if (endMin <= startMin) endMin += 1440;
    return round2((endMin - startMin) / 60 * 7);
  }
  return 0;
}

function calcCallPoints(shift) {
  // Unrestricted call is now automatically calculated inside calcARPoints via gap detection
  return 0;
}

function calcSubspecPoints(shift) {
  let pts = 0;
  if (shift.subspecCoverage) pts += 45;
  pts += (parseInt(shift.teeCount) || 0) * 22;
  return pts;
}

function calcTempCoveragePoints(shift) {
  if (!shift.tempCoverage || shift.tempCoverage.length === 0) return { pagerAdj: 0, ar: 0 };
  const isHol = shift.isHoliday;
  const isWknd = isWeekend(shift.date);
  let pagerAdj = 0;
  let ar = 0;
  shift.tempCoverage.forEach(tc => {
    if (!tc.start || !tc.end) return;
    let tcStart = timeToMinutes(tc.start);
    let tcEnd = timeToMinutes(tc.end);
    if (tcEnd <= tcStart) tcEnd += 1440;
    const tcMinutes = tcEnd - tcStart;
    if (tc.type === 'covered') {
      pagerAdj -= (tcMinutes / 60) * 3.5;
    } else if (tc.type === 'covering') {
      pagerAdj += (tcMinutes / 60) * 3.5;
      // AR for work time entries during coverage
      const tcEntries = tc.timeEntries || [];
      tcEntries.forEach(e => {
        if (!e.start || !e.end) return;
        let es = timeToMinutes(e.start);
        let ee = timeToMinutes(e.end);
        if (ee <= es) ee += 1440;
        for (let m = es; m < ee; m++) {
          ar += getARRate(shift.assignmentType, isHol, isWknd, m % 1440) / 60;
        }
      });
    }
  });
  return { pagerAdj: round2(pagerAdj), ar: round2(ar) };
}

function calcShiftTotal(shift) {
  const shiftCases = data.cases.filter(c => c.shiftDate === shift.date);
  const breakdown = calcARBreakdown(shift);
  const arPts = breakdown.ar;
  const callPts = breakdown.call;
  let prodPts = 0;
  shiftCases.forEach(c => { prodPts += calcCasePoints(c, shift); });
  const subspecPts = (shift.assignmentType === 'cardiac_liver') ? calcSubspecPoints(shift) : 0;
  const supervisionPts = calcSupervisionPoints(shift);
  return { ar: arPts, prod: round2(prodPts), call: callPts, subspec: subspecPts, supervision: supervisionPts, total: round2(arPts + prodPts + callPts + subspecPts + supervisionPts) };
}

function getCaseTypeName(type) {
  const names = {
    standard: 'Standard Case', labor_epidural: 'Labor Epidural',
    acute_pain_procedure: 'Acute Pain Procedure',
    aps_rounding: 'APS Rounding', epidural_blood_patch: 'Epidural Blood Patch',
    emergency_intubation: 'Emergency Intubation', '01996': 'Epidural Rounding (01996)',
    '99231': 'Pain Rounding (99231)', tee: 'TEE Exam'
  };
  return names[type] || type;
}

// ================================================================
// WORKING DATE
// ================================================================
let workingDate = todayStr();
let deShiftEditing = false;
let returnToShiftLogs = false;

function setWorkingDate(d) {
  workingDate = d;
  document.getElementById('shiftDate').value = d;
  document.getElementById('headerDateBtn').textContent = formatDateShort(d);
  loadShiftForDate();
  updateHeaderPoints();
  updateEndTimeWarning();
  updateORCaseVisibility();
  deShiftEditing = false;
  updateDataEntryState();
  renderDECaseList();
  updateDETally();
  // Re-render Today page if it's currently visible
  if (document.getElementById('page-today').classList.contains('active')) {
    renderToday();
  }
}

// Header date picker
document.getElementById('headerDateBtn').addEventListener('click', () => {
  document.getElementById('globalDatePicker').value = workingDate;
  document.getElementById('datePickerModal').classList.remove('hidden');
});

document.getElementById('cancelDatePicker').addEventListener('click', () => {
  document.getElementById('datePickerModal').classList.add('hidden');
});

document.getElementById('todayDatePicker').addEventListener('click', () => {
  setWorkingDate(todayStr());
  document.getElementById('datePickerModal').classList.add('hidden');
});

document.getElementById('applyDatePicker').addEventListener('click', () => {
  const v = document.getElementById('globalDatePicker').value;
  if (v) setWorkingDate(v);
  document.getElementById('datePickerModal').classList.add('hidden');
});

document.getElementById('datePickerModal').addEventListener('click', (e) => {
  if (e.target.id === 'datePickerModal') document.getElementById('datePickerModal').classList.add('hidden');
});

// ================================================================
// NAVIGATION (bottom nav)
// ================================================================
document.querySelectorAll('.bottom-nav button').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.bottom-nav button').forEach(b => b.classList.remove('active'));
    document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
    btn.classList.add('active');
    document.getElementById('page-' + btn.dataset.page).classList.add('active');
    returnToShiftLogs = false;
    if (btn.dataset.page === 'dataentry') loadDataEntryPage();
    if (btn.dataset.page === 'today') { returnToDailyTab = false; renderToday(); }
    if (btn.dataset.page === 'dashboard') { switchDashboardTab(activeDashTab); }
    if (btn.dataset.page === 'settings') { renderHistory(); loadOverrideUI(); loadStipendUI(); renderFlaggedEmail(); }
    if (btn.dataset.page === 'reconcile') renderReconTabs();
    if (btn.dataset.page === 'scan') initScanPage();
  });
});

// ================================================================
// SHIFT TEMPLATES
// ================================================================
const defaultTemplates = [
  { name: 'OR Day', type: 'OR', start: '07:10', end: '17:00' },
  { name: 'UVH OB Day', type: 'OB_restricted', start: '07:00', end: '19:00' },
  { name: 'UVH OB Night', type: 'OB_restricted', start: '19:00', end: '07:00' },
  { name: 'UVH OB Weekend', type: 'OB_restricted', start: '07:00', end: '07:00' },
  { name: 'NORA', type: 'NORA', start: '07:00', end: '14:00' },
  { name: 'ACS', type: 'ACS', start: '07:00', end: '17:00' },
];

function renderTemplates() {
  const grid = document.getElementById('templateGrid');
  const templates = defaultTemplates;
  grid.innerHTML = templates.map((t, i) => `
    <button class="template-btn" data-tidx="${i}">
      <span class="t-label">${t.name}</span>
      <span class="t-time">${t.start} - ${t.end}</span>
    </button>
  `).join('');

  grid.querySelectorAll('.template-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const t = templates[parseInt(btn.dataset.tidx)];
      document.getElementById('shiftAssignmentType').value = t.type;
      populateTimeEntries([{ start: t.start, end: t.end }]);
      document.getElementById('cardiacLiverOptions').classList.toggle('hidden', t.type !== 'cardiac_liver');
      updateSupervisionOverlayVisibility();
      showToast('Template applied');
    });
  });
}

// Template collapse toggle
document.getElementById('templateCollapseHeader').addEventListener('click', () => {
  const body = document.getElementById('templateCollapseBody');
  const arrow = document.getElementById('templateArrow');
  if (body.style.maxHeight && body.style.maxHeight !== '0px') {
    body.style.maxHeight = '0';
    arrow.classList.remove('open');
  } else {
    body.style.maxHeight = body.scrollHeight + 'px';
    arrow.classList.add('open');
  }
});

// Quick Procedures collapse toggle
document.getElementById('quickProcCollapseHeader').addEventListener('click', () => {
  const body = document.getElementById('quickProcCollapseBody');
  const arrow = document.getElementById('quickProcArrow');
  if (body.style.maxHeight && body.style.maxHeight !== '0px') {
    body.style.maxHeight = '0';
    arrow.classList.remove('open');
  } else {
    body.style.maxHeight = body.scrollHeight + 'px';
    arrow.classList.add('open');
  }
});

// Quick Procedure button clicks
const quickProcs = {
  colonoscopy: { name: 'Colonoscopy', units: 4 },
  egd: { name: 'EGD', units: 5 },
  double: { name: 'EGD + Colonoscopy', units: 5 },
  tonsils: { name: 'Tonsillectomy', units: 5 }
};

document.querySelectorAll('[data-qproc]').forEach(btn => {
  btn.addEventListener('click', () => {
    const proc = quickProcs[btn.dataset.qproc];
    if (!proc) return;
    selectedCaseType = 'standard';
    document.getElementById('caseTypeSelect').value = 'standard';
    applyCaseTypeVisibility('standard');
    document.getElementById('caseProcedure').value = proc.name;
    document.getElementById('caseBaseUnits').value = proc.units;
    updatePointPreview();
    showToast(proc.name + ' pre-filled');
  });
});

// ================================================================
// SHIFT PAGE
// ================================================================
const shiftDateInput = document.getElementById('shiftDate');

function updateUnrestrictedCallVisibility() {
  // Unrestricted call is now automatic based on shift type + gaps — no manual UI needed
}

function updateEndTimeWarning() {
  const shift = data.shifts[workingDate];
  const banner = document.getElementById('endTimeWarning');
  const hasNoEnd = shift && !shift.forcedOff && shift.assignmentType !== 'forced_off' && shift.timeEntries &&
    shift.timeEntries.length > 0 && !shift.timeEntries[shift.timeEntries.length - 1].end;
  if (hasNoEnd) {
    banner.classList.remove('hidden');
  } else {
    banner.classList.add('hidden');
  }
}

function updateORCaseVisibility() {
  const shift = data.shifts[workingDate];
  const isSF = shift && ['SF1','SF2'].includes(shift.assignmentType);
  document.getElementById('orCaseRow').classList.toggle('hidden', !isSF);
  if (!isSF) document.getElementById('caseORCase').checked = false;
}

function updateSupervisionOverlayVisibility() {
  const type = getSelectedAssignmentType();
  const eligible = ['OR','SF1','SF2'].includes(type);
  document.getElementById('supervisionOverlaySection').classList.toggle('hidden', !eligible);
  if (!eligible) {
    document.getElementById('supervisionOverlayCheck').checked = false;
    document.getElementById('supervisionTimes').classList.add('hidden');
  }
}

function updatePreCallOverlayVisibility() {
  const type = getSelectedAssignmentType();
  const eligible = ['mole','OB_restricted'].includes(type);
  document.getElementById('preCallOverlaySection').classList.toggle('hidden', !eligible);
  if (!eligible) {
    document.getElementById('preCallOverlayCheck').checked = false;
    document.getElementById('preCallTimes').classList.add('hidden');
  }
}

function updateTempCoverageVisibility() {
  const type = getSelectedAssignmentType();
  const isWkndOrHol = document.getElementById('shiftHoliday').checked || isWeekend(workingDate);
  const eligible = getPagerPayWindow(type, isWkndOrHol) !== null;
  document.getElementById('tempCoverageSection').classList.toggle('hidden', !eligible);
  if (!eligible) {
    document.getElementById('tempCoverageCheck').checked = false;
    document.getElementById('tempCoverageForm').classList.add('hidden');
    document.getElementById('tcTimeEntriesSection').classList.add('hidden');
    document.getElementById('tcTimeEntriesContainer').innerHTML = '';
  }
}

function addTCTimeEntryRow(startVal, endVal) {
  const container = document.getElementById('tcTimeEntriesContainer');
  const row = document.createElement('div');
  row.className = 'time-entry-row';
  row.innerHTML = `
    <input type="text" inputmode="numeric" placeholder="HH:MM" maxlength="5" class="mil-time tc-start" value="${startVal}">
    <span class="te-label">to</span>
    <input type="text" inputmode="numeric" placeholder="HH:MM" maxlength="5" class="mil-time tc-end" value="${endVal}">
    <button type="button" class="remove-entry-btn">&times;</button>
  `;
  row.querySelector('.remove-entry-btn').addEventListener('click', () => { row.remove(); });
  row.querySelectorAll('input.mil-time').forEach(input => bindMilTimeInput(input));
  container.appendChild(row);
}

function collectTCTimeEntries() {
  const rows = document.querySelectorAll('#tcTimeEntriesContainer .time-entry-row');
  const entries = [];
  rows.forEach(row => {
    const start = row.querySelector('.tc-start')?.value || '';
    const end = row.querySelector('.tc-end')?.value || '';
    if (start) entries.push({ start, end });
  });
  return entries;
}

function populateTCTimeEntries(entries) {
  const container = document.getElementById('tcTimeEntriesContainer');
  container.innerHTML = '';
  entries.forEach(e => addTCTimeEntryRow(e.start || '', e.end || ''));
}

function checkEndTimeNotification() {
  const now = new Date();
  if (now.getHours() < 7) return;
  const twoDaysAgo = new Date(now.getTime() - 48 * 60 * 60 * 1000);
  const missing = Object.values(data.shifts).filter(s => {
    if (s.forcedOff || s.assignmentType === 'forced_off') return false;
    // Check if last entry has an end time
    const entries = s.timeEntries || [];
    const lastEnd = entries.length > 0 ? entries[entries.length - 1].end : s.endTime;
    if (lastEnd) return false;
    const sd = new Date(s.date + 'T12:00:00');
    return sd >= twoDaysAgo && sd <= now;
  });
  if (missing.length === 0) return;
  if ('Notification' in window && Notification.permission === 'default') {
    Notification.requestPermission();
  }
  if ('Notification' in window && Notification.permission === 'granted') {
    const dates = missing.map(s => formatDateShort(s.date)).join(', ');
    new Notification('MWA Point Tracker', {
      body: `Missing end time for: ${dates}`,
      icon: 'icons/icon-192.png'
    });
  }
}

document.getElementById('shiftAssignmentType').addEventListener('change', function() {
  const type = this.value;
  document.getElementById('cardiacLiverOptions').classList.toggle('hidden', type !== 'cardiac_liver');
  document.getElementById('vacationRangeSection').classList.toggle('hidden', type !== 'vacation');
  document.getElementById('eveningAssignmentSection').classList.toggle('hidden', type !== 'pre_call');
  document.getElementById('timeEntriesLabel').textContent = type === 'pre_call' ? 'Pre-Call Times' : 'Time Entries';
  if (type !== 'pre_call') {
    document.getElementById('eveningAssignmentType').value = '';
    document.getElementById('eveningTimeSection').classList.add('hidden');
    document.getElementById('eveningTimeEntriesContainer').innerHTML = '';
  }
  if (type === 'forced_off') {
    populateTimeEntries([{ start: '07:00', end: '20:00' }]);
  }
  updateUnrestrictedCallVisibility();
  updateSupervisionOverlayVisibility();
  updatePreCallOverlayVisibility();
  updateTempCoverageVisibility();
  updateORCaseVisibility();
});

document.getElementById('supervisionOverlayCheck').addEventListener('change', function() {
  document.getElementById('supervisionTimes').classList.toggle('hidden', !this.checked);
});

document.getElementById('preCallOverlayCheck').addEventListener('change', function() {
  document.getElementById('preCallTimes').classList.toggle('hidden', !this.checked);
});

document.getElementById('eveningAssignmentType').addEventListener('change', function() {
  const hasEvening = !!this.value;
  document.getElementById('eveningTimeSection').classList.toggle('hidden', !hasEvening);
  if (!hasEvening) {
    document.getElementById('eveningTimeEntriesContainer').innerHTML = '';
  }
});

document.getElementById('addEveningTimeEntryBtn').addEventListener('click', () => {
  addEveningTimeEntryRow('', '');
});

document.getElementById('tempCoverageCheck').addEventListener('change', function() {
  document.getElementById('tempCoverageForm').classList.toggle('hidden', !this.checked);
  if (!this.checked) {
    document.getElementById('tcTimeEntriesSection').classList.add('hidden');
    document.getElementById('tcTimeEntriesContainer').innerHTML = '';
    // Restore regular time entries when coverage unchecked
    document.getElementById('timeEntriesGroup').classList.remove('hidden');
  } else {
    // Check if covering is selected and hide time entries
    const isCovering = document.querySelector('input[name="tcDirection"]:checked')?.value === 'covering';
    if (isCovering) {
      document.getElementById('timeEntriesGroup').classList.add('hidden');
    }
  }
});

document.querySelectorAll('input[name="tcDirection"]').forEach(r => {
  r.addEventListener('change', function() {
    const isCovering = this.value === 'covering';
    document.getElementById('tcTimeEntriesSection').classList.toggle('hidden', !isCovering);
    if (!isCovering) {
      document.getElementById('tcTimeEntriesContainer').innerHTML = '';
      document.getElementById('timeEntriesGroup').classList.remove('hidden');
    } else {
      // Hide regular time entries — coverage entries replace them
      document.getElementById('timeEntriesGroup').classList.add('hidden');
    }
  });
});

document.getElementById('addTCTimeEntryBtn').addEventListener('click', () => {
  addTCTimeEntryRow('', '');
});

function addEveningTimeEntryRow(startVal, endVal) {
  const container = document.getElementById('eveningTimeEntriesContainer');
  const row = document.createElement('div');
  row.className = 'time-entry-row';
  row.innerHTML = `
    <input type="text" inputmode="numeric" placeholder="HH:MM" maxlength="5" class="mil-time eve-start" value="${startVal}">
    <span class="te-label">to</span>
    <input type="text" inputmode="numeric" placeholder="HH:MM" maxlength="5" class="mil-time eve-end" value="${endVal}">
    <button type="button" class="remove-entry-btn">&times;</button>
  `;
  row.querySelector('.remove-entry-btn').addEventListener('click', () => { row.remove(); });
  row.querySelectorAll('input.mil-time').forEach(input => bindMilTimeInput(input));
  container.appendChild(row);
}

function collectEveningTimeEntries() {
  const rows = document.querySelectorAll('#eveningTimeEntriesContainer .time-entry-row');
  const entries = [];
  rows.forEach(row => {
    const start = row.querySelector('.eve-start')?.value || '';
    const end = row.querySelector('.eve-end')?.value || '';
    if (start) entries.push({ start, end });
  });
  return entries;
}

function populateEveningTimeEntries(entries) {
  const container = document.getElementById('eveningTimeEntriesContainer');
  container.innerHTML = '';
  entries.forEach(e => addEveningTimeEntryRow(e.start || '', e.end || ''));
}

shiftDateInput.addEventListener('change', function() {
  workingDate = this.value;
  document.getElementById('headerDateBtn').textContent = formatDateShort(workingDate);
  loadShiftForDate();
  deShiftEditing = false;
  updateDataEntryState();
  renderDECaseList();
  updateDETally();
});

function getSelectedAssignmentType() {
  return document.getElementById('shiftAssignmentType').value || 'OR';
}

function loadShiftForDate() {
  const date = workingDate;
  const shift = data.shifts[date];
  const banner = document.getElementById('editShiftBanner');
  if (shift) {
    banner.textContent = 'Editing shift for ' + formatDate(date);
    banner.classList.remove('hidden');
    // Backward compat: migrate old forcedOff flag to assignment type
    const effectiveType = shift.forcedOff ? 'forced_off' : shift.assignmentType;
    // If shift has pre-call overlay on mole/OB, show as pre_call with evening assignment
    const hasPreCallOverlay = (shift.preCallStart || shift.preCallEnd) && ['mole','OB_restricted'].includes(effectiveType);
    if (hasPreCallOverlay) {
      document.getElementById('shiftAssignmentType').value = 'pre_call';
      document.getElementById('timeEntriesLabel').textContent = 'Pre-Call Times';
      document.getElementById('eveningAssignmentSection').classList.remove('hidden');
      document.getElementById('eveningAssignmentType').value = effectiveType;
      document.getElementById('eveningTimeSection').classList.remove('hidden');
      // Split time entries: pre-call entries vs evening entries
      const pcEnd = timeToMinutes(shift.preCallEnd || '');
      const allEntries = shift.timeEntries || [];
      const preCallEntries = [];
      const eveningEntries = [];
      allEntries.forEach(e => {
        if (!e.start) return;
        const startMin = timeToMinutes(e.start);
        if (pcEnd > 0 && startMin < pcEnd) {
          preCallEntries.push(e);
        } else {
          eveningEntries.push(e);
        }
      });
      populateTimeEntries(preCallEntries.length > 0 ? preCallEntries : [{ start: shift.preCallStart || '07:00', end: shift.preCallEnd || '' }]);
      populateEveningTimeEntries(eveningEntries);
    } else {
      document.getElementById('shiftAssignmentType').value = effectiveType;
      const isPreCall = effectiveType === 'pre_call';
      document.getElementById('timeEntriesLabel').textContent = isPreCall ? 'Pre-Call Times' : 'Time Entries';
      document.getElementById('eveningAssignmentSection').classList.toggle('hidden', !isPreCall);
      if (!isPreCall) {
        document.getElementById('eveningAssignmentType').value = '';
        document.getElementById('eveningTimeSection').classList.add('hidden');
        document.getElementById('eveningTimeEntriesContainer').innerHTML = '';
      }
      populateTimeEntries(shift.timeEntries || [{ start: shift.startTime || '07:00', end: shift.endTime || '' }]);
    }
    document.getElementById('shiftHoliday').checked = shift.isHoliday || false;
    document.getElementById('cardiacLiverOptions').classList.toggle('hidden', shift.assignmentType !== 'cardiac_liver');
    document.getElementById('vacationRangeSection').classList.toggle('hidden', shift.assignmentType !== 'vacation');
    document.getElementById('vacationEndDate').value = '';
    document.getElementById('subspecCoverage').checked = shift.subspecCoverage || false;
    document.getElementById('teeCount').value = shift.teeCount || 0;
    if (shift.supervisionStart || shift.supervisionEnd) {
      document.getElementById('supervisionOverlayCheck').checked = true;
      document.getElementById('supervisionStart').value = shift.supervisionStart || '';
      document.getElementById('supervisionEnd').value = shift.supervisionEnd || '';
      document.getElementById('supervisionTimes').classList.remove('hidden');
    } else {
      document.getElementById('supervisionOverlayCheck').checked = false;
      document.getElementById('supervisionStart').value = '';
      document.getElementById('supervisionEnd').value = '';
      document.getElementById('supervisionTimes').classList.add('hidden');
    }
    if (shift.preCallStart || shift.preCallEnd) {
      document.getElementById('preCallOverlayCheck').checked = true;
      document.getElementById('preCallStartInput').value = shift.preCallStart || '';
      document.getElementById('preCallEndInput').value = shift.preCallEnd || '';
      document.getElementById('preCallTimes').classList.remove('hidden');
    } else {
      document.getElementById('preCallOverlayCheck').checked = false;
      document.getElementById('preCallStartInput').value = '';
      document.getElementById('preCallEndInput').value = '';
      document.getElementById('preCallTimes').classList.add('hidden');
    }
    // Temp coverage
    if (shift.tempCoverage && shift.tempCoverage.length > 0) {
      const tc = shift.tempCoverage[0];
      document.getElementById('tempCoverageCheck').checked = true;
      document.getElementById('tempCoverageForm').classList.remove('hidden');
      document.querySelector(`input[name="tcDirection"][value="${tc.type}"]`).checked = true;
      document.getElementById('tcStart').value = tc.start || '';
      document.getElementById('tcEnd').value = tc.end || '';
      if (tc.type === 'covering') {
        document.getElementById('tcTimeEntriesSection').classList.remove('hidden');
        populateTCTimeEntries(tc.timeEntries || []);
        // Hide regular time entries — coverage entries replace them
        document.getElementById('timeEntriesGroup').classList.add('hidden');
      } else {
        document.getElementById('tcTimeEntriesSection').classList.add('hidden');
        document.getElementById('tcTimeEntriesContainer').innerHTML = '';
        document.getElementById('timeEntriesGroup').classList.remove('hidden');
      }
    } else {
      document.getElementById('tempCoverageCheck').checked = false;
      document.getElementById('tempCoverageForm').classList.add('hidden');
      document.getElementById('tcStart').value = '';
      document.getElementById('tcEnd').value = '';
      document.getElementById('tcTimeEntriesSection').classList.add('hidden');
      document.getElementById('tcTimeEntriesContainer').innerHTML = '';
      document.getElementById('timeEntriesGroup').classList.remove('hidden');
    }
  } else {
    banner.classList.add('hidden');
    document.getElementById('shiftAssignmentType').value = 'OR';
    populateTimeEntries([{ start: '07:00', end: '' }]);
    document.getElementById('shiftHoliday').checked = false;
    document.getElementById('cardiacLiverOptions').classList.add('hidden');
    document.getElementById('vacationRangeSection').classList.add('hidden');
    document.getElementById('vacationEndDate').value = '';
    document.getElementById('subspecCoverage').checked = false;
    document.getElementById('teeCount').value = 0;
    document.getElementById('supervisionOverlayCheck').checked = false;
    document.getElementById('supervisionStart').value = '';
    document.getElementById('supervisionEnd').value = '';
    document.getElementById('supervisionTimes').classList.add('hidden');
    document.getElementById('preCallOverlayCheck').checked = false;
    document.getElementById('preCallStartInput').value = '';
    document.getElementById('preCallEndInput').value = '';
    document.getElementById('eveningAssignmentSection').classList.add('hidden');
    document.getElementById('eveningAssignmentType').value = '';
    document.getElementById('eveningTimeSection').classList.add('hidden');
    document.getElementById('eveningTimeEntriesContainer').innerHTML = '';
    document.getElementById('preCallTimes').classList.add('hidden');
    document.getElementById('tempCoverageCheck').checked = false;
    document.getElementById('tempCoverageForm').classList.add('hidden');
    document.getElementById('tcStart').value = '';
    document.getElementById('tcEnd').value = '';
    document.getElementById('tcTimeEntriesSection').classList.add('hidden');
    document.getElementById('tcTimeEntriesContainer').innerHTML = '';
    document.getElementById('timeEntriesGroup').classList.remove('hidden');
  }
  updateUnrestrictedCallVisibility();
  updateSupervisionOverlayVisibility();
  updatePreCallOverlayVisibility();
  updateTempCoverageVisibility();
  updateEndTimeWarning();
}

// ================================================================
// DATA ENTRY PAGE FUNCTIONS
// ================================================================
function updateDEStickyHeaderSpacer() {
  requestAnimationFrame(() => {
    const h = document.getElementById('deStickyHeader').offsetHeight;
    document.getElementById('deStickyHeaderSpacer').style.height = h + 'px';
  });
}

function loadDataEntryPage() {
  loadShiftForDate();
  updateORCaseVisibility();
  updateDataEntryState();
  renderDECaseList();
  updateDETally();
  // Show/hide back button based on whether we came from Shift Logs
  document.getElementById('backToShiftLogsBtn').classList.toggle('hidden', !returnToShiftLogs);
}

function updateDataEntryState() {
  const shift = data.shifts[workingDate];
  const summaryBar = document.getElementById('deShiftSummaryBar');
  const shiftSection = document.getElementById('deShiftSection');
  const caseSection = document.getElementById('deCaseSection');
  const caseListCard = document.getElementById('deCaseListCard');

  if (shift && !deShiftEditing) {
    // Shift exists and not editing — show summary bar, hide shift form, show case section
    summaryBar.classList.remove('hidden');
    shiftSection.style.display = 'none';
    const isVacation = shift.assignmentType === 'vacation';
    const isForcedOff = shift.assignmentType === 'forced_off' || shift.forcedOff;
    const badge = document.getElementById('deSSBBadge');
    const hasPreCallOverlay = (shift.preCallStart || shift.preCallEnd) && ['mole','OB_restricted'].includes(shift.assignmentType);
    badge.textContent = hasPreCallOverlay
      ? 'Pre-Call + ' + getAssignmentTypeName(shift.assignmentType)
      : getAssignmentTypeName(isForcedOff ? 'forced_off' : shift.assignmentType);
    badge.classList.toggle('vacation', isVacation);
    const entries = shift.timeEntries || [{ start: shift.startTime, end: shift.endTime }];
    if (isVacation) {
      document.getElementById('deSSBTimes').textContent = 'Vacation Day';
    } else if (isForcedOff) {
      document.getElementById('deSSBTimes').textContent = '56 pts — Forced Off';
    } else if (entries.length === 1) {
      document.getElementById('deSSBTimes').textContent = (entries[0].start || '?') + ' - ' + (entries[0].end || '?');
    } else {
      document.getElementById('deSSBTimes').textContent = entries.length + ' time entries';
    }
    // Show case section only if not vacation/forced off
    if (isVacation || isForcedOff) {
      caseSection.classList.add('hidden');
    } else {
      caseSection.classList.remove('hidden');
    }
    caseListCard.classList.remove('hidden');
  } else {
    // No shift or editing — show shift form, hide summary bar and case section
    summaryBar.classList.add('hidden');
    shiftSection.style.display = '';
    caseSection.classList.add('hidden');
    caseListCard.classList.toggle('hidden', !shift);
  }
  // Show "Add Cases" button only when editing an existing shift (so user can switch back to case view)
  const switchToCaseBtn = document.getElementById('switchToCaseEntryBtn');
  const isVacOrForcedForBtn = shift && (shift.assignmentType === 'vacation' || shift.assignmentType === 'forced_off' || shift.forcedOff);
  switchToCaseBtn.classList.toggle('hidden', !(shift && deShiftEditing && !isVacOrForcedForBtn));
  // Show delete button only when editing an existing shift
  document.getElementById('deleteShiftDE').classList.toggle('hidden', !shift);
  updateDEStickyHeaderSpacer();
}

function renderDECaseList() {
  const listEl = document.getElementById('deCaseList');
  const countEl = document.getElementById('deCaseCount');
  const shift = data.shifts[workingDate];
  const shiftCases = data.cases.filter(c => c.shiftDate === workingDate);
  countEl.textContent = shiftCases.length > 0 ? `(${shiftCases.length})` : '';

  if (shiftCases.length === 0) {
    listEl.innerHTML = '<p style="color:var(--text-dim);font-size:0.85rem;">No cases logged yet.</p>';
    return;
  }

  let html = '';
  shiftCases.forEach(c => {
    const pts = shift ? calcCasePoints(c, shift) : 0;
    const name = c.caseType === 'standard' ? (c.procedure || 'Standard Case') : getCaseTypeName(c.caseType);
    const timeStr = c.startTime && c.endTime ? `${c.startTime} - ${c.endTime}` : '';
    html += `<div class="de-case-list-item" onclick="openCaseEdit('${c.id}')" style="cursor:pointer;">
      <div class="de-info">
        <div class="de-name">${escHtml(name)}</div>
        ${timeStr ? `<div class="de-detail">${escHtml(timeStr)}</div>` : ''}
      </div>
      <div class="de-actions">
        <span class="de-pts">${pts.toFixed(1)}</span>
        <span onclick="event.stopPropagation();deleteCaseDE('${c.id}')" style="color:var(--danger);cursor:pointer;font-size:1rem;padding:4px;line-height:1;">&times;</span>
      </div>
    </div>`;
  });
  listEl.innerHTML = html;
}

function updateDETally() {
  const shift = data.shifts[workingDate];
  const tallyEl = document.getElementById('deTallyValue');
  if (!shift) {
    tallyEl.textContent = '0';
    return;
  }
  const totals = calcShiftTotal(shift);
  tallyEl.textContent = totals.total.toFixed(1);
}

function deleteCaseDE(id) {
  if (!confirm('Delete this case?')) return;
  data.cases = data.cases.filter(c => c.id !== id);
  saveData(data);
  updateHeaderPoints();
  renderDECaseList();
  updateDETally();
  renderToday();
  showToast('Case deleted');
}

// Summary bar click — re-expand shift form for editing
document.getElementById('deShiftSummaryBar').addEventListener('click', () => {
  deShiftEditing = true;
  loadShiftForDate();
  updateDataEntryState();
});

// "Edit Shift" button in case section — switch to shift entry view
document.getElementById('switchToShiftEntryBtn').addEventListener('click', () => {
  deShiftEditing = true;
  loadShiftForDate();
  updateDataEntryState();
});

// "Add Cases" button in shift section — switch back to case entry view (without saving)
document.getElementById('switchToCaseEntryBtn').addEventListener('click', () => {
  deShiftEditing = false;
  updateDataEntryState();
});

document.getElementById('deleteShiftDE').addEventListener('click', () => {
  const shift = data.shifts[workingDate];
  if (!shift) return;
  if (!confirm('Delete this shift? This cannot be undone.')) return;
  delete data.shifts[workingDate];
  saveData(data);
  deShiftEditing = false;
  updateHeaderPoints();
  loadShiftForDate();
  updateDataEntryState();
  renderDECaseList();
  updateDETally();
  renderShiftLogTable();
  renderToday();
  if (returnToShiftLogs) {
    navigateToShiftLogs();
  } else {
    showToast('Shift deleted');
  }
});

document.getElementById('saveShiftBtn').addEventListener('click', () => {
  const date = workingDate;
  if (!date) { showToast('Please select a date'); return; }
  let assignmentType = getSelectedAssignmentType();
  const supervisionEnabled = document.getElementById('supervisionOverlayCheck')?.checked || false;
  const preCallEnabled = document.getElementById('preCallOverlayCheck')?.checked || false;
  // Pre-Call with evening assignment: save as evening type with pre-call overlay
  const eveningAssignment = assignmentType === 'pre_call' ? (document.getElementById('eveningAssignmentType').value || '') : '';
  const isVacation = assignmentType === 'vacation';
  const isForcedOff = assignmentType === 'forced_off';
  const timeEntries = isVacation ? [{ start: '', end: '' }] : isForcedOff ? [{ start: '07:00', end: '20:00' }] : collectTimeEntries();
  const effectiveType = eveningAssignment || assignmentType;
  const hasPagerWindow = getPagerPayWindow(effectiveType, isWeekend(date) || document.getElementById('holidayCheck')?.checked) !== null;
  if (!isVacation && !isForcedOff && (timeEntries.length === 0 || !timeEntries[0].start) && !hasPagerWindow) {
    showToast('Please enter at least one start time');
    return;
  }
  // Validate: entries should be in chronological order, no overlaps (cross-midnight aware)
  if (!isVacation) {
    for (let i = 1; i < timeEntries.length; i++) {
      const prevEnd = timeToMinutes(timeEntries[i-1].end);
      let currStart = timeToMinutes(timeEntries[i].start);
      // If current start is before previous end, assume cross-midnight
      if (currStart < timeToMinutes(timeEntries[0].start)) currStart += 1440;
      let adjPrevEnd = prevEnd;
      if (adjPrevEnd < timeToMinutes(timeEntries[0].start)) adjPrevEnd += 1440;
      if (timeEntries[i-1].end && currStart <= adjPrevEnd) {
        showToast('Time entries must be in chronological order with no overlaps');
        return;
      }
    }
  }
  // Build list of dates to save (range for vacation, single otherwise)
  const datesToSave = [date];
  if (isVacation) {
    const vacEnd = document.getElementById('vacationEndDate').value;
    if (vacEnd && vacEnd > date) {
      const startD = new Date(date + 'T00:00:00');
      const endD = new Date(vacEnd + 'T00:00:00');
      datesToSave.length = 0;
      for (let d = new Date(startD); d <= endD; d.setDate(d.getDate() + 1)) {
        datesToSave.push(d.toISOString().split('T')[0]);
      }
    }
  }
  let skipped = 0;
  datesToSave.forEach(dt => {
    if (isVacation && datesToSave.length > 1 && data.shifts[dt] && data.shifts[dt].assignmentType !== 'vacation') {
      skipped++;
      return; // don't overwrite existing non-vacation shifts
    }
    // When pre_call with evening assignment, merge pre-call + evening time entries
    let savePreCallStart = preCallEnabled ? document.getElementById('preCallStartInput').value : '';
    let savePreCallEnd = preCallEnabled ? document.getElementById('preCallEndInput').value : '';
    let allTimeEntries = timeEntries;
    if (eveningAssignment && assignmentType === 'pre_call') {
      // Pre-call window from the main time entries
      const firstStart = timeEntries[0]?.start || '';
      const lastEnd = timeEntries[timeEntries.length - 1]?.end || '';
      savePreCallStart = firstStart;
      savePreCallEnd = lastEnd;
      // Merge evening time entries
      const eveningEntries = collectEveningTimeEntries();
      allTimeEntries = [...timeEntries, ...eveningEntries];
    }
    data.shifts[dt] = {
      date: dt, assignmentType: effectiveType,
      startTime: allTimeEntries[0]?.start || '',
      endTime: allTimeEntries[allTimeEntries.length - 1]?.end || '',
      timeEntries: allTimeEntries,
      isHoliday: document.getElementById('shiftHoliday').checked,
      forcedOff: false,
      subspecCoverage: document.getElementById('subspecCoverage').checked,
      teeCount: parseInt(document.getElementById('teeCount').value) || 0,
      supervisionStart: supervisionEnabled ? document.getElementById('supervisionStart').value : '',
      supervisionEnd: supervisionEnabled ? document.getElementById('supervisionEnd').value : '',
      preCallStart: savePreCallStart,
      preCallEnd: savePreCallEnd,
      tempCoverage: (() => {
        const tcCheck = document.getElementById('tempCoverageCheck');
        if (!tcCheck || !tcCheck.checked) return [];
        const dir = document.querySelector('input[name="tcDirection"]:checked')?.value || 'covered';
        const tcStartVal = document.getElementById('tcStart').value;
        const tcEndVal = document.getElementById('tcEnd').value;
        if (!tcStartVal || !tcEndVal) return [];
        const entry = { type: dir, start: tcStartVal, end: tcEndVal };
        if (dir === 'covering') entry.timeEntries = collectTCTimeEntries();
        else entry.timeEntries = [];
        return [entry];
      })()
    };
  });
  saveData(data);
  updateHeaderPoints();
  updateEndTimeWarning();
  updateORCaseVisibility();
  renderShiftLogTable();
  if (datesToSave.length > 1) {
    const msg = `${datesToSave.length - skipped} vacation day${datesToSave.length - skipped !== 1 ? 's' : ''} saved!` + (skipped ? ` (${skipped} existing shift${skipped !== 1 ? 's' : ''} skipped)` : '');
    showToast(msg);
  } else {
    showToast('Shift saved!');
  }
  deShiftEditing = false;
  if (returnToShiftLogs) {
    navigateToShiftLogs();
  } else {
    updateDataEntryState();
    renderDECaseList();
    updateDETally();
  }
});

// ================================================================
// CASE PAGE
// ================================================================
let selectedCaseType = 'standard';

document.getElementById('caseTypeSelect').addEventListener('change', function() {
  selectedCaseType = this.value;
  applyCaseTypeVisibility(selectedCaseType);
  updatePointPreview();
});

function applyCaseTypeVisibility(ct) {
  const isStd = ct === 'standard';
  const isLabor = ct === 'labor_epidural';
  const isAPS = ct === 'aps_rounding';
  const isAcutePain = ct === 'acute_pain_procedure';
  document.getElementById('standardFields').classList.toggle('hidden', !isStd);
  document.getElementById('laborEpiduralFields').classList.toggle('hidden', !isLabor);
  document.getElementById('apsRoundingFields').classList.toggle('hidden', !isAPS);
  document.getElementById('simpleFields').classList.toggle('hidden', isStd || isLabor || isAPS || isAcutePain);
}

document.getElementById('caseShared').addEventListener('change', function() {
  document.getElementById('sharedPctRow').classList.toggle('hidden', !this.checked);
  updatePointPreview();
});

// Procedure autocomplete
(function() {
  const procInput = document.getElementById('caseProcedure');
  const sugBox = document.getElementById('procSuggestions');
  const baseUnitsInput = document.getElementById('caseBaseUnits');
  let activeIdx = -1;
  let baseUnitsAutoFilled = false;

  function getProcHistory() {
    const map = {};
    data.cases.forEach(c => {
      if (c.caseType !== 'standard' || !c.procedure) return;
      const name = c.procedure.trim();
      if (!name) return;
      if (!map[name]) map[name] = { count: 0, lastUnits: '' };
      map[name].count++;
      if (c.baseUnits) map[name].lastUnits = c.baseUnits;
    });
    return map;
  }

  function showSuggestions() {
    const query = procInput.value.trim().toLowerCase();
    if (!query) { hideSuggestions(); return; }
    const history = getProcHistory();
    const matches = Object.entries(history)
      .filter(([name]) => name.toLowerCase().includes(query))
      .sort((a, b) => b[1].count - a[1].count)
      .slice(0, 8);
    if (matches.length === 0) { hideSuggestions(); return; }
    activeIdx = -1;
    sugBox.innerHTML = matches.map(([name, d], i) =>
      `<div class="proc-item" data-idx="${i}" data-name="${escHtml(name)}" data-units="${escHtml(d.lastUnits)}">${escHtml(name)}<span class="proc-units">${d.lastUnits ? d.lastUnits + 'u' : ''} (${d.count})</span></div>`
    ).join('');
    sugBox.classList.remove('hidden');
  }

  function hideSuggestions() { sugBox.classList.add('hidden'); sugBox.innerHTML = ''; activeIdx = -1; }

  function selectItem(el) {
    procInput.value = el.dataset.name;
    const units = el.dataset.units;
    if (units) { baseUnitsInput.value = units; baseUnitsAutoFilled = true; }
    hideSuggestions();
    updatePointPreview();
  }

  procInput.addEventListener('input', showSuggestions);
  procInput.addEventListener('focus', () => { if (procInput.value.trim()) showSuggestions(); });

  procInput.addEventListener('keydown', function(e) {
    const items = sugBox.querySelectorAll('.proc-item');
    if (items.length === 0) return;
    if (e.key === 'ArrowDown') {
      e.preventDefault();
      activeIdx = Math.min(activeIdx + 1, items.length - 1);
      items.forEach((el, i) => el.classList.toggle('active', i === activeIdx));
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      activeIdx = Math.max(activeIdx - 1, 0);
      items.forEach((el, i) => el.classList.toggle('active', i === activeIdx));
    } else if (e.key === 'Enter' && activeIdx >= 0) {
      e.preventDefault();
      selectItem(items[activeIdx]);
    } else if (e.key === 'Escape') {
      hideSuggestions();
    }
  });

  sugBox.addEventListener('click', function(e) {
    const item = e.target.closest('.proc-item');
    if (item) selectItem(item);
  });

  // Allow editing base units after auto-fill
  baseUnitsInput.addEventListener('focus', function() { baseUnitsAutoFilled = false; });

  document.addEventListener('click', function(e) {
    if (!e.target.closest('.proc-autocomplete')) hideSuggestions();
  });
})();

['caseBaseUnits','caseStart','caseEnd','casePhysicalStatus','laborStart','laborEnd','caseNerveBlock','apsEpiduralCount','apsPainCount','caseSharedPct'].forEach(id => {
  const el = document.getElementById(id);
  if (el) { el.addEventListener('input', updatePointPreview); el.addEventListener('change', updatePointPreview); }
});

['caseEmergency','caseHighRiskPeds','caseORCase','caseCentralLine','caseArterialLine','casePAC','caseTEEAddOn','caseITMorphine','caseShared'].forEach(id => {
  const el = document.getElementById(id);
  if (el) el.addEventListener('change', updatePointPreview);
});

// Auto-check OR Case for SF1 — all cases on SF1 default to OR rates
document.getElementById('caseStart').addEventListener('change', function() {
  const shift = data.shifts[workingDate];
  if (!shift || shift.assignmentType !== 'SF1') return;
  const startMin = timeToMinutes(this.value);
  if (isNaN(startMin)) return;
  document.getElementById('caseORCase').checked = true;
  updatePointPreview();
});

function updateModifierTags() {
  const tags = [];
  if (document.getElementById('caseEmergency').checked) tags.push('Emergency');
  if (document.getElementById('caseHighRiskPeds').checked) tags.push('High Risk Peds');
  if (document.getElementById('caseORCase').checked) tags.push('OR Case');
  if (document.getElementById('caseShared').checked) tags.push('Shared');
  document.getElementById('modifierTags').innerHTML = tags.map(t => `<span class="mod-tag">${t}</span>`).join('');
}

function updatePointPreview() {
  updateModifierTags();
  const previewEl = document.getElementById('casePointPreview');
  const previewPts = document.getElementById('previewPoints');
  const tempCase = buildCaseFromForm();
  const shift = data.shifts[workingDate] || { date: workingDate, assignmentType: 'OR', isHoliday: false };
  const pts = calcCasePoints(tempCase, shift);
  previewEl.classList.remove('hidden');
  previewPts.textContent = pts.toFixed(2) + ' pts';
}

function buildCaseFromForm() {
  const isLabor = selectedCaseType === 'labor_epidural';
  const isAPS = selectedCaseType === 'aps_rounding';
  return {
    caseType: selectedCaseType,
    procedure: isLabor ? 'Labor Epidural' : (isAPS ? 'APS Rounding' : (document.getElementById('caseProcedure')?.value || selectedCaseType)),
    baseUnits: document.getElementById('caseBaseUnits')?.value || '',
    physicalStatus: document.getElementById('casePhysicalStatus')?.value || 'P2',
    startTime: isLabor ? (document.getElementById('laborStart')?.value || '') : (document.getElementById('caseStart')?.value || ''),
    endTime: isLabor ? (document.getElementById('laborEnd')?.value || '') : (document.getElementById('caseEnd')?.value || ''),
    isEmergency: document.getElementById('caseEmergency')?.checked || false,
    isMedicalProc: false,
    medicalUnits: 0,
    isAcutePain: false,
    acutePainUnits: 0,
    isHighRiskPeds: document.getElementById('caseHighRiskPeds')?.checked || false,
    isORCase: document.getElementById('caseORCase')?.checked || false,
    isSharedCase: document.getElementById('caseShared')?.checked || false,
    sharedStartupPct: document.getElementById('caseSharedPct')?.value || 50,
    nerveBlock: document.getElementById('caseNerveBlock')?.value || 'none',
    hasCentralLine: document.getElementById('caseCentralLine')?.checked || false,
    hasArterialLine: document.getElementById('caseArterialLine')?.checked || false,
    hasPAC: document.getElementById('casePAC')?.checked || false,
    hasTEEAddOn: document.getElementById('caseTEEAddOn')?.checked || false,
    hasITMorphine: document.getElementById('caseITMorphine')?.checked || false,
    epiduralRounds: document.getElementById('apsEpiduralCount')?.value || 0,
    painRounds: document.getElementById('apsPainCount')?.value || 0,
    notes: document.getElementById('caseNotes')?.value || ''
  };
}

document.getElementById('saveCaseBtn').addEventListener('click', () => {
  const date = workingDate;
  if (!date) { showToast('Set shift date first'); return; }
  if (!data.shifts[date]) { showToast('Please save a shift for this date first'); return; }
  if (data.shifts[date].assignmentType === 'vacation') { showToast('Vacation days do not have cases'); return; }
  const caseData = buildCaseFromForm();
  caseData.id = genId();
  caseData.shiftDate = date;
  caseData.timestamp = new Date().toISOString();
  if (caseData.caseType === 'labor_epidural') {
    if (!caseData.startTime || !caseData.endTime) { showToast('Please enter start and end times'); return; }
  }
  if (caseData.caseType === 'standard') {
    if (!caseData.startTime) { showToast('Please enter a start time'); return; }
  }
  if (caseData.caseType === 'aps_rounding') {
    if (!(parseInt(caseData.epiduralRounds) > 0) && !(parseInt(caseData.painRounds) > 0)) { showToast('Enter at least one round count'); return; }
  }
  data.cases.push(caseData);
  saveData(data);
  updateHeaderPoints();
  showToast('Case saved! (' + calcCasePoints(caseData, data.shifts[date]).toFixed(2) + ' pts)');
  resetCaseForm();
  renderDECaseList();
  updateDETally();
});

function resetCaseForm() {
  selectedCaseType = 'standard';
  document.getElementById('caseTypeSelect').value = 'standard';
  applyCaseTypeVisibility('standard');
  document.getElementById('caseProcedure').value = '';
  document.getElementById('caseBaseUnits').value = '';
  document.getElementById('casePhysicalStatus').value = 'P2';
  document.getElementById('caseStart').value = '';
  document.getElementById('caseEnd').value = '';
  document.getElementById('caseEmergency').checked = false;
  document.getElementById('caseHighRiskPeds').checked = false;
  document.getElementById('caseORCase').checked = false;
  document.getElementById('caseShared').checked = false;
  document.getElementById('caseSharedPct').value = '50';
  document.getElementById('sharedPctRow').classList.add('hidden');
  document.getElementById('caseNerveBlock').value = 'none';
  document.getElementById('caseCentralLine').checked = false;
  document.getElementById('caseArterialLine').checked = false;
  document.getElementById('casePAC').checked = false;
  document.getElementById('caseTEEAddOn').checked = false;
  document.getElementById('caseITMorphine').checked = false;
  document.getElementById('laborStart').value = '';
  document.getElementById('laborEnd').value = '';
  document.getElementById('apsEpiduralCount').value = '0';
  document.getElementById('apsPainCount').value = '0';
  document.getElementById('caseNotes').value = '';
  document.getElementById('simpleNotes').value = '';
  document.getElementById('casePointPreview').classList.add('hidden');
  document.getElementById('modifiersSection').removeAttribute('open');
  updateModifierTags();
}

// ================================================================
// TODAY PAGE
// ================================================================
function renderToday() {
  const date = workingDate;
  const shift = data.shifts[date];
  const shiftCases = data.cases.filter(c => c.shiftDate === date);
  document.getElementById('todayTitle').textContent = date === todayStr() ? "Today's Summary" : formatDate(date);

  // Back bar and edit shift button
  const backBar = document.getElementById('todayBackBar');
  const editShiftBtn = document.getElementById('todayEditShiftBtn');
  if (returnToDailyTab) {
    backBar.style.display = 'flex';
    backBar.classList.remove('hidden');
  } else {
    backBar.style.display = 'none';
  }
  if (shift) {
    editShiftBtn.classList.remove('hidden');
    editShiftBtn.onclick = () => openShiftEdit(date);
  } else {
    editShiftBtn.classList.add('hidden');
  }

  if (!shift) {
    document.getElementById('todayAR').textContent = '0';
    document.getElementById('todayProd').textContent = '0';
    document.getElementById('todayCall').textContent = '0';
    document.getElementById('todayTotal').textContent = '0';
    document.getElementById('todayBreakdown').innerHTML = '<p style="color:var(--text-dim);font-size:0.85rem;">No shift saved for this date.</p>';
    document.getElementById('todayCaseList').innerHTML = '<div class="empty-state"><p>No cases logged yet.</p></div>';
    document.getElementById('todayCaseCount').textContent = '';
    return;
  }

  const totals = calcShiftTotal(shift);
  document.getElementById('todayAR').textContent = totals.ar.toFixed(1);
  document.getElementById('todayProd').textContent = totals.prod.toFixed(1);
  document.getElementById('todayCall').textContent = (totals.call + totals.subspec + totals.supervision).toFixed(1);
  document.getElementById('todayTotal').textContent = totals.total.toFixed(1);

  let bdHtml = '<div class="point-breakdown">';
  const isWkndOrHol = shift.isHoliday || isWeekend(shift.date);
  const pagerWindow = getPagerPayWindow(shift.assignmentType, isWkndOrHol);
  const isCoveringShift = shift.tempCoverage && shift.tempCoverage.length > 0 && shift.tempCoverage[0].type === 'covering';

  if (isCoveringShift) {
    // Covering shift: show coverage interval + time punches only
    const tc = shift.tempCoverage[0];
    bdHtml += `<div class="row" style="font-size:0.75rem;color:var(--accent2)"><span>Coverage Pager: ${tc.start} - ${tc.end}</span><span></span></div>`;
    const tcEntries = tc.timeEntries || [];
    tcEntries.forEach(e => {
      if (e.start) bdHtml += `<div class="row" style="font-size:0.75rem;"><span>Clocked in: ${e.start} - ${e.end || '?'}</span><span></span></div>`;
    });
    bdHtml += `<div class="row"><span>Coverage AR</span><span>${totals.ar.toFixed(2)}</span></div>`;
    bdHtml += `<div class="row"><span>Productivity (${shiftCases.length} cases)</span><span>${totals.prod.toFixed(2)}</span></div>`;
    const pagerHrs = round2(totals.call / 3.5);
    bdHtml += `<div class="row"><span>Coverage Pager Pay (${pagerHrs.toFixed(1)} hrs × 3.5)</span><span>${totals.call.toFixed(2)}</span></div>`;
  } else {
    // Regular shift: show time entries + standard breakdown
    const entries = shift.timeEntries || [{ start: shift.startTime, end: shift.endTime }];
    if (entries.length > 1) {
      bdHtml += `<div class="row" style="font-size:0.75rem;color:var(--text-dim);border-bottom:1px solid var(--border);padding-bottom:6px;margin-bottom:4px;"><span>Time Entries (${entries.length})</span><span></span></div>`;
      for (let i = 0; i < entries.length; i++) {
        if (i === 0 && pagerWindow && entries[i].start) {
          const entryStart = timeToMinutes(entries[i].start);
          if (pagerWindow.start < entryStart) {
            bdHtml += `<div class="row" style="font-size:0.75rem;color:var(--accent2)"><span>Pager: ${minutesToTimeStr(pagerWindow.start)} - ${entries[i].start}</span><span></span></div>`;
          }
        }
        bdHtml += `<div class="row" style="font-size:0.75rem;"><span>Clocked in: ${entries[i].start} - ${entries[i].end || '?'}</span><span></span></div>`;
        if (i < entries.length - 1 && entries[i].end && entries[i+1].start) {
          if (pagerWindow) {
            bdHtml += `<div class="row" style="font-size:0.75rem;color:var(--accent2)"><span>Pager: ${entries[i].end} - ${entries[i+1].start}</span><span></span></div>`;
          } else {
            bdHtml += `<div class="row" style="font-size:0.75rem;color:var(--text-dim)"><span>Gap: ${entries[i].end} - ${entries[i+1].start}</span><span></span></div>`;
          }
        }
        if (i === entries.length - 1 && pagerWindow && entries[i].end) {
          const entryEnd = timeToMinutes(entries[i].end);
          const adjustedEnd = entryEnd <= timeToMinutes(entries[0].start) ? entryEnd + 1440 : entryEnd;
          if (adjustedEnd < pagerWindow.end) {
            bdHtml += `<div class="row" style="font-size:0.75rem;color:var(--accent2)"><span>Pager: ${entries[i].end} - ${minutesToTimeStr(pagerWindow.end)}</span><span></span></div>`;
          }
        }
      }
    } else if (entries.length === 1) {
      if (pagerWindow && entries[0].start) {
        const entryStart = timeToMinutes(entries[0].start);
        if (pagerWindow.start < entryStart) {
          bdHtml += `<div class="row" style="font-size:0.75rem;color:var(--accent2)"><span>Pager: ${minutesToTimeStr(pagerWindow.start)} - ${entries[0].start}</span><span></span></div>`;
        }
      }
      bdHtml += `<div class="row" style="font-size:0.75rem;color:var(--text-dim);"><span>Clocked in: ${entries[0].start} - ${entries[0].end || '?'}</span><span></span></div>`;
      if (pagerWindow && entries[0].end) {
        const entryEnd = timeToMinutes(entries[0].end);
        const entryStart = timeToMinutes(entries[0].start);
        const adjustedEnd = entryEnd <= entryStart ? entryEnd + 1440 : entryEnd;
        if (adjustedEnd < pagerWindow.end) {
          bdHtml += `<div class="row" style="font-size:0.75rem;color:var(--accent2)"><span>Pager: ${entries[0].end} - ${minutesToTimeStr(pagerWindow.end)}</span><span></span></div>`;
        }
      }
    }
    // Show AR breakdown: split for pre-call shifts
    const arBreakdown = calcARBreakdown(shift);
    if (arBreakdown.preCallAR !== undefined) {
      const eveningName = getAssignmentTypeName(shift.assignmentType);
      bdHtml += `<div class="row"><span>Pre-Call AR</span><span>${arBreakdown.preCallAR.toFixed(2)}</span></div>`;
      bdHtml += `<div class="row"><span>${escHtml(eveningName)} AR</span><span>${arBreakdown.eveningAR.toFixed(2)}</span></div>`;
    } else {
      bdHtml += `<div class="row"><span>Availability Rate</span><span>${totals.ar.toFixed(2)}</span></div>`;
    }
    bdHtml += `<div class="row"><span>Productivity (${shiftCases.length} cases)</span><span>${totals.prod.toFixed(2)}</span></div>`;
    // Show pager pay line item
    if (pagerWindow) {
      const pagerHrs = round2(totals.call / 3.5);
      bdHtml += `<div class="row"><span>Pager Pay (${pagerHrs.toFixed(1)} hrs × 3.5)</span><span>${totals.call.toFixed(2)}</span></div>`;
    } else if (totals.call > 0) {
      bdHtml += `<div class="row"><span>Pager Pay</span><span>${totals.call.toFixed(2)}</span></div>`;
    }
    // Temp coverage (covered) line item
    if (shift.tempCoverage && shift.tempCoverage.length > 0 && shift.tempCoverage[0].type === 'covered') {
      const tcPts = calcTempCoveragePoints(shift);
      const tcTotal = round2(tcPts.pagerAdj);
      if (tcTotal !== 0) {
        const tc = shift.tempCoverage[0];
        bdHtml += `<div class="row"><span>Temp Coverage (Covered) ${tc.start}-${tc.end}</span><span>${tcTotal.toFixed(2)}</span></div>`;
      }
    }
  }
  if (totals.subspec > 0) bdHtml += `<div class="row"><span>Subspecialty</span><span>${totals.subspec.toFixed(2)}</span></div>`;
  if (totals.supervision > 0) bdHtml += `<div class="row"><span>CRNA Supervision</span><span>${totals.supervision.toFixed(2)}</span></div>`;
  bdHtml += `<div class="row total"><span>Total</span><span>${totals.total.toFixed(2)} pts</span></div>`;
  bdHtml += '</div>';
  document.getElementById('todayBreakdown').innerHTML = bdHtml;

  document.getElementById('todayCaseCount').textContent = `(${shiftCases.length})`;

  if (shiftCases.length === 0) {
    document.getElementById('todayCaseList').innerHTML = '<div class="empty-state"><p>No cases logged yet.</p></div>';
    return;
  }

  let listHtml = '';
  shiftCases.forEach(c => {
    const pts = calcCasePoints(c, shift);
    const name = c.caseType === 'standard' ? (c.procedure || 'Standard Case') : getCaseTypeName(c.caseType);
    const orTag = c.isORCase ? ' <span style="color:var(--accent2);font-size:0.75rem;">[OR]</span>' : '';
    const sharedTag = c.isSharedCase ? ` <span style="color:var(--purple);font-size:0.75rem;">[Shared ${c.sharedStartupPct || 50}%]</span>` : '';
    const timeStr = c.startTime && c.endTime ? `${c.startTime} - ${c.endTime}` : '';
    const details = [];
    if (c.physicalStatus && c.caseType === 'standard') details.push(c.physicalStatus);
    if (c.baseUnits && c.caseType === 'standard') details.push(`${c.baseUnits} base`);
    if (timeStr) details.push(timeStr);
    if (c.caseType === 'aps_rounding') {
      const epi = parseInt(c.epiduralRounds) || 0;
      const pain = parseInt(c.painRounds) || 0;
      if (epi > 0) details.push(`${epi} epi`);
      if (pain > 0) details.push(`${pain} pain`);
    }
    listHtml += `
      <div class="case-list-item">
        <div class="info">
          <h4>${escHtml(name)}${orTag}${sharedTag}</h4>
          <p>${escHtml(details.join(' | '))}</p>
          ${c.notes ? `<p style="margin-top:2px;font-style:italic;">${escHtml(c.notes)}</p>` : ''}
        </div>
        <div class="actions">
          <span class="point-badge">${pts.toFixed(1)} pts</span>
          <button class="btn btn-outline btn-sm" onclick="openCaseEdit('${c.id}')" style="padding:2px 8px;font-size:0.68rem;">Edit</button>
          <button class="btn btn-danger btn-sm" onclick="deleteCase('${c.id}')">Del</button>
        </div>
      </div>`;
  });
  document.getElementById('todayCaseList').innerHTML = listHtml;
}

// Back button: return to Dashboard Daily tab
document.getElementById('todayBackBtn').addEventListener('click', () => {
  returnToDailyTab = false;
  document.querySelectorAll('.bottom-nav button').forEach(b => b.classList.remove('active'));
  document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
  const dashBtn = document.querySelector('.bottom-nav button[data-page="dashboard"]');
  if (dashBtn) dashBtn.classList.add('active');
  document.getElementById('page-dashboard').classList.add('active');
  switchDashboardTab('daily');
});

function escHtml(s) {
  const div = document.createElement('div');
  div.textContent = s;
  return div.innerHTML;
}

function deleteCase(id) {
  if (!confirm('Delete this case?')) return;
  data.cases = data.cases.filter(c => c.id !== id);
  saveData(data);
  updateHeaderPoints();
  renderToday();
  renderCaseLogTable();
  renderDECaseList();
  updateDETally();
  showToast('Case deleted');
}

// ================================================================
// HISTORY (in More page)
// ================================================================
let historyYear = new Date().getFullYear();
let historyMonth = new Date().getMonth();

function renderHistory() {
  const monthNames = ['January','February','March','April','May','June','July','August','September','October','November','December'];
  document.getElementById('historyMonth').textContent = `${monthNames[historyMonth]} ${historyYear}`;
  const prefix = `${historyYear}-${String(historyMonth+1).padStart(2,'0')}`;
  const monthShifts = Object.values(data.shifts).filter(s => s.date.startsWith(prefix)).sort((a,b) => b.date.localeCompare(a.date));
  let monthTotalPts = 0;
  let listHtml = '';
  monthShifts.forEach(shift => {
    const totals = calcShiftTotal(shift);
    monthTotalPts += totals.total;
    const caseCount = data.cases.filter(c => c.shiftDate === shift.date).length;
    const entries = shift.timeEntries || [{ start: shift.startTime, end: shift.endTime }];
    const timeStr = entries.map(e => `${e.start}-${e.end || '?'}`).join(', ');
    listHtml += `
      <div class="day-list-item" onclick="showDayDetail('${shift.date}')">
        <div>
          <div class="date">${formatDate(shift.date)}</div>
          <div class="meta">${getAssignmentTypeName(shift.assignmentType)} | ${timeStr} | ${caseCount} cases</div>
        </div>
        <span class="point-badge large">${totals.total.toFixed(1)}</span>
      </div>`;
  });
  document.getElementById('monthTotal').textContent = monthTotalPts.toFixed(1);
  document.getElementById('monthDays').textContent = monthShifts.length;
  document.getElementById('historyList').innerHTML = monthShifts.length === 0
    ? '<div class="empty-state"><p>No shifts recorded for this month.</p></div>'
    : listHtml;
}

document.getElementById('prevMonth').addEventListener('click', () => {
  historyMonth--;
  if (historyMonth < 0) { historyMonth = 11; historyYear--; }
  renderHistory();
});

document.getElementById('nextMonth').addEventListener('click', () => {
  historyMonth++;
  if (historyMonth > 11) { historyMonth = 0; historyYear++; }
  renderHistory();
});

function showDayDetail(dateStr) {
  const shift = data.shifts[dateStr];
  if (!shift) return;
  const totals = calcShiftTotal(shift);
  const shiftCases = data.cases.filter(c => c.shiftDate === dateStr);
  document.getElementById('dayModalTitle').textContent = formatDate(dateStr);
  const detailEntries = shift.timeEntries || [{ start: shift.startTime, end: shift.endTime }];
  const detailTimeStr = detailEntries.map(e => `${e.start}-${e.end || '?'}`).join(', ');
  let html = `
    <p style="font-size:0.8rem;color:var(--text-dim);margin-bottom:8px;">${getAssignmentTypeName(shift.assignmentType)} | ${detailTimeStr}${detailEntries.length > 1 ? ' (' + detailEntries.length + ' entries)' : ''}</p>
    <div class="summary-grid" style="margin-bottom:12px;">
      <div class="summary-item"><div class="label">AR</div><div class="value blue">${totals.ar.toFixed(1)}</div></div>
      <div class="summary-item"><div class="label">Prod</div><div class="value green">${totals.prod.toFixed(1)}</div></div>
      <div class="summary-item"><div class="label">Call/Other</div><div class="value yellow">${(totals.call + totals.subspec + totals.supervision).toFixed(1)}</div></div>
      <div class="summary-item"><div class="label">Total</div><div class="value">${totals.total.toFixed(1)}</div></div>
    </div>
    <h3 style="margin-bottom:8px;">Cases (${shiftCases.length})</h3>`;
  shiftCases.forEach(c => {
    const pts = calcCasePoints(c, shift);
    const name = c.caseType === 'standard' ? (c.procedure || 'Standard Case') : getCaseTypeName(c.caseType);
    const breakdown = getCaseBreakdown(c, shift);
    html += `<div style="padding:8px 0;border-bottom:1px solid var(--surface2);">
      <div style="display:flex;justify-content:space-between;"><strong>${escHtml(name)}</strong><span class="point-badge">${pts.toFixed(1)}</span></div>`;
    breakdown.forEach(r => {
      html += `<div style="display:flex;justify-content:space-between;font-size:0.75rem;color:var(--text-dim);padding:2px 0;"><span>${escHtml(r.label)}</span><span>${r.pts.toFixed(2)}</span></div>`;
    });
    if (c.notes) html += `<div style="font-size:0.75rem;color:var(--text-dim);font-style:italic;margin-top:2px;">${escHtml(c.notes)}</div>`;
    html += '</div>';
  });
  document.getElementById('dayModalContent').innerHTML = html;
  document.getElementById('dayModal').classList.remove('hidden');
}

document.getElementById('closeDayModal').addEventListener('click', () => { document.getElementById('dayModal').classList.add('hidden'); });
document.getElementById('dayModal').addEventListener('click', (e) => {
  if (e.target.id === 'dayModal') document.getElementById('dayModal').classList.add('hidden');
});

// ================================================================
// DASHBOARD — Tabs & Rendering
// ================================================================
let monthlyChart = null;
let breakdownChart = null;
let pipelineChart = null;
let productionTrendChart = null;
let shiftDistChart = null;
let activeDashTab = 'daily';

// Dashboard sub-tab switching
document.querySelectorAll('.dash-tab-btn').forEach(btn => {
  btn.addEventListener('click', () => switchDashboardTab(btn.dataset.dtab));
});

function switchDashboardTab(tabName) {
  activeDashTab = tabName;
  document.querySelectorAll('.dash-tab-btn').forEach(b => b.classList.toggle('active', b.dataset.dtab === tabName));
  document.getElementById('dtab-caselogs').classList.toggle('hidden', tabName !== 'caselogs');
  document.getElementById('dtab-shiftlogs').classList.toggle('hidden', tabName !== 'shiftlogs');
  document.getElementById('dtab-projections').classList.toggle('hidden', tabName !== 'projections');
  document.getElementById('dtab-time').classList.toggle('hidden', tabName !== 'time');
  document.getElementById('dtab-analytics').classList.toggle('hidden', tabName !== 'analytics');
  document.getElementById('dtab-daily').classList.toggle('hidden', tabName !== 'daily');
  updateDashStickyHeaderSpacer();
  if (tabName === 'caselogs') renderCaseLogTable();
  if (tabName === 'shiftlogs') renderShiftLogTable();
  if (tabName === 'projections') renderProjections();
  if (tabName === 'time') renderTimeTab();
  if (tabName === 'analytics') renderAnalyticsTab();
  if (tabName === 'daily') renderDailyTab();
}

function updateDashStickyHeaderSpacer() {
  requestAnimationFrame(() => {
    const h = document.getElementById('dashStickyHeader').offsetHeight;
    document.getElementById('dashStickyHeaderSpacer').style.height = h + 'px';
  });
}

// Generic collapsible toggle
function toggleCollapse(sectionId) {
  const bodyMap = {
    projBreakdown: 'projBreakdownBody', projEfficiency: 'projEfficiencyBody', projCaseEff: 'projCaseEffBody', projMoM: 'projMoMBody', projPtsPerType: 'projPtsPerTypeBody',
    timeDOW: 'timeDOWBody', timeWknd: 'timeWkndBody', timeNight: 'timeNightBody',
    analAddOns: 'analAddOnsBody', analTopProc: 'analTopProcBody', analAvgUnits: 'analAvgUnitsBody',
    analShiftDist: 'analShiftDistBody'
  };
  const arrowMap = {
    projBreakdown: 'projBreakdownArrow', projEfficiency: 'projEfficiencyArrow', projCaseEff: 'projCaseEffArrow', projMoM: 'projMoMArrow', projPtsPerType: 'projPtsPerTypeArrow',
    timeDOW: 'timeDOWArrow', timeWknd: 'timeWkndArrow', timeNight: 'timeNightArrow',
    analAddOns: 'analAddOnsArrow', analTopProc: 'analTopProcArrow', analAvgUnits: 'analAvgUnitsArrow',
    analShiftDist: 'analShiftDistArrow'
  };
  const body = document.getElementById(bodyMap[sectionId]);
  const arrow = document.getElementById(arrowMap[sectionId]);
  if (!body || !arrow) return;
  if (body.style.maxHeight && body.style.maxHeight !== '0px') {
    body.style.maxHeight = '0';
    arrow.classList.remove('open');
  } else {
    body.style.maxHeight = body.scrollHeight + 'px';
    arrow.classList.add('open');
  }
}

// Shared helper: shift clocked-in hours (sum of time entries, not gaps)
function calcShiftHours(shift) {
  if (!shift || shift.assignmentType === 'vacation') return 0;
  const entries = shift.timeEntries || [];
  if (entries.length > 0) {
    let totalMin = 0;
    entries.forEach(e => {
      if (!e.start || !e.end) return;
      let s = timeToMinutes(e.start);
      let en = timeToMinutes(e.end);
      if (en <= s) en += 1440;
      totalMin += (en - s);
    });
    if (totalMin > 0) return totalMin / 60;
  }
  // Fallback for legacy shifts without timeEntries
  if (!shift.endTime) return 0;
  let start = timeToMinutes(shift.startTime);
  let end = timeToMinutes(shift.endTime);
  if (end <= start) end += 1440;
  return (end - start) / 60;
}

// ================================================================
// CASE LOGS TAB
// ================================================================
let clYear = new Date().getFullYear();
let clMonth = new Date().getMonth();

function updateCLMonthLabel() {
  const mn = ['January','February','March','April','May','June','July','August','September','October','November','December'];
  document.getElementById('clMonthLabel').textContent = `${mn[clMonth]} ${clYear}`;
}

document.getElementById('clPrevMonth').addEventListener('click', () => {
  clMonth--; if (clMonth < 0) { clMonth = 11; clYear--; }
  updateCLMonthLabel(); renderCaseLogTable();
});
document.getElementById('clNextMonth').addEventListener('click', () => {
  clMonth++; if (clMonth > 11) { clMonth = 0; clYear++; }
  updateCLMonthLabel(); renderCaseLogTable();
});

document.getElementById('caseLogSearch').addEventListener('input', () => filterCaseLog());

function getCaseAddOnSummary(c) {
  const parts = [];
  if (c.nerveBlock === 'brachial_plexus') parts.push('NB-BP');
  else if (c.nerveBlock === 'other') parts.push('NB');
  if (c.hasCentralLine) parts.push('CL');
  if (c.hasArterialLine) parts.push('AL');
  if (c.hasPAC) parts.push('PAC');
  if (c.hasTEEAddOn) parts.push('TEE');
  if (c.hasITMorphine) parts.push('ITM');
  return parts.join(', ');
}

function renderCaseLogTable() {
  updateCLMonthLabel();
  const prefix = `${clYear}-${String(clMonth+1).padStart(2,'0')}`;
  const monthCases = data.cases.filter(c => c.shiftDate && c.shiftDate.startsWith(prefix))
    .sort((a, b) => (b.shiftDate + (b.startTime || '')).localeCompare(a.shiftDate + (a.startTime || '')));
  const container = document.getElementById('caseLogTableContainer');
  // Hide delete-selected button on re-render
  document.getElementById('clDeleteSelectedBtn').classList.add('hidden');
  if (monthCases.length === 0) {
    container.innerHTML = '<div class="empty-state"><p>No cases for this month.</p></div>';
    return;
  }
  let html = '<table class="case-log-table" id="caseLogTable"><thead><tr>';
  html += '<th><input type="checkbox" class="cl-cb" id="clSelectAll" onclick="clToggleSelectAll(this)"></th>';
  html += '<th>Date</th><th>Case</th><th>Start</th><th>Stop</th><th>Pts</th><th></th><th></th>';
  html += '</tr></thead><tbody>';
  let totalPts = 0;
  monthCases.forEach(c => {
    const shift = data.shifts[c.shiftDate];
    const pts = calcCasePoints(c, shift);
    totalPts += pts;
    const name = c.caseType === 'standard' ? (c.procedure || 'Standard') : getCaseTypeName(c.caseType);
    const sharedMark = c.isSharedCase ? ' [S]' : '';
    const flaggedClass = c.flagged ? ' flagged-row' : '';
    html += `<tr class="${flaggedClass}" data-caseid="${c.id}" onclick="openCaseEdit('${c.id}')">`;
    html += `<td><input type="checkbox" class="cl-cb cl-row-cb" data-caseid="${c.id}" onclick="event.stopPropagation();clUpdateDeleteBtn()"></td>`;
    html += `<td>${formatDateShort(c.shiftDate)}</td>`;
    html += `<td>${escHtml(name)}${sharedMark}</td>`;
    html += `<td>${c.startTime || '-'}</td>`;
    html += `<td>${c.endTime || '-'}</td>`;
    html += `<td><strong>${pts.toFixed(1)}</strong></td>`;
    html += `<td><span class="cl-del" onclick="event.stopPropagation();deleteCase('${c.id}')">&times;</span></td>`;
    html += `<td><button class="flag-btn ${c.flagged ? 'flagged' : ''}" onclick="event.stopPropagation();toggleCaseFlag('${c.id}')">&#9873;</button></td>`;
    html += '</tr>';
  });
  html += '</tbody><tfoot><tr style="border-top:2px solid var(--accent);">';
  html += `<td colspan="7" style="text-align:right;font-weight:600;">Monthly Total (${monthCases.length} cases)</td>`;
  html += `<td><strong>${round2(totalPts).toFixed(1)}</strong></td>`;
  html += '</tr></tfoot></table>';
  container.innerHTML = html;
}

function clToggleSelectAll(masterCb) {
  const cbs = document.querySelectorAll('#caseLogTable .cl-row-cb');
  cbs.forEach(cb => { cb.checked = masterCb.checked; });
  clUpdateDeleteBtn();
}

function clUpdateDeleteBtn() {
  const cbs = document.querySelectorAll('#caseLogTable .cl-row-cb:checked');
  const btn = document.getElementById('clDeleteSelectedBtn');
  const count = cbs.length;
  document.getElementById('clDeleteSelectedCount').textContent = count;
  btn.classList.toggle('hidden', count === 0);
  // Update select-all checkbox state
  const allCbs = document.querySelectorAll('#caseLogTable .cl-row-cb');
  const selectAll = document.getElementById('clSelectAll');
  if (selectAll) {
    selectAll.checked = allCbs.length > 0 && count === allCbs.length;
    selectAll.indeterminate = count > 0 && count < allCbs.length;
  }
}

document.getElementById('clDeleteSelectedBtn').addEventListener('click', () => {
  const cbs = document.querySelectorAll('#caseLogTable .cl-row-cb:checked');
  const ids = Array.from(cbs).map(cb => cb.getAttribute('data-caseid'));
  if (ids.length === 0) return;
  if (!confirm(`Delete ${ids.length} selected case${ids.length > 1 ? 's' : ''}?`)) return;
  const idSet = new Set(ids);
  data.cases = data.cases.filter(c => !idSet.has(c.id));
  saveData(data);
  updateHeaderPoints();
  renderCaseLogTable();
  renderToday();
  renderDECaseList();
  updateDETally();
  showToast(`${ids.length} case${ids.length > 1 ? 's' : ''} deleted`);
});

function filterCaseLog() {
  const query = (document.getElementById('caseLogSearch').value || '').toLowerCase();
  const table = document.getElementById('caseLogTable');
  if (!table) return;
  const rows = table.querySelectorAll('tbody tr');
  rows.forEach(row => {
    const text = row.textContent.toLowerCase();
    row.style.display = text.includes(query) ? '' : 'none';
  });
}

// ================================================================
// SHIFT LOGS TAB
// ================================================================
let slYear = new Date().getFullYear();
let slMonth = new Date().getMonth();

function updateSLMonthLabel() {
  const mn = ['January','February','March','April','May','June','July','August','September','October','November','December'];
  document.getElementById('slMonthLabel').textContent = `${mn[slMonth]} ${slYear}`;
}

document.getElementById('slPrevMonth').addEventListener('click', () => {
  slMonth--; if (slMonth < 0) { slMonth = 11; slYear--; }
  updateSLMonthLabel(); renderShiftLogTable();
});
document.getElementById('slNextMonth').addEventListener('click', () => {
  slMonth++; if (slMonth > 11) { slMonth = 0; slYear++; }
  updateSLMonthLabel(); renderShiftLogTable();
});

document.getElementById('shiftLogSearch').addEventListener('input', () => filterShiftLog());

function getPayCodeName(normalizedMin, assignmentType, isWknd, isHol) {
  const isDaytime = normalizedMin >= 420 && normalizedMin < 1020;
  // OB_restricted always uses restricted OB rate; SF1 only during non-holiday weekday daytime
  const isOB = assignmentType === 'OB_restricted' ||
    (assignmentType === 'SF1' && !isHol && !isWknd && isDaytime);
  const isEvening = normalizedMin >= 1020 && normalizedMin < 1380;
  if (isWknd || isHol) {
    if (isDaytime) return isOB ? 'Restricted OB Weekend Day' : 'Weekend Day';
    return isOB ? 'Restricted OB Weekend Night' : 'Weekend Night';
  }
  if (isDaytime) return isOB ? 'Restricted OB Hours' : 'MD Hourly';
  if (isEvening) return isOB ? 'Restricted OB Evening' : 'Evening Diff';
  return isOB ? 'Restricted OB Night' : 'Night Diff';
}

function getShiftPayBreakdown(shift) {
  if (shift.assignmentType === 'vacation') return [];
  if (shift.forcedOff || shift.assignmentType === 'forced_off') return [{ clockIn: '', clockOut: '', payCode: 'Forced Off', durationMin: 0, payRate: 0, amount: 56 }];
  const isHol = shift.isHoliday;
  const isWknd = isWeekend(shift.date);
  const isWkndOrHol = isHol || isWknd;
  const pagerWindowEarly = getPagerPayWindow(shift.assignmentType, isWkndOrHol);

  // Temp coverage (covering): only coverage-scoped rows
  if (shift.tempCoverage && shift.tempCoverage.length > 0 && shift.tempCoverage[0].type === 'covering') {
    const tc = shift.tempCoverage[0];
    if (!tc.start || !tc.end) return [];
    let tcS = timeToMinutes(tc.start);
    let tcE = timeToMinutes(tc.end);
    if (tcE <= tcS) tcE += 1440;
    const tcDurMin = tcE - tcS;
    const coverageRows = [];
    coverageRows.push({
      clockIn: tc.start, clockOut: tc.end,
      payCode: 'Temp Coverage Pager',
      durationMin: tcDurMin, payRate: 3.5,
      amount: round2((tcDurMin / 60) * 3.5),
      isPager: true, isSubRow: false
    });
    (tc.timeEntries || []).forEach(e => {
      if (!e.start || !e.end) return;
      let es = timeToMinutes(e.start);
      let ee = timeToMinutes(e.end);
      if (ee <= es) ee += 1440;
      const eDurMin = ee - es;
      const normMin = es % 1440;
      const rate = getARRate(shift.assignmentType, isHol, isWknd, normMin);
      coverageRows.push({
        clockIn: e.start, clockOut: e.end,
        payCode: 'Temp Coverage AR',
        durationMin: eDurMin, payRate: rate,
        amount: round2((eDurMin / 60) * rate),
        isSubRow: false
      });
    });
    return coverageRows;
  }

  const entries = shift.timeEntries || [];
  const hasEntries = entries.length > 0 && (entries.length > 1 || entries[0].start);
  const lastEntry = hasEntries ? entries[entries.length - 1] : null;
  const hasEnd = hasEntries && (entries.length > 1 || (lastEntry && lastEntry.end));

  // No time entries: return pager pay row only if eligible
  if (!hasEntries || !hasEnd) {
    if (pagerWindowEarly) {
      const durMin = pagerWindowEarly.end - pagerWindowEarly.start;
      return [{ clockIn: minutesToTimeStr(pagerWindowEarly.start), clockOut: minutesToTimeStr(pagerWindowEarly.end), payCode: 'Pager Pay', durationMin: durMin, payRate: 3.5, amount: round2((durMin / 60) * 3.5), isPager: true, isSubRow: false }];
    }
    return [];
  }
  const isSF = ['SF1','SF2'].includes(shift.assignmentType);

  let orRanges = [];
  if (isSF) {
    const shiftCases = data.cases.filter(c => c.shiftDate === shift.date && c.isORCase);
    shiftCases.forEach(c => {
      let cs = timeToMinutes(c.startTime);
      let ce = timeToMinutes(c.endTime);
      if (ce <= cs) ce += 1440;
      orRanges.push({ start: cs, end: ce });
    });
  }

  const clockedRanges = [];
  entries.forEach(e => {
    if (!e.start) return;
    const s = timeToMinutes(e.start);
    let en = e.end ? timeToMinutes(e.end) : s;
    if (en <= s && e.end) en += 1440;
    clockedRanges.push({ start: s, end: en, startStr: e.start, endStr: e.end || '' });
  });
  // Fix cross-midnight ordering: if an entry starts before the previous entry, it's the next day
  for (let i = 1; i < clockedRanges.length; i++) {
    if (clockedRanges[i].start < clockedRanges[i-1].start) {
      clockedRanges[i].start += 1440;
      clockedRanges[i].end += 1440;
    }
  }

  function pagerOnlyRows() {
    if (pagerWindowEarly) {
      const durMin = pagerWindowEarly.end - pagerWindowEarly.start;
      return [{ clockIn: minutesToTimeStr(pagerWindowEarly.start), clockOut: minutesToTimeStr(pagerWindowEarly.end), payCode: 'Pager Pay', durationMin: durMin, payRate: 3.5, amount: round2((durMin / 60) * 3.5), isPager: true, isSubRow: false }];
    }
    return [];
  }
  if (clockedRanges.length === 0) return pagerOnlyRows();
  const spanStart = clockedRanges[0].start;
  const spanEnd = clockedRanges[clockedRanges.length - 1].end;
  if (spanEnd <= spanStart) return pagerOnlyRows();

  const rows = [];

  // Build pre-call range (OR rates during pre-call period)
  let preCallRange = null;
  if (shift.preCallStart && shift.preCallEnd) {
    let pcs = timeToMinutes(shift.preCallStart);
    let pce = timeToMinutes(shift.preCallEnd);
    if (pce <= pcs) pce += 1440;
    preCallRange = { start: pcs, end: pce };
  }

  // Rate-change boundaries (minute of day)
  function getBoundaries() {
    const b = (isWknd || isHol) ? [420, 1020] : [420, 1020, 1380];
    // Add supervision overlay boundaries so segments split at supervision start/end
    if (shift.supervisionStart && shift.supervisionEnd && shift.assignmentType !== 'CRNA_supervision') {
      const ss = timeToMinutes(shift.supervisionStart);
      const se = timeToMinutes(shift.supervisionEnd);
      if (ss > 0 && !b.includes(ss)) b.push(ss);
      if (se > 0 && !b.includes(se)) b.push(se);
    }
    // Add pre-call boundaries so segments split at pre-call start/end
    if (preCallRange) {
      const pcStart = preCallRange.start % 1440;
      const pcEnd = preCallRange.end % 1440;
      if (!b.includes(pcStart)) b.push(pcStart);
      if (pcEnd > 0 && !b.includes(pcEnd)) b.push(pcEnd);
    }
    return b.sort((a, c) => a - c);
  }
  const bounds = getBoundaries();

  // For each clocked range, segment at rate boundaries
  clockedRanges.forEach((cr, idx) => {
    let segStart = cr.start;
    while (segStart < cr.end) {
      const normStart = segStart % 1440;
      // Find next boundary after normStart
      let nextBound = cr.end;
      for (const b of bounds) {
        // Calculate the actual minute where this boundary hits within the shift span
        const base = segStart - normStart;
        let boundMin = base + b;
        if (boundMin <= segStart) boundMin += 1440;
        if (boundMin < nextBound) nextBound = boundMin;
      }
      const segEnd = Math.min(nextBound, cr.end);
      const normSeg = segStart % 1440;
      let rateType = shift.assignmentType;
      let isPreCallSeg = false;
      if (preCallRange && segStart >= preCallRange.start && segStart < preCallRange.end) {
        rateType = 'OR';
        isPreCallSeg = true;
      } else if (isSF) {
        for (const r of orRanges) {
          if (segStart >= r.start && segStart < r.end) { rateType = 'OR'; break; }
        }
      }
      const payCode = isPreCallSeg ? 'Pre-Call ' + getPayCodeName(normSeg, 'OR', isWknd, isHol) : getPayCodeName(normSeg, rateType, isWknd, isHol);
      let payRate = getARRate(rateType, isHol, isWknd, normSeg);

      // CRNA supervision bonus: +7/hr
      let supBonus = 0;
      if (shift.assignmentType === 'CRNA_supervision') {
        // Standalone CRNA supervision: +7 on all clocked time
        supBonus = 7;
      } else if (shift.supervisionStart && shift.supervisionEnd) {
        // Overlay: +7 only during supervision period
        let supStart = timeToMinutes(shift.supervisionStart);
        let supEnd = timeToMinutes(shift.supervisionEnd);
        if (supEnd <= supStart) supEnd += 1440;
        if (segStart < supEnd && segEnd > supStart) supBonus = 7;
      }
      payRate += supBonus;

      const durMin = segEnd - segStart;
      rows.push({
        clockIn: segStart === cr.start ? cr.startStr : '',
        clockOut: segEnd === cr.end ? cr.endStr : '',
        payCode: supBonus > 0 ? payCode + ' + CRNA' : payCode,
        durationMin: durMin,
        payRate,
        amount: round2((durMin / 60) * payRate),
        entryIdx: idx,
        isSubRow: segStart !== cr.start
      });
      segStart = segEnd;
    }
  });

  // Pager pay: guaranteed full window duration (does not stop when clocked in)
  const pagerWindow = getPagerPayWindow(shift.assignmentType, isWkndOrHol);
  if (pagerWindow) {
    const durMin = pagerWindow.end - pagerWindow.start;
    if (durMin > 0) {
      rows.push({
        clockIn: minutesToTimeStr(pagerWindow.start),
        clockOut: minutesToTimeStr(pagerWindow.end),
        payCode: 'Pager Pay',
        durationMin: durMin,
        payRate: 3.5,
        amount: round2((durMin / 60) * 3.5),
        isPager: true,
        isSubRow: false
      });
    }
  }

  // Temp coverage rows
  if (shift.tempCoverage && shift.tempCoverage.length > 0) {
    shift.tempCoverage.forEach(tc => {
      if (!tc.start || !tc.end) return;
      let tcS = timeToMinutes(tc.start);
      let tcE = timeToMinutes(tc.end);
      if (tcE <= tcS) tcE += 1440;
      const tcDurMin = tcE - tcS;
      if (tc.type === 'covered') {
        rows.push({
          clockIn: tc.start, clockOut: tc.end,
          payCode: 'Temp Coverage (Covered)',
          durationMin: tcDurMin, payRate: -3.5,
          amount: round2((tcDurMin / 60) * -3.5),
          isPager: true, isSubRow: false
        });
      } else if (tc.type === 'covering') {
        rows.push({
          clockIn: tc.start, clockOut: tc.end,
          payCode: 'Temp Coverage Pager',
          durationMin: tcDurMin, payRate: 3.5,
          amount: round2((tcDurMin / 60) * 3.5),
          isPager: true, isSubRow: false
        });
        // AR rows for coverage work time entries
        const tcEntries = tc.timeEntries || [];
        tcEntries.forEach(e => {
          if (!e.start || !e.end) return;
          let es = timeToMinutes(e.start);
          let ee = timeToMinutes(e.end);
          if (ee <= es) ee += 1440;
          const eDurMin = ee - es;
          const normMin = es % 1440;
          const rate = getARRate(shift.assignmentType, isHol, isWknd, normMin);
          rows.push({
            clockIn: e.start, clockOut: e.end,
            payCode: 'Temp Coverage AR',
            durationMin: eDurMin, payRate: rate,
            amount: round2((eDurMin / 60) * rate),
            isSubRow: false
          });
        });
      }
    });
  }

  // Merge consecutive same-payCode segments within the same entry
  const merged = [];
  for (let i = 0; i < rows.length; i++) {
    const r = rows[i];
    if (merged.length > 0) {
      const prev = merged[merged.length - 1];
      if (prev.payCode === r.payCode && prev.entryIdx === r.entryIdx && !r.isPager && !prev.isPager) {
        prev.durationMin += r.durationMin;
        prev.amount = round2(prev.amount + r.amount);
        if (r.clockOut) prev.clockOut = r.clockOut;
        continue;
      }
    }
    merged.push({ ...r });
  }

  // Consolidate all rows with the same payCode + payRate into single totals
  const consolidated = [];
  const seen = {};
  for (const r of merged) {
    const key = r.payCode + '|' + r.payRate;
    if (seen[key] !== undefined) {
      const c = consolidated[seen[key]];
      c.durationMin += r.durationMin;
      c.amount = round2(c.amount + r.amount);
      if (r.clockOut) c.clockOut = r.clockOut;
    } else {
      seen[key] = consolidated.length;
      consolidated.push({ ...r });
    }
  }

  // Guaranteed minimum logic
  if (!isHol && !isWknd) {
    if (preCallRange) {
      // Pre-call split: apply separate minimums to pre-call and evening rows
      const preCallRows = consolidated.filter(r => !r.isPager && r.payCode && r.payCode.startsWith('Pre-Call'));
      const eveningRows = consolidated.filter(r => !r.isPager && r.payCode && !r.payCode.startsWith('Pre-Call'));
      const pagerRows = consolidated.filter(r => r.isPager);

      const preCallTotal = preCallRows.reduce((sum, r) => sum + r.amount, 0);
      const preCallMin = 20 * 4; // OR rate minimum = 80 pts
      let preCallResult = preCallRows;
      if (preCallTotal > 0 && preCallTotal < preCallMin) {
        preCallResult = [{
          clockIn: preCallRows[0]?.clockIn || '', clockOut: preCallRows[preCallRows.length - 1]?.clockOut || '',
          payCode: 'Pre-Call 4-Hour Minimum',
          durationMin: 240, payRate: 20, amount: preCallMin,
          isSubRow: false, isPreCall: true
        }];
      }

      let eveningResult = eveningRows;
      if (shift.assignmentType !== 'mole') {
        const eveningTotal = eveningRows.reduce((sum, r) => sum + r.amount, 0);
        const isOBRate = ['OB_restricted','SF1'].includes(shift.assignmentType);
        const eveningMin = isOBRate ? 13 * 4 : 20 * 4;
        if (eveningTotal > 0 && eveningTotal < eveningMin) {
          eveningResult = [{
            clockIn: eveningRows[0]?.clockIn || '', clockOut: eveningRows[eveningRows.length - 1]?.clockOut || '',
            payCode: getAssignmentTypeName(shift.assignmentType) + ' 4-Hour Minimum',
            durationMin: 240, payRate: isOBRate ? 13 : 20, amount: eveningMin,
            isSubRow: false
          }];
        }
      }

      consolidated.length = 0;
      preCallResult.forEach(r => consolidated.push(r));
      eveningResult.forEach(r => consolidated.push(r));
      pagerRows.forEach(r => consolidated.push(r));
    } else if (shift.assignmentType !== 'mole') {
      // Non-pre-call: single 4hr minimum
      const isOBRate = ['OB_restricted','SF1'].includes(shift.assignmentType);
      const minPoints = isOBRate ? 13 * 4 : 20 * 4;
      const arRows = consolidated.filter(r => !r.isPager);
      const arTotal = arRows.reduce((sum, r) => sum + r.amount, 0);
      if (arTotal > 0 && arTotal < minPoints) {
        const pagerRows = consolidated.filter(r => r.isPager);
        consolidated.length = 0;
        consolidated.push({
          clockIn: arRows[0]?.clockIn || '', clockOut: arRows[arRows.length - 1]?.clockOut || '',
          payCode: '4-Hour Minimum',
          durationMin: 240, payRate: isOBRate ? 13 : 20, amount: minPoints,
          isSubRow: false
        });
        pagerRows.forEach(r => consolidated.push(r));
      }
    }
  }

  return consolidated;
}

function getShiftBadgeClass(type) {
  if (type === 'OR' || type === 'cardiac_liver' || type === 'NORA' || type === 'ACS' || type === 'pre_call') return 'sl-badge-or';
  if (type === 'OB_restricted') return 'sl-badge-ob';
  if (type.includes('call')) return 'sl-badge-call';
  if (type === 'endo') return 'sl-badge-endo';
  if (type === 'SF1' || type === 'SF2') return 'sl-badge-sf';
  if (type === 'vacation' || type === 'forced_off') return 'sl-badge-vac';
  return 'sl-badge-other';
}

function minutesToTimeStr(m) {
  const norm = ((m % 1440) + 1440) % 1440;
  return String(Math.floor(norm / 60)).padStart(2, '0') + ':' + String(norm % 60).padStart(2, '0');
}

function renderShiftLogTable() {
  updateSLMonthLabel();
  const prefix = `${slYear}-${String(slMonth + 1).padStart(2, '0')}`;
  const monthShifts = Object.values(data.shifts)
    .filter(s => s.date && s.date.startsWith(prefix))
    .sort((a, b) => a.date.localeCompare(b.date));

  const container = document.getElementById('shiftLogTableContainer');
  const summaryEl = document.getElementById('shiftLogSummary');
  document.getElementById('slDeleteBar').classList.add('hidden');

  if (monthShifts.length === 0) {
    container.innerHTML = '<div class="empty-state"><p>No shifts for this month.</p></div>';
    summaryEl.innerHTML = '';
    return;
  }

  // Build breakdowns for all shifts
  const allBreakdowns = [];
  monthShifts.forEach(shift => {
    const rows = getShiftPayBreakdown(shift);
    allBreakdowns.push({ shift, rows });
  });

  // Summary card: aggregate by payCode
  const payCodeTotals = {};
  allBreakdowns.forEach(({ rows }) => {
    rows.forEach(r => {
      if (!payCodeTotals[r.payCode]) payCodeTotals[r.payCode] = { hours: 0, amount: 0 };
      payCodeTotals[r.payCode].hours += r.durationMin / 60;
      payCodeTotals[r.payCode].amount += r.amount;
    });
  });

  let totalHours = 0, totalAmount = 0;
  let summaryHtml = '<table class="sl-summary-table"><thead><tr><th>Pay Code</th><th>Hours</th><th>Amount</th></tr></thead><tbody>';
  const sortedCodes = Object.keys(payCodeTotals).sort((a, b) => payCodeTotals[b].amount - payCodeTotals[a].amount);
  sortedCodes.forEach(code => {
    const t = payCodeTotals[code];
    totalHours += t.hours;
    totalAmount += t.amount;
    const cls = code === 'Pager Pay' ? ' class="sl-pager-row"' : '';
    summaryHtml += `<tr${cls}><td>${code}</td><td>${t.hours.toFixed(1)}</td><td>${t.amount.toFixed(1)}</td></tr>`;
  });
  summaryHtml += `<tr><td><strong>Total</strong></td><td><strong>${totalHours.toFixed(1)}</strong></td><td><strong>${totalAmount.toFixed(1)}</strong></td></tr>`;
  summaryHtml += '</tbody></table>';
  summaryEl.innerHTML = summaryHtml;

  // Detail table
  const dayNames = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
  let html = '<table class="shift-log-table" id="shiftLogTable"><thead><tr>';
  html += '<th class="sl-check"><input type="checkbox" id="slSelectAll" onclick="slToggleAll(this)"></th>';
  html += '<th>Date</th><th>Assignment</th><th>Time</th><th>Duration</th><th>Clock In</th><th>Clock Out</th><th>Pay Code</th><th>Hours</th><th>Pay Rate</th><th>Amount</th><th></th><th class="sl-del-cell"></th>';
  html += '</tr></thead><tbody>';

  let grandTotal = 0;
  let shiftIdx = 0;

  allBreakdowns.forEach(({ shift, rows }) => {
    const d = new Date(shift.date + 'T12:00:00');
    const dayName = dayNames[d.getDay()];
    const month = d.getMonth() + 1;
    const day = d.getDate();
    const dateLabel = `${dayName} ${month}/${day}`;
    const typeName = getAssignmentTypeName(shift.assignmentType);
    const badgeClass = getShiftBadgeClass(shift.assignmentType);
    const hasPreCall = shift.preCallStart && shift.preCallEnd;
    const totalHrs = calcShiftHours(shift);
    const entries = shift.timeEntries || [];
    const timeStr = entries.length > 0 && entries[0].start
      ? entries[0].start + (entries[entries.length - 1].end ? ' - ' + entries[entries.length - 1].end : '')
      : '-';
    const shiftTotal = rows.reduce((s, r) => s + r.amount, 0);
    grandTotal += shiftTotal;
    const checkboxCell = `<td class="sl-check"><input type="checkbox" class="sl-shift-cb" data-date="${shift.date}" onclick="event.stopPropagation();slUpdateDeleteBar()"></td>`;
    const deleteCell = `<td class="sl-del-cell"><button class="sl-del-btn" title="Delete shift" onclick="event.stopPropagation();deleteShiftFromLog('${shift.date}')">&times;</button></td>`;

    if (shift.assignmentType === 'vacation') {
      const altClass = shiftIdx % 2 === 1 ? ' sl-alt' : '';
      const fClass = shift.flagged ? ' flagged-row' : '';
      shiftIdx++;
      html += `<tr class="${altClass}${fClass}" data-shiftdate="${shift.date}" onclick="openShiftEdit('${shift.date}')">`;
      html += checkboxCell;
      html += `<td>${dateLabel}</td>`;
      html += `<td><span class="sl-badge ${badgeClass}">${escHtml(typeName)}</span></td>`;
      html += `<td>-</td><td>-</td><td>-</td><td>-</td><td>Vacation</td><td>-</td><td>-</td><td>0.0</td>`;
      html += `<td><button class="flag-btn ${shift.flagged ? 'flagged' : ''}" onclick="event.stopPropagation();toggleShiftFlag('${shift.date}')">&#9873;</button></td>`;
      html += deleteCell;
      html += '</tr>';
      return;
    }

    if (rows.length === 0) {
      const altClass = shiftIdx % 2 === 1 ? ' sl-alt' : '';
      const fClass = shift.flagged ? ' flagged-row' : '';
      shiftIdx++;
      html += `<tr class="${altClass}${fClass}" data-shiftdate="${shift.date}" onclick="openShiftEdit('${shift.date}')">`;
      html += checkboxCell;
      html += `<td>${dateLabel}</td>`;
      html += `<td><span class="sl-badge ${badgeClass}">${escHtml(typeName)}</span></td>`;
      html += `<td>${timeStr}</td><td>${totalHrs.toFixed(1)}h</td>`;
      html += `<td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>0.0</td>`;
      html += `<td><button class="flag-btn ${shift.flagged ? 'flagged' : ''}" onclick="event.stopPropagation();toggleShiftFlag('${shift.date}')">&#9873;</button></td>`;
      html += deleteCell;
      html += '</tr>';
      return;
    }

    // Pre-call shifts: render as two separate visual groups
    if (hasPreCall) {
      const preCallRows = rows.filter(r => r.payCode && r.payCode.startsWith('Pre-Call'));
      const eveningRows = rows.filter(r => !r.payCode || !r.payCode.startsWith('Pre-Call'));
      const pcTimeStr = shift.preCallStart + ' - ' + shift.preCallEnd;
      // Compute pre-call clocked hours
      let pcMinutes = 0;
      const pcEnd = (() => { let e = timeToMinutes(shift.preCallEnd); const s = timeToMinutes(shift.preCallStart); if (e <= s) e += 1440; return e; })();
      const pcStart = timeToMinutes(shift.preCallStart);
      entries.forEach(e => {
        if (!e.start || !e.end) return;
        let s = timeToMinutes(e.start);
        let en = timeToMinutes(e.end);
        if (en <= s) en += 1440;
        // Overlap with pre-call window
        const overlapStart = Math.max(s, pcStart);
        const overlapEnd = Math.min(en, pcEnd);
        if (overlapEnd > overlapStart) pcMinutes += (overlapEnd - overlapStart);
      });
      const pcHrs = pcMinutes / 60;
      const eveningHrs = totalHrs - pcHrs;

      // Pre-Call group
      const pcAlt = shiftIdx % 2 === 1 ? ' sl-alt' : '';
      const pcFClass = shift.flagged ? ' flagged-row' : '';
      shiftIdx++;
      if (preCallRows.length > 0) {
        preCallRows.forEach((r, i) => {
          const rowClass = i > 0 ? `sl-sub-row${pcAlt}` : pcAlt.trim();
          html += `<tr class="${rowClass}${pcFClass}" data-shiftdate="${shift.date}" onclick="openShiftEdit('${shift.date}')">`;
          if (i === 0) {
            html += checkboxCell;
            html += `<td>${dateLabel}</td>`;
            html += `<td><span class="sl-badge sl-badge-or">Pre-Call</span></td>`;
            html += `<td>${pcTimeStr}</td>`;
            html += `<td>${pcHrs.toFixed(1)}h</td>`;
          } else {
            html += '<td data-blank></td><td data-blank></td><td data-blank></td><td data-blank></td><td data-blank></td>';
          }
          html += `<td>${r.clockIn || ''}</td><td>${r.clockOut || ''}</td>`;
          html += `<td>${r.payCode}</td><td>${(r.durationMin / 60).toFixed(1)}</td>`;
          html += `<td>${r.payRate.toFixed(1)}/hr</td><td><strong>${r.amount.toFixed(1)}</strong></td>`;
          html += i === 0 ? `<td><button class="flag-btn ${shift.flagged ? 'flagged' : ''}" onclick="event.stopPropagation();toggleShiftFlag('${shift.date}')">&#9873;</button></td>` : '<td></td>';
          html += i === 0 ? deleteCell : '<td></td>';
          html += '</tr>';
        });
      } else {
        html += `<tr class="${pcAlt}${pcFClass}" data-shiftdate="${shift.date}" onclick="openShiftEdit('${shift.date}')">`;
        html += checkboxCell;
        html += `<td>${dateLabel}</td>`;
        html += `<td><span class="sl-badge sl-badge-or">Pre-Call</span></td>`;
        html += `<td>${pcTimeStr}</td><td>${pcHrs.toFixed(1)}h</td>`;
        html += `<td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>0.0</td>`;
        html += `<td><button class="flag-btn ${shift.flagged ? 'flagged' : ''}" onclick="event.stopPropagation();toggleShiftFlag('${shift.date}')">&#9873;</button></td>`;
        html += deleteCell;
        html += '</tr>';
      }

      // Evening group
      const evAlt = shiftIdx % 2 === 1 ? ' sl-alt' : '';
      shiftIdx++;
      if (eveningRows.length > 0) {
        eveningRows.forEach((r, i) => {
          const rowClass = i > 0 ? `sl-sub-row${evAlt}` : evAlt.trim();
          html += `<tr class="${rowClass}${pcFClass}" data-shiftdate="${shift.date}" onclick="openShiftEdit('${shift.date}')">`;
          if (i === 0) {
            html += '<td data-blank></td>';
            html += `<td>${dateLabel}</td>`;
            html += `<td><span class="sl-badge ${badgeClass}">${escHtml(typeName)}</span></td>`;
            html += `<td>${timeStr}</td>`;
            html += `<td>${eveningHrs.toFixed(1)}h</td>`;
          } else {
            html += '<td data-blank></td><td data-blank></td><td data-blank></td><td data-blank></td><td data-blank></td>';
          }
          html += `<td>${r.clockIn || ''}</td><td>${r.clockOut || ''}</td>`;
          html += `<td>${r.payCode}</td><td>${(r.durationMin / 60).toFixed(1)}</td>`;
          html += `<td>${r.payRate.toFixed(1)}/hr</td><td><strong>${r.amount.toFixed(1)}</strong></td>`;
          html += '<td></td>';
          html += '<td></td>';
          html += '</tr>';
        });
      } else {
        html += `<tr class="${evAlt}${pcFClass}" data-shiftdate="${shift.date}" onclick="openShiftEdit('${shift.date}')">`;
        html += '<td data-blank></td>';
        html += `<td>${dateLabel}</td>`;
        html += `<td><span class="sl-badge ${badgeClass}">${escHtml(typeName)}</span></td>`;
        html += `<td>${timeStr}</td><td>${eveningHrs.toFixed(1)}h</td>`;
        html += `<td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>0.0</td>`;
        html += '<td></td>';
        html += '<td></td>';
        html += '</tr>';
      }
      return;
    }

    // Non-pre-call shifts: single group
    const altClass = shiftIdx % 2 === 1 ? ' sl-alt' : '';
    const fClass = shift.flagged ? ' flagged-row' : '';
    shiftIdx++;
    rows.forEach((r, i) => {
      const rowClass = i > 0 ? `sl-sub-row${altClass}` : altClass.trim();
      html += `<tr class="${rowClass}${fClass}" data-shiftdate="${shift.date}" onclick="openShiftEdit('${shift.date}')">`;
      if (i === 0) {
        html += checkboxCell;
        html += `<td>${dateLabel}</td>`;
        html += `<td><span class="sl-badge ${badgeClass}">${escHtml(typeName)}</span></td>`;
        html += `<td>${timeStr}</td>`;
        html += `<td>${totalHrs.toFixed(1)}h</td>`;
      } else {
        html += '<td data-blank></td><td data-blank></td><td data-blank></td><td data-blank></td><td data-blank></td>';
      }
      html += `<td>${r.clockIn || ''}</td>`;
      html += `<td>${r.clockOut || ''}</td>`;
      html += `<td>${r.payCode}</td>`;
      html += `<td>${(r.durationMin / 60).toFixed(1)}</td>`;
      html += `<td>${r.payRate.toFixed(1)}/hr</td>`;
      html += `<td><strong>${r.amount.toFixed(1)}</strong></td>`;
      html += i === 0 ? `<td><button class="flag-btn ${shift.flagged ? 'flagged' : ''}" onclick="event.stopPropagation();toggleShiftFlag('${shift.date}')">&#9873;</button></td>` : '<td></td>';
      html += i === 0 ? deleteCell : '<td></td>';
      html += '</tr>';
    });
  });

  html += `<tr style="border-top:2px solid var(--border);"><td colspan="12" style="text-align:right;font-weight:700;">Monthly Total</td><td><strong>${grandTotal.toFixed(1)}</strong></td></tr>`;
  html += '</tbody></table>';
  container.innerHTML = html;
}

function slToggleAll(masterCb) {
  const cbs = document.querySelectorAll('.sl-shift-cb');
  cbs.forEach(cb => { cb.checked = masterCb.checked; });
  slUpdateDeleteBar();
}

function slUpdateDeleteBar() {
  const cbs = document.querySelectorAll('.sl-shift-cb:checked');
  const bar = document.getElementById('slDeleteBar');
  const countEl = document.getElementById('slDeleteCount');
  if (cbs.length > 0) {
    bar.classList.remove('hidden');
    countEl.textContent = cbs.length + ' selected';
  } else {
    bar.classList.add('hidden');
  }
  // Sync select-all checkbox
  const allCbs = document.querySelectorAll('.sl-shift-cb');
  const selectAll = document.getElementById('slSelectAll');
  if (selectAll) {
    selectAll.checked = allCbs.length > 0 && cbs.length === allCbs.length;
  }
}

function deleteShiftFromLog(dateStr) {
  if (!confirm('Delete this shift and its associated cases? This cannot be undone.')) return;
  delete data.shifts[dateStr];
  data.cases = data.cases.filter(c => c.shiftDate !== dateStr);
  saveData(data);
  updateHeaderPoints();
  renderShiftLogTable();
  renderToday();
  renderDailyTab();
  showToast('Shift deleted');
}

function deleteSelectedShifts() {
  const cbs = document.querySelectorAll('.sl-shift-cb:checked');
  if (cbs.length === 0) return;
  const dates = Array.from(cbs).map(cb => cb.dataset.date);
  const unique = [...new Set(dates)];
  if (!confirm(`Delete ${unique.length} shift${unique.length > 1 ? 's' : ''} and their associated cases? This cannot be undone.`)) return;
  unique.forEach(dateStr => {
    delete data.shifts[dateStr];
    data.cases = data.cases.filter(c => c.shiftDate !== dateStr);
  });
  saveData(data);
  updateHeaderPoints();
  renderShiftLogTable();
  renderToday();
  renderDailyTab();
  showToast(`${unique.length} shift${unique.length > 1 ? 's' : ''} deleted`);
}

function filterShiftLog() {
  const query = (document.getElementById('shiftLogSearch').value || '').toLowerCase();
  const table = document.getElementById('shiftLogTable');
  if (!table) return;
  const rows = table.querySelectorAll('tbody tr');
  rows.forEach(row => {
    const text = row.textContent.toLowerCase();
    row.style.display = text.includes(query) ? '' : 'none';
  });
}

function toggleCaseFlag(caseId) {
  const c = data.cases.find(x => x.id === caseId);
  if (c) { c.flagged = !c.flagged; saveData(); renderCaseLogTable(); }
}
function toggleShiftFlag(dateStr) {
  const s = data.shifts[dateStr];
  if (s) { s.flagged = !s.flagged; saveData(); renderShiftLogTable(); }
}

function renderFlaggedEmail() {
  const flaggedShifts = Object.values(data.shifts).filter(s => s.flagged).sort((a,b) => a.date.localeCompare(b.date));
  const flaggedCases = data.cases.filter(c => c.flagged).sort((a,b) => (a.shiftDate||'').localeCompare(b.shiftDate||''));
  const total = flaggedShifts.length + flaggedCases.length;
  document.getElementById('flaggedCount').textContent = `(${total})`;
  const preview = document.getElementById('flaggedEmailPreview');
  if (total === 0) {
    preview.innerHTML = '<p style="color:var(--text-dim);font-size:0.85rem;">No flagged items.</p>';
    preview.dataset.emailText = '';
    return;
  }
  const userName = data.settings?.name || 'Provider';
  let emailText = `Subject: Missing Time Punches — ${userName}\n\nHi,\n\nThe following items are missing time punches on the compensation sheet:\n\n`;
  let idx = 1;
  flaggedShifts.forEach(s => {
    const d = new Date(s.date + 'T12:00:00');
    const dateStr = `${d.getMonth()+1}/${d.getDate()}/${d.getFullYear()}`;
    const typeName = getAssignmentTypeName(s.assignmentType);
    const entries = s.timeEntries || [];
    const times = entries.length > 0 && entries[0].start
      ? entries[0].start + (entries[entries.length-1].end ? ' \u2013 ' + entries[entries.length-1].end : '')
      : 'no times recorded';
    emailText += `${idx}. ${dateStr} \u2014 ${typeName} (${times})\n`;
    idx++;
  });
  flaggedCases.forEach(c => {
    const d = new Date(c.shiftDate + 'T12:00:00');
    const dateStr = `${d.getMonth()+1}/${d.getDate()}/${d.getFullYear()}`;
    const name = c.caseType === 'standard' ? (c.procedure || 'Standard') : getCaseTypeName(c.caseType);
    const times = (c.startTime || '?') + ' \u2013 ' + (c.endTime || '?');
    emailText += `${idx}. ${dateStr} \u2014 Case: ${name} (${times})\n`;
    idx++;
  });
  emailText += `\nPlease update accordingly.\n\nThanks,\n${userName}`;
  preview.innerHTML = `<div class="email-preview">${escHtml(emailText)}</div>`;
  preview.dataset.emailText = emailText;
}

// ================================================================
// SHIFT EDIT MODAL
// ================================================================
let editingShiftDate = null;

function openShiftEdit(dateStr) {
  const shift = data.shifts[dateStr];
  if (!shift) return;

  // Navigate to Data Entry page for this date in edit mode
  setWorkingDate(dateStr);
  deShiftEditing = true;
  returnToShiftLogs = true;
  document.querySelectorAll('.bottom-nav button').forEach(b => b.classList.remove('active'));
  document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
  const deBtn = document.querySelector('.bottom-nav button[data-page="dataentry"]');
  deBtn.classList.add('active');
  document.getElementById('page-dataentry').classList.add('active');
  loadDataEntryPage();
}

function navigateToShiftLogs() {
  returnToShiftLogs = false;
  document.querySelectorAll('.bottom-nav button').forEach(b => b.classList.remove('active'));
  document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
  const dashBtn = document.querySelector('.bottom-nav button[data-page="dashboard"]');
  dashBtn.classList.add('active');
  document.getElementById('page-dashboard').classList.add('active');
  document.querySelectorAll('.dash-tab').forEach(t => t.classList.remove('active'));
  const slTab = document.getElementById('dashShiftLogsTab');
  if (slTab) { slTab.classList.add('active'); slTab.click(); }
}

function renderEditShiftTimeEntries(entries) {
  const container = document.getElementById('editShiftTimeEntries');
  if (!entries || entries.length === 0) entries = [{ start: '', end: '' }];
  let html = '';
  entries.forEach((e, i) => {
    html += `<div class="form-row" style="align-items:end;gap:8px;margin-top:8px;">
      <div class="form-group" style="flex:1;">
        <label>Start${entries.length > 1 ? ' #' + (i + 1) : ''}</label>
        <input type="text" inputmode="numeric" placeholder="HH:MM" maxlength="5" class="mil-time edit-shift-start" value="${e.start || ''}">
      </div>
      <div class="form-group" style="flex:1;">
        <label>End${entries.length > 1 ? ' #' + (i + 1) : ''}</label>
        <input type="text" inputmode="numeric" placeholder="HH:MM" maxlength="5" class="mil-time edit-shift-end" value="${e.end || ''}">
      </div>
      ${entries.length > 1 ? `<button class="btn btn-danger btn-sm" onclick="removeEditShiftEntry(${i})" style="margin-bottom:4px;padding:4px 8px;">x</button>` : ''}
    </div>`;
  });
  container.innerHTML = html;
  container.querySelectorAll('.mil-time').forEach(inp => bindMilTimeInput(inp));
}

function getEditShiftEntries() {
  const starts = document.querySelectorAll('#editShiftTimeEntries .edit-shift-start');
  const ends = document.querySelectorAll('#editShiftTimeEntries .edit-shift-end');
  const entries = [];
  starts.forEach((s, i) => {
    entries.push({ start: s.value.trim(), end: (ends[i] ? ends[i].value.trim() : '') });
  });
  return entries;
}

function removeEditShiftEntry(idx) {
  const entries = getEditShiftEntries();
  entries.splice(idx, 1);
  renderEditShiftTimeEntries(entries);
}

document.getElementById('editShiftAddEntry').addEventListener('click', () => {
  const entries = getEditShiftEntries();
  entries.push({ start: '', end: '' });
  renderEditShiftTimeEntries(entries);
});

document.getElementById('saveShiftEdit').addEventListener('click', () => {
  if (!editingShiftDate) return;
  const shift = data.shifts[editingShiftDate];
  if (!shift) return;
  shift.assignmentType = document.getElementById('editShiftType').value;
  shift.isHoliday = document.getElementById('editShiftHoliday').checked;
  shift.timeEntries = getEditShiftEntries();
  // Also sync legacy startTime/endTime
  if (shift.timeEntries.length > 0) {
    shift.startTime = shift.timeEntries[0].start;
    shift.endTime = shift.timeEntries[shift.timeEntries.length - 1].end;
  }
  saveData(data);
  document.getElementById('shiftEditModal').classList.add('hidden');
  editingShiftDate = null;
  updateHeaderPoints();
  renderShiftLogTable();
  renderToday();
  renderDailyTab();
  showToast('Shift updated');
});

document.getElementById('deleteShiftBtn').addEventListener('click', () => {
  if (!editingShiftDate) return;
  if (!confirm('Delete this shift? This cannot be undone.')) return;
  delete data.shifts[editingShiftDate];
  saveData(data);
  document.getElementById('shiftEditModal').classList.add('hidden');
  editingShiftDate = null;
  updateHeaderPoints();
  renderShiftLogTable();
  renderToday();
  renderDailyTab();
  showToast('Shift deleted');
});

document.getElementById('cancelShiftEdit').addEventListener('click', () => {
  document.getElementById('shiftEditModal').classList.add('hidden');
  editingShiftDate = null;
});

// ================================================================
// MONTHLY OVERRIDE
// ================================================================
let ovYear = new Date().getFullYear();
let ovMonth = new Date().getMonth();

function updateOVMonthLabel() {
  const mn = ['January','February','March','April','May','June','July','August','September','October','November','December'];
  document.getElementById('ovMonthLabel').textContent = `${mn[ovMonth]} ${ovYear}`;
}

function getOVKey() {
  return ovYear + '-' + String(ovMonth + 1).padStart(2, '0');
}

function loadOverrideUI() {
  updateOVMonthLabel();
  const mk = getOVKey();
  if (!data.overrides) data.overrides = {};
  const ov = data.overrides[mk];

  // Calculate current values to show as placeholders
  const monthShifts = Object.values(data.shifts).filter(s => s.date && s.date.startsWith(mk));
  let calcTime = 0, calcProd = 0;
  monthShifts.forEach(shift => {
    const t = calcShiftTotal(shift);
    calcTime += t.ar + t.call + t.subspec + t.supervision;
    calcProd += t.prod;
  });

  const timeInput = document.getElementById('overrideTimePoints');
  const prodInput = document.getElementById('overrideProdPoints');
  timeInput.placeholder = `Calculated: ${calcTime.toFixed(1)}`;
  prodInput.placeholder = `Calculated: ${calcProd.toFixed(1)}`;
  timeInput.value = ov && ov.timePoints != null ? ov.timePoints : '';
  prodInput.value = ov && ov.prodPoints != null ? ov.prodPoints : '';

  const status = document.getElementById('overrideStatus');
  if (ov && (ov.timePoints != null || ov.prodPoints != null)) {
    status.innerHTML = '<span style="color:var(--accent2);font-weight:600;">Override active for this month</span>';
  } else {
    status.textContent = '';
  }
}

document.getElementById('ovPrevMonth').addEventListener('click', () => {
  ovMonth--; if (ovMonth < 0) { ovMonth = 11; ovYear--; }
  loadOverrideUI();
});
document.getElementById('ovNextMonth').addEventListener('click', () => {
  ovMonth++; if (ovMonth > 11) { ovMonth = 0; ovYear++; }
  loadOverrideUI();
});

document.getElementById('saveOverrideBtn').addEventListener('click', () => {
  if (!data.overrides) data.overrides = {};
  const mk = getOVKey();
  const timeVal = document.getElementById('overrideTimePoints').value;
  const prodVal = document.getElementById('overrideProdPoints').value;
  const ov = {};
  if (timeVal !== '') ov.timePoints = parseFloat(timeVal);
  if (prodVal !== '') ov.prodPoints = parseFloat(prodVal);
  if (Object.keys(ov).length > 0) {
    data.overrides[mk] = ov;
  } else {
    delete data.overrides[mk];
  }
  saveData(data);
  loadOverrideUI();
  showToast('Override saved');
});

document.getElementById('clearOverrideBtn').addEventListener('click', () => {
  if (!data.overrides) data.overrides = {};
  const mk = getOVKey();
  delete data.overrides[mk];
  saveData(data);
  loadOverrideUI();
  showToast('Override cleared');
});

// ================================================================
// MONTHLY STIPENDS
// ================================================================
let stipMonth = new Date().getMonth();
let stipYear = new Date().getFullYear();

function getStipKey() {
  return stipYear + '-' + String(stipMonth + 1).padStart(2, '0');
}

function updateStipMonthLabel() {
  const monthNames = ['January','February','March','April','May','June','July','August','September','October','November','December'];
  document.getElementById('stipMonthLabel').textContent = monthNames[stipMonth] + ' ' + stipYear;
}

function loadStipendUI() {
  updateStipMonthLabel();
  if (!data.stipends) data.stipends = {};
  const mk = getStipKey();
  const entries = data.stipends[mk] || [];
  const container = document.getElementById('stipendEntries');
  container.innerHTML = '';
  if (entries.length === 0) {
    addStipendRow(container, '', '');
  } else {
    entries.forEach(e => addStipendRow(container, e.label, e.amount));
  }
  updateStipendStatus();
}

function addStipendRow(container, label, amount) {
  const row = document.createElement('div');
  row.style.cssText = 'display:flex;gap:8px;margin-bottom:8px;align-items:center;';
  row.innerHTML = `<input type="text" placeholder="Label (e.g., Med Director)" value="${label}" style="flex:2;padding:8px;border-radius:6px;border:1px solid var(--border);background:var(--surface);color:var(--text);" class="stip-label">
    <input type="number" placeholder="$ Amount" value="${amount}" min="0" step="0.01" style="flex:1;padding:8px;border-radius:6px;border:1px solid var(--border);background:var(--surface);color:var(--text);" class="stip-amount">
    <button type="button" style="background:none;border:none;color:var(--danger);font-size:1.2rem;cursor:pointer;padding:4px 8px;" class="stip-remove">&times;</button>`;
  row.querySelector('.stip-remove').addEventListener('click', () => {
    row.remove();
    if (container.children.length === 0) addStipendRow(container, '', '');
  });
  container.appendChild(row);
}

function updateStipendStatus() {
  const mk = getStipKey();
  const entries = (data.stipends || {})[mk] || [];
  const total = entries.reduce((s, e) => s + (e.amount || 0), 0);
  const status = document.getElementById('stipendStatus');
  if (total > 0) {
    status.innerHTML = `<span style="color:var(--accent2);font-weight:600;">$${total.toLocaleString('en-US', {minimumFractionDigits:2})} in stipends this month</span>`;
  } else {
    status.textContent = '';
  }
}

function getMonthlyStipendTotal(monthKey) {
  if (!data.stipends) return 0;
  const entries = data.stipends[monthKey] || [];
  return entries.reduce((s, e) => s + (e.amount || 0), 0);
}

document.getElementById('stipPrevMonth').addEventListener('click', () => {
  stipMonth--; if (stipMonth < 0) { stipMonth = 11; stipYear--; }
  loadStipendUI();
});
document.getElementById('stipNextMonth').addEventListener('click', () => {
  stipMonth++; if (stipMonth > 11) { stipMonth = 0; stipYear++; }
  loadStipendUI();
});

document.getElementById('addStipendBtn').addEventListener('click', () => {
  addStipendRow(document.getElementById('stipendEntries'), '', '');
});

document.getElementById('saveStipendBtn').addEventListener('click', () => {
  if (!data.stipends) data.stipends = {};
  const mk = getStipKey();
  const rows = document.getElementById('stipendEntries').children;
  const entries = [];
  for (const row of rows) {
    const label = row.querySelector('.stip-label').value.trim();
    const amount = parseFloat(row.querySelector('.stip-amount').value) || 0;
    if (label || amount > 0) entries.push({ label, amount });
  }
  if (entries.length > 0) {
    data.stipends[mk] = entries;
  } else {
    delete data.stipends[mk];
  }
  saveData(data);
  updateStipendStatus();
  showToast('Stipends saved');
});

document.getElementById('clearStipendBtn').addEventListener('click', () => {
  if (!data.stipends) data.stipends = {};
  const mk = getStipKey();
  delete data.stipends[mk];
  saveData(data);
  loadStipendUI();
  showToast('Stipends cleared');
});

// ================================================================
// PROJECTIONS TAB
// ================================================================
function renderProjections() {
  renderMonthlyChart();
  renderBreakdownChart();
  renderStabilization();
  renderProjectedAnnual();
  renderMonthlyPace();
  renderPipelineChart();
  renderPtsPerShiftType();
  renderShiftEfficiency();
  renderCaseTypeEfficiency();
  renderMoMChange();
}

function getMonthlyTotals() {
  const months = {};
  // First compute from shift data
  const monthBreakdowns = {};
  Object.values(data.shifts).forEach(shift => {
    const mk = shift.date.substring(0, 7);
    if (!monthBreakdowns[mk]) monthBreakdowns[mk] = { time: 0, prod: 0 };
    const t = calcShiftTotal(shift);
    monthBreakdowns[mk].time += t.ar + t.call + t.subspec + t.supervision;
    monthBreakdowns[mk].prod += t.prod;
  });
  // Apply overrides where present
  const overrides = (data.overrides || {});
  Object.keys(monthBreakdowns).forEach(mk => {
    const ov = overrides[mk];
    let time = monthBreakdowns[mk].time;
    let prod = monthBreakdowns[mk].prod;
    if (ov) {
      if (ov.timePoints != null) time = ov.timePoints;
      if (ov.prodPoints != null) prod = ov.prodPoints;
    }
    months[mk] = round2(time + prod);
  });
  // Also include override-only months (where no shifts exist but override was set)
  Object.keys(overrides).forEach(mk => {
    if (!months[mk]) {
      const ov = overrides[mk];
      months[mk] = round2((ov.timePoints || 0) + (ov.prodPoints || 0));
    }
  });
  return months;
}

function renderMonthlyChart() {
  const totals = getMonthlyTotals();
  const sortedKeys = Object.keys(totals).sort();
  const last6 = sortedKeys.slice(-6);
  const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
  const labels = last6.map(k => { const [y,m] = k.split('-'); return monthNames[parseInt(m)-1] + ' ' + y; });
  const values = last6.map(k => round2(totals[k]));
  const avg = values.length > 0 ? round2(values.reduce((a, b) => a + b, 0) / values.length) : 0;
  const ctx = document.getElementById('monthlyChart').getContext('2d');
  if (monthlyChart) monthlyChart.destroy();
  const datasets = [
    { label: 'Total Points', data: values, backgroundColor: 'rgba(59,130,246,0.7)', borderColor: '#3b82f6', borderWidth: 1, borderRadius: 4 }
  ];
  if (values.length > 1) {
    datasets.push({
      label: 'Average', data: values.map(() => avg), type: 'line',
      borderColor: '#f59e0b', borderWidth: 2, borderDash: [6, 3],
      pointRadius: 0, fill: false
    });
  }
  monthlyChart = new Chart(ctx, {
    type: 'bar',
    data: { labels, datasets },
    options: {
      responsive: true, maintainAspectRatio: false,
      plugins: { legend: { display: values.length > 1, labels: { color: '#94a3b8' } } },
      scales: {
        y: { beginAtZero: true, ticks: { color: '#94a3b8' }, grid: { color: 'rgba(71,85,105,0.3)' } },
        x: { ticks: { color: '#94a3b8' }, grid: { display: false } }
      }
    }
  });
  // Summary text below chart
  const summaryEl = document.getElementById('monthlyChartSummary');
  let summaryText = values.length > 0 ? `6-Month Avg: ${avg.toFixed(1)} pts` : '';
  const pv = settings.pointValue;
  if (pv && pv > 0 && avg > 0) {
    const projected = avg * pv;
    summaryText += ` &nbsp;|&nbsp; Projected Monthly: $${projected.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
  }
  summaryEl.innerHTML = summaryText;
}

function renderBreakdownChart() {
  const now = new Date();
  const prefix = now.getFullYear() + '-' + String(now.getMonth()+1).padStart(2,'0');
  const monthShifts = Object.values(data.shifts).filter(s => s.date.startsWith(prefix));
  let obProd = 0, orProd = 0, totalAR = 0, totalCall = 0, totalSupervision = 0;
  monthShifts.forEach(shift => {
    const t = calcShiftTotal(shift);
    totalAR += t.ar;
    totalCall += t.call + t.subspec;
    totalSupervision += t.supervision;
    // Split prod by OB vs OR shift type
    if (['OB_restricted','SF1','SF2'].includes(shift.assignmentType)) obProd += t.prod;
    else orProd += t.prod;
  });
  const ctx = document.getElementById('breakdownChart').getContext('2d');
  if (breakdownChart) breakdownChart.destroy();
  breakdownChart = new Chart(ctx, {
    type: 'doughnut',
    data: {
      labels: ['OB','OR','Supervision','Availability','Call'],
      datasets: [{ data: [round2(obProd), round2(orProd), round2(totalSupervision), round2(totalAR), round2(totalCall)], backgroundColor: ['#ec4899','#10b981','#8b5cf6','#3b82f6','#f59e0b'], borderWidth: 0 }]
    },
    options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { position: 'bottom', labels: { color: '#94a3b8', padding: 16 } } } }
  });
}

function renderStabilization() {
  const now = new Date();
  const mt = getMonthlyTotals();
  function mk(offset) { const d = new Date(now.getFullYear(), now.getMonth() - offset, 1); return d.getFullYear() + '-' + String(d.getMonth()+1).padStart(2,'0'); }
  const raw = mt[mk(0)] || 0;
  const weighted = round2(0.10 * raw + 0.40 * (mt[mk(1)]||0) + 0.25 * (mt[mk(2)]||0) + 0.15 * (mt[mk(3)]||0) + 0.10 * (mt[mk(4)]||0));
  document.getElementById('stabRaw').textContent = raw.toFixed(1);
  document.getElementById('stabWeighted').textContent = weighted.toFixed(1);
  const pv = settings.pointValue;
  const decAdv = settings.decemberAdvance !== false;
  const paycheckLabel = document.getElementById('stabPaycheckLabel');

  if (decAdv && now.getMonth() === 0) {
    // January: paycheck was already received in December
    document.getElementById('stabPaycheck').textContent = '$0.00';
    paycheckLabel.textContent = 'January paycheck received in December';
  } else if (pv && pv > 0) {
    const currentStipend = getMonthlyStipendTotal(mk(0));
    let paycheck = weighted * pv + currentStipend;

    if (decAdv && now.getMonth() === 11) {
      // December: add January's advance paycheck
      function mkFwd(month) { const d = new Date(now.getFullYear() + 1, month, 1); return d.getFullYear() + '-' + String(d.getMonth()+1).padStart(2,'0'); }
      const janWeighted = round2(0.10 * (mt[mkFwd(0)]||0) + 0.40 * raw + 0.25 * (mt[mk(1)]||0) + 0.15 * (mt[mk(2)]||0) + 0.10 * (mt[mk(3)]||0));
      const decStipend = getMonthlyStipendTotal(mk(0)); // Dec stipend → Jan paycheck
      paycheck += janWeighted * pv + decStipend;
      paycheckLabel.textContent = "Projected Dec paycheck + Jan advance";
    } else {
      paycheckLabel.textContent = "Projected next month\u2019s paycheck";
    }

    document.getElementById('stabPaycheck').textContent = '$' + paycheck.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
  } else {
    document.getElementById('stabPaycheck').innerHTML = '&mdash;';
    paycheckLabel.textContent = "Projected next month\u2019s paycheck";
  }
}

// ================================================================
// PROJECTED ANNUAL, SHIFT EFFICIENCY, MOM CHANGE
// ================================================================
function renderProjectedAnnual() {
  const mt = getMonthlyTotals();
  const now = new Date();
  const thisYear = now.getFullYear();
  function mk(offset) { const d = new Date(now.getFullYear(), now.getMonth() - offset, 1); return d.getFullYear() + '-' + String(d.getMonth()+1).padStart(2,'0'); }
  const last3 = [mt[mk(0)]||0, mt[mk(1)]||0, mt[mk(2)]||0].filter(v => v > 0);
  const avg = last3.length > 0 ? last3.reduce((a,b)=>a+b,0) / last3.length : 0;
  document.getElementById('projRollingAvg').textContent = avg.toFixed(1);
  const pv = settings.pointValue;

  // YTD points + stipends: sum all months in current year
  let ytdPts = 0;
  let ytdMonths = 0;
  let ytdStipends = 0;
  for (let m = 0; m <= now.getMonth(); m++) {
    const key = thisYear + '-' + String(m + 1).padStart(2, '0');
    if (mt[key]) { ytdPts += mt[key]; ytdMonths++; }
    ytdStipends += getMonthlyStipendTotal(key);
  }
  const remainingMonths = 12 - now.getMonth() - 1; // full months left after current

  // Average monthly stipend for projection
  const stipMonths = [];
  for (let i = 0; i < 3; i++) {
    const key = mk(i);
    const s = getMonthlyStipendTotal(key);
    if (s > 0) stipMonths.push(s);
  }
  const avgStipend = stipMonths.length > 0 ? stipMonths.reduce((a,b)=>a+b,0) / stipMonths.length : 0;

  if (pv && pv > 0 && avg > 0) {
    const annualPts = avg * 12 * pv;
    const annualStipend = avgStipend * 12;
    const annual = annualPts + annualStipend;
    const ytdRevenue = ytdPts * pv + ytdStipends;
    const projRemaining = avg * remainingMonths * pv + avgStipend * remainingMonths;
    document.getElementById('projAnnualIncome').textContent = '$' + annual.toLocaleString('en-US', { maximumFractionDigits: 0 });
    document.getElementById('projYTDRevenue').textContent = '$' + ytdRevenue.toLocaleString('en-US', { maximumFractionDigits: 0 });
    document.getElementById('projRemaining').textContent = '$' + projRemaining.toLocaleString('en-US', { maximumFractionDigits: 0 });
    let detail = `${ytdPts.toFixed(0)} pts earned YTD across ${ytdMonths} month${ytdMonths !== 1 ? 's' : ''} \u2022 ${remainingMonths} month${remainingMonths !== 1 ? 's' : ''} remaining`;
    if (ytdStipends > 0) detail += ` \u2022 $${ytdStipends.toLocaleString('en-US', {maximumFractionDigits:0})} stipends YTD`;
    document.getElementById('projYTDDetail').textContent = detail;
  } else {
    document.getElementById('projAnnualIncome').innerHTML = '&mdash;';
    document.getElementById('projYTDRevenue').innerHTML = '&mdash;';
    document.getElementById('projRemaining').innerHTML = '&mdash;';
    document.getElementById('projYTDDetail').textContent = pv ? '' : 'Set $/point above to see revenue projections';
  }
}

function renderMonthlyPace() {
  const now = new Date();
  const thisPrefix = now.getFullYear() + '-' + String(now.getMonth() + 1).padStart(2, '0');
  const dayOfMonth = now.getDate();
  const daysInMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0).getDate();

  // Current month's shifts
  const monthShifts = Object.values(data.shifts).filter(s => s.date.startsWith(thisPrefix));
  let currentPts = 0;
  monthShifts.forEach(s => { currentPts += calcShiftTotal(s).total; });
  currentPts = round2(currentPts);

  // Count vacation days this month
  const vacationDays = monthShifts.filter(s => s.assignmentType === 'vacation');
  const totalVacDays = vacationDays.length;
  const vacDaysPassed = vacationDays.filter(s => parseInt(s.date.split('-')[2]) <= dayOfMonth).length;
  const workingDaysInMonth = daysInMonth - totalVacDays;
  const workingDaysElapsed = dayOfMonth - vacDaysPassed;
  const vacationRatio = workingDaysInMonth / daysInMonth; // fraction of month that's working

  // Build cumulative-by-day curves for prior months
  const priorMonthCurves = [];
  const mt = getMonthlyTotals();
  for (let offset = 1; offset <= 6; offset++) {
    const d = new Date(now.getFullYear(), now.getMonth() - offset, 1);
    const key = d.getFullYear() + '-' + String(d.getMonth() + 1).padStart(2, '0');
    if (!mt[key]) continue;

    const mDays = new Date(d.getFullYear(), d.getMonth() + 1, 0).getDate();
    const shifts = Object.values(data.shifts).filter(s => s.date.startsWith(key));
    if (shifts.length === 0) continue;

    const dailyPts = new Array(mDays + 1).fill(0);
    shifts.forEach(s => {
      const day = parseInt(s.date.split('-')[2]);
      dailyPts[day] += calcShiftTotal(s).total;
    });

    const cumulative = new Array(mDays + 1).fill(0);
    for (let i = 1; i <= mDays; i++) {
      cumulative[i] = cumulative[i - 1] + dailyPts[i];
    }

    priorMonthCurves.push({ key, days: mDays, cumulative, total: round2(cumulative[mDays]) });
  }

  // Calculate expected points by now and target end-of-month
  // Use working-day fraction instead of calendar fraction to account for vacation
  let expectedByNow = 0;
  let avgMonthEnd = 0;
  if (priorMonthCurves.length > 0) {
    let sumAtDay = 0;
    let sumTotal = 0;
    priorMonthCurves.forEach(curve => {
      // Map effective working-day fraction to prior month's timeline
      const fraction = workingDaysInMonth > 0 ? workingDaysElapsed / workingDaysInMonth : 0;
      const mappedDay = fraction * curve.days;
      const lower = Math.floor(mappedDay);
      const upper = Math.min(Math.ceil(mappedDay), curve.days);
      const frac = mappedDay - lower;
      const interpolated = lower >= 1
        ? curve.cumulative[lower] * (1 - frac) + curve.cumulative[upper] * frac
        : curve.cumulative[upper] * frac;
      sumAtDay += interpolated;
      sumTotal += curve.total;
    });
    // Scale prior month averages by vacation ratio (fewer working days = lower expected total)
    avgMonthEnd = round2((sumTotal / priorMonthCurves.length) * vacationRatio);
    expectedByNow = round2((sumAtDay / priorMonthCurves.length) * vacationRatio);
  }

  // Project end-of-month
  let projected;
  if (expectedByNow > 0) {
    projected = round2(currentPts * (avgMonthEnd / expectedByNow));
  } else {
    const fractionElapsed = workingDaysInMonth > 0 ? workingDaysElapsed / workingDaysInMonth : 0;
    projected = fractionElapsed > 0 ? round2(currentPts / fractionElapsed) : 0;
  }

  document.getElementById('paceCurrentPts').textContent = currentPts.toFixed(1) + ' pts';
  document.getElementById('paceProjected').textContent = projected.toFixed(1) + ' pts';

  // Progress bar
  let pct = 0;
  let label = '';
  if (expectedByNow > 0) {
    pct = Math.min(100, round2(currentPts / avgMonthEnd * 100));
    const diff = round2(currentPts - expectedByNow);
    const nMonths = priorMonthCurves.length;
    let vacNote = totalVacDays > 0 ? ` \u2022 ${totalVacDays}d vacation` : '';
    label = `${pct.toFixed(0)}% of adj avg (${avgMonthEnd.toFixed(0)} pts) \u2022 ${diff >= 0 ? '+' : ''}${diff.toFixed(0)} pts vs pace (${nMonths}-mo)${vacNote}`;
  } else {
    pct = Math.min(100, (dayOfMonth / daysInMonth) * 100);
    label = `Day ${dayOfMonth} of ${daysInMonth} \u2022 No prior data for comparison`;
  }
  document.getElementById('paceBar').style.width = pct + '%';
  document.getElementById('paceBar').style.background = (expectedByNow > 0 && currentPts >= expectedByNow) ? 'var(--accent)' : 'var(--primary)';
  document.getElementById('paceLabel').textContent = label;
}

function renderPipelineChart() {
  const now = new Date();
  const mt = getMonthlyTotals();
  const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
  const pv = settings.pointValue || 0;

  // Stabilization weights: paycheck for month M uses:
  //   10% of M + 40% of M-1 + 25% of M-2 + 15% of M-3 + 10% of M-4
  const weights = [0.10, 0.40, 0.25, 0.15, 0.10];

  // Helper: get month key like "2026-02"
  function mkKey(year, month) {
    const d = new Date(year, month, 1);
    return d.getFullYear() + '-' + String(d.getMonth() + 1).padStart(2, '0');
  }

  // Calculate rolling avg from recent known months for optional projections
  const includeProjections = document.getElementById('pipelineProjectToggle').checked;
  const recentKnown = [];
  for (let i = 0; i < 3; i++) {
    const k = mkKey(now.getFullYear(), now.getMonth() - i);
    if (mt[k]) recentKnown.push(mt[k]);
  }
  const avgProjection = includeProjections && recentKnown.length > 0
    ? recentKnown.reduce((a, b) => a + b, 0) / recentKnown.length : 0;

  // For each of the next 5 months, compute the full stabilization-weighted paycheck
  // using real data where available; projected avg only when toggle is on
  const labels = [];
  const realValues = [];      // solid portion (from recorded data)
  const projectedValues = []; // translucent portion (from rolling avg)
  const breakdowns = [];

  for (let target = 0; target < 5; target++) {
    const targetDate = new Date(now.getFullYear(), now.getMonth() + target, 1);
    const label = monthNames[targetDate.getMonth()] + ' ' + targetDate.getFullYear();
    labels.push(target === 0 ? label + ' (current)' : label);

    // For this target month's paycheck, we need months: target, target-1, target-2, target-3, target-4
    let realPts = 0;
    let projPts = 0;
    const bd = [];
    for (let w = 0; w < 5; w++) {
      const srcDate = new Date(now.getFullYear(), now.getMonth() + target - w, 1);
      const srcKey = mkKey(srcDate.getFullYear(), srcDate.getMonth());
      const srcLabel = monthNames[srcDate.getMonth()] + ' ' + srcDate.getFullYear().toString().slice(2);

      const isCurrentOrPast = srcDate <= now || srcKey === mkKey(now.getFullYear(), now.getMonth());
      const isProjected = !mt[srcKey] && !isCurrentOrPast;
      let srcPts;
      if (mt[srcKey] !== undefined) {
        srcPts = mt[srcKey];
      } else if (isCurrentOrPast) {
        srcPts = 0;
      } else {
        srcPts = avgProjection;
      }

      const contribution = round2(srcPts * weights[w]);
      if (isProjected) {
        projPts += contribution;
      } else {
        realPts += contribution;
      }
      bd.push({ label: srcLabel, weight: weights[w], pts: round2(srcPts), contribution, isProjected });
    }

    realValues.push(round2(realPts));
    projectedValues.push(round2(projPts));
    breakdowns.push(bd);
  }

  // Add stipends: each target month's paycheck includes the previous month's stipend
  const stipendValues = [];
  for (let target = 0; target < 5; target++) {
    const stipKey = mkKey(now.getFullYear(), now.getMonth() + target - 1);
    stipendValues.push(getMonthlyStipendTotal(stipKey));
  }

  // December advance: December gets January's paycheck added, January becomes $0
  const decAdv = settings.decemberAdvance !== false;
  const decAdvFlags = []; // track which months are affected for tooltip
  for (let target = 0; target < 5; target++) {
    const targetDate = new Date(now.getFullYear(), now.getMonth() + target, 1);
    const targetMonth = targetDate.getMonth();
    decAdvFlags.push({ isDec: targetMonth === 11, isJan: targetMonth === 0 });

    if (decAdv && targetMonth === 0) {
      // January: $0 (already received in December)
      realValues[target] = 0;
      projectedValues[target] = 0;
      stipendValues[target] = 0;
    }

    if (decAdv && targetMonth === 11) {
      // December: add January's paycheck as advance
      const janDate = new Date(targetDate.getFullYear() + 1, 0, 1);
      let janReal = 0, janProj = 0;
      for (let w = 0; w < 5; w++) {
        const srcDate = new Date(janDate.getFullYear(), janDate.getMonth() - w, 1);
        const srcKey = mkKey(srcDate.getFullYear(), srcDate.getMonth());
        const isCurrentOrPast = srcDate <= now || srcKey === mkKey(now.getFullYear(), now.getMonth());
        const isProjected = !mt[srcKey] && !isCurrentOrPast;
        const srcPts = mt[srcKey] !== undefined ? mt[srcKey] : (isCurrentOrPast ? 0 : avgProjection);
        const contribution = round2(srcPts * weights[w]);
        if (isProjected) janProj += contribution; else janReal += contribution;
      }
      realValues[target] += round2(janReal);
      projectedValues[target] += round2(janProj);
      // Add December's stipend → January paycheck (now included in December)
      const janStipKey = mkKey(targetDate.getFullYear(), 11); // Dec stipend → Jan paycheck
      stipendValues[target] += getMonthlyStipendTotal(janStipKey);
    }
  }

  const ctx = document.getElementById('pipelineChart').getContext('2d');
  if (pipelineChart) pipelineChart.destroy();

  const useDollars = pv > 0;
  const realData = useDollars ? realValues.map((v, i) => round2(v * pv + stipendValues[i])) : realValues;
  const projData = useDollars ? projectedValues.map(v => round2(v * pv)) : projectedValues;
  const hasAnyProjections = projectedValues.some(v => v > 0);

  const datasets = [{
    label: useDollars ? 'Recorded ($)' : 'Recorded Data',
    data: realData,
    backgroundColor: '#10b981',
    borderWidth: 0,
    borderRadius: hasAnyProjections ? 0 : 4
  }];

  if (hasAnyProjections) {
    datasets.push({
      label: useDollars ? 'Projected ($)' : 'Projected (3-mo avg)',
      data: projData,
      backgroundColor: 'rgba(245,158,11,0.35)',
      borderWidth: 0,
      borderRadius: 4
    });
  }

  pipelineChart = new Chart(ctx, {
    type: 'bar',
    data: { labels, datasets },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: { display: hasAnyProjections, labels: { color: '#94a3b8', boxWidth: 12, padding: 12 } },
        tooltip: {
          callbacks: {
            title: ctx => ctx[0].label,
            afterBody: function(ctx) {
              const idx = ctx[0].dataIndex;
              const flags = decAdvFlags[idx];
              if (decAdv && flags.isJan) return ['  $0 \u2014 advanced in December'];
              const bd = breakdowns[idx];
              const lines = bd.map(b => {
                const pct = (b.weight * 100).toFixed(0);
                const proj = b.isProjected ? ' (est)' : '';
                return `  ${pct}% \u00d7 ${b.pts.toFixed(0)} pts${proj} (${b.label}) = ${b.contribution.toFixed(1)}`;
              });
              const total = round2(realValues[idx] + projectedValues[idx]);
              const stip = stipendValues[idx];
              if (useDollars) {
                let line = `  Total: ${total.toFixed(1)} pts \u2192 $${round2(total * pv).toLocaleString('en-US', {maximumFractionDigits:0})}`;
                if (stip > 0) line += ` + $${stip.toLocaleString('en-US', {maximumFractionDigits:0})} stipend`;
                if (flags.isDec) line += ' (incl. Jan advance)';
                lines.push(line);
              }
              return lines;
            }
          }
        }
      },
      scales: {
        y: {
          beginAtZero: true,
          stacked: true,
          ticks: { color: '#94a3b8', callback: v => useDollars ? '$' + v.toLocaleString() : v },
          grid: { color: 'rgba(71,85,105,0.3)' }
        },
        x: { stacked: true, ticks: { color: '#94a3b8', font: { size: 10 } }, grid: { display: false } }
      }
    }
  });

  // Summary
  const currentPts = mt[mkKey(now.getFullYear(), now.getMonth())] || 0;
  let summary = `Current month: ${currentPts.toFixed(0)} pts`;
  if (useDollars) {
    const nextPaycheck = round2((realValues[0] + projectedValues[0]) * pv + stipendValues[0]);
    const isCurrentJan = decAdv && now.getMonth() === 0;
    if (isCurrentJan) {
      summary += ' \u2022 Next paycheck: $0 (advanced in Dec)';
    } else {
      summary += ` \u2022 Next paycheck: $${nextPaycheck.toLocaleString('en-US', {maximumFractionDigits: 0})}`;
      if (decAdv && now.getMonth() === 11) summary += ' (incl. Jan)';
    }
  }
  document.getElementById('pipelineSummary').textContent = summary;
}

function renderPtsPerShiftType() {
  const groups = {};
  Object.values(data.shifts).forEach(shift => {
    const t = calcShiftTotal(shift).total;
    const type = shift.assignmentType;
    if (!groups[type]) groups[type] = { totalPts: 0, count: 0 };
    groups[type].totalPts += t;
    groups[type].count++;
  });

  const ranked = Object.entries(groups)
    .map(([type, g]) => ({ type, name: getAssignmentTypeName(type), avgPts: round2(g.totalPts / g.count), count: g.count, totalPts: round2(g.totalPts) }))
    .sort((a, b) => b.avgPts - a.avgPts);

  let html = '';
  if (ranked.length > 0) {
    html += '<div style="font-size:0.75rem;color:var(--text-dim);margin-bottom:8px;">Average total points per shift (AR + production + call)</div>';
    ranked.forEach(r => {
      html += `<div class="efficiency-item"><span class="eff-label">${escHtml(r.name)} <span style="color:var(--text-dim);font-size:0.75rem;">(${r.count} shift${r.count !== 1 ? 's' : ''})</span></span><span class="eff-value" style="color:var(--primary);">${r.avgPts.toFixed(1)}</span></div>`;
    });
  }
  if (!html) html = '<p style="font-size:0.85rem;color:var(--text-dim);">No shift data yet.</p>';
  document.getElementById('ptsPerTypeContent').innerHTML = html;
}

function renderShiftEfficiency() {
  const allShifts = Object.values(data.shifts);
  const efficiencies = [];
  allShifts.forEach(shift => {
    const hrs = calcShiftHours(shift);
    if (hrs <= 0) return;
    const total = calcShiftTotal(shift).total;
    efficiencies.push({ date: shift.date, type: shift.assignmentType, ptsPerHr: round2(total / hrs), total, hrs });
  });
  efficiencies.sort((a, b) => b.ptsPerHr - a.ptsPerHr);
  const best5 = efficiencies.slice(0, 5);
  const worst5 = efficiencies.length > 5 ? efficiencies.slice(-5).reverse() : [];
  let html = '';
  if (best5.length > 0) {
    html += '<h4 style="font-size:0.82rem;color:var(--accent);margin-bottom:6px;">Top 5 (pts/hr)</h4>';
    best5.forEach(e => {
      html += `<div class="efficiency-item"><span class="eff-label">${formatDateShort(e.date)} — ${getAssignmentTypeName(e.type)}</span><span class="eff-value good">${e.ptsPerHr.toFixed(1)}</span></div>`;
    });
  }
  if (worst5.length > 0) {
    html += '<h4 style="font-size:0.82rem;color:var(--danger);margin-top:12px;margin-bottom:6px;">Bottom 5 (pts/hr)</h4>';
    worst5.forEach(e => {
      html += `<div class="efficiency-item"><span class="eff-label">${formatDateShort(e.date)} — ${getAssignmentTypeName(e.type)}</span><span class="eff-value bad">${e.ptsPerHr.toFixed(1)}</span></div>`;
    });
  }
  if (!html) html = '<p style="font-size:0.85rem;color:var(--text-dim);">No shift data yet.</p>';
  document.getElementById('efficiencyContent').innerHTML = html;
}

function renderCaseTypeEfficiency() {
  const groups = {};
  data.cases.forEach(c => {
    const shift = data.shifts[c.shiftDate];
    if (!shift) return;
    const pts = calcCasePoints(c, shift);
    // Calculate case duration in hours
    let hrs = 0;
    if (c.startTime && c.endTime) {
      let s = timeToMinutes(c.startTime), e = timeToMinutes(c.endTime);
      if (e <= s) e += 1440;
      hrs = (e - s) / 60;
    }
    const key = c.caseType === 'standard' ? (c.procedure || 'Standard Case') : getCaseTypeName(c.caseType);
    if (!groups[key]) groups[key] = { totalPts: 0, totalHrs: 0, count: 0 };
    groups[key].totalPts += pts;
    groups[key].totalHrs += hrs;
    groups[key].count++;
  });

  const ranked = Object.entries(groups)
    .map(([name, g]) => ({ name, ptsPerHr: g.totalHrs > 0 ? round2(g.totalPts / g.totalHrs) : 0, totalPts: round2(g.totalPts), count: g.count, hasTime: g.totalHrs > 0 }))
    .filter(r => r.count >= 2 && r.hasTime)
    .sort((a, b) => b.ptsPerHr - a.ptsPerHr);

  let html = '';
  if (ranked.length > 0) {
    const top = ranked.slice(0, 8);
    html += '<h4 style="font-size:0.82rem;color:var(--accent);margin-bottom:6px;">Highest pts/hr by Case Type</h4>';
    top.forEach(r => {
      html += `<div class="efficiency-item"><span class="eff-label">${escHtml(r.name)} <span style="color:var(--text-dim);font-size:0.75rem;">(${r.count}x)</span></span><span class="eff-value good">${r.ptsPerHr.toFixed(1)}</span></div>`;
    });

    const bottom = ranked.slice(-Math.min(5, Math.max(0, ranked.length - 8))).reverse();
    if (bottom.length > 0) {
      html += '<h4 style="font-size:0.82rem;color:var(--danger);margin-top:12px;margin-bottom:6px;">Lowest pts/hr by Case Type</h4>';
      bottom.forEach(r => {
        html += `<div class="efficiency-item"><span class="eff-label">${escHtml(r.name)} <span style="color:var(--text-dim);font-size:0.75rem;">(${r.count}x)</span></span><span class="eff-value bad">${r.ptsPerHr.toFixed(1)}</span></div>`;
      });
    }
  }
  if (!html) html = '<p style="font-size:0.85rem;color:var(--text-dim);">Not enough timed case data yet (need 2+ of a type).</p>';
  document.getElementById('caseEffContent').innerHTML = html;
}

function renderMoMChange() {
  const mt = getMonthlyTotals();
  const now = new Date();
  function mk(offset) { const d = new Date(now.getFullYear(), now.getMonth() - offset, 1); return d.getFullYear() + '-' + String(d.getMonth()+1).padStart(2,'0'); }
  const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
  let html = '';
  for (let i = 0; i < 3; i++) {
    const key = mk(i);
    const prevKey = mk(i + 1);
    const curr = mt[key] || 0;
    const prev = mt[prevKey] || 0;
    const [y, m] = key.split('-');
    const label = monthNames[parseInt(m)-1] + ' ' + y;
    let change = '', cls = 'trend-flat';
    if (prev > 0) {
      const pct = round2(((curr - prev) / prev) * 100);
      if (pct > 0) { change = `+${pct.toFixed(1)}%`; cls = 'trend-up'; }
      else if (pct < 0) { change = `${pct.toFixed(1)}%`; cls = 'trend-down'; }
      else { change = '0%'; }
    } else {
      change = curr > 0 ? 'New' : '-';
    }
    html += `<div class="efficiency-item"><span class="eff-label">${label}: ${curr.toFixed(0)} pts</span><span class="eff-value ${cls}">${change}</span></div>`;
  }
  document.getElementById('momContent').innerHTML = html || '<p style="font-size:0.85rem;color:var(--text-dim);">Not enough data.</p>';
}

// ================================================================
// TIME TAB
// ================================================================
function renderTimeTab() {
  renderTimeSummary();
  renderProductionTrend();
  renderDayOfWeekHeatmap();
  renderWeekendVsWeekday();
  renderNightCallFreq();
}

function getRecentShifts(months) {
  const now = new Date();
  const cutoff = new Date(now.getFullYear(), now.getMonth() - months, 1);
  const cutoffStr = cutoff.getFullYear() + '-' + String(cutoff.getMonth()+1).padStart(2,'0') + '-01';
  return Object.values(data.shifts).filter(s => s.date >= cutoffStr);
}

function renderTimeSummary() {
  const recent = getRecentShifts(3);
  if (recent.length === 0) {
    document.getElementById('timeAvgMonth').textContent = '0';
    document.getElementById('timeAvgWeek').textContent = '0';
    document.getElementById('timeAvgStart').textContent = '--:--';
    document.getElementById('timeAvgEnd').textContent = '--:--';
    return;
  }
  let totalHours = 0, totalStartMin = 0, totalEndMin = 0, count = 0;
  recent.forEach(s => {
    const hrs = calcShiftHours(s);
    if (hrs > 0) {
      totalHours += hrs;
      const entries = s.timeEntries || [{ start: s.startTime, end: s.endTime }];
      totalStartMin += timeToMinutes(entries[0].start);
      const lastEnd = entries[entries.length - 1].end;
      totalEndMin += timeToMinutes(lastEnd || entries[0].start);
      count++;
    }
  });
  const avgMonthHrs = count > 0 ? round2(totalHours / 3) : 0;
  const avgWeekHrs = count > 0 ? round2(totalHours / 13) : 0; // ~13 weeks in 3 months
  document.getElementById('timeAvgMonth').textContent = avgMonthHrs.toFixed(0);
  document.getElementById('timeAvgWeek').textContent = avgWeekHrs.toFixed(0);
  if (count > 0) {
    const avgSM = Math.round(totalStartMin / count);
    const avgEM = Math.round(totalEndMin / count);
    document.getElementById('timeAvgStart').textContent = String(Math.floor(avgSM/60)).padStart(2,'0') + ':' + String(avgSM%60).padStart(2,'0');
    document.getElementById('timeAvgEnd').textContent = String(Math.floor(avgEM/60)).padStart(2,'0') + ':' + String(avgEM%60).padStart(2,'0');
  }
}

function renderProductionTrend() {
  const mt = getMonthlyTotals();
  const sortedKeys = Object.keys(mt).sort();
  const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
  const labels = sortedKeys.map(k => { const [y,m] = k.split('-'); return monthNames[parseInt(m)-1] + ' ' + y; });
  const values = sortedKeys.map(k => round2(mt[k]));
  const ctx = document.getElementById('productionTrendChart').getContext('2d');
  if (productionTrendChart) productionTrendChart.destroy();
  productionTrendChart = new Chart(ctx, {
    type: 'line',
    data: {
      labels,
      datasets: [{ label: 'Monthly Points', data: values, borderColor: '#3b82f6', backgroundColor: 'rgba(59,130,246,0.15)', fill: true, tension: 0.3, pointRadius: 4, pointBackgroundColor: '#3b82f6' }]
    },
    options: {
      responsive: true, maintainAspectRatio: false,
      plugins: { legend: { display: false } },
      scales: {
        y: { beginAtZero: true, ticks: { color: '#94a3b8' }, grid: { color: 'rgba(71,85,105,0.3)' } },
        x: { ticks: { color: '#94a3b8', maxRotation: 45, minRotation: 45 }, grid: { display: false } }
      }
    }
  });
}

function renderDayOfWeekHeatmap() {
  const days = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
  const hoursByDay = [0,0,0,0,0,0,0];
  const ptsByDay = [0,0,0,0,0,0,0];
  const countByDay = [0,0,0,0,0,0,0];
  Object.values(data.shifts).forEach(s => {
    const d = new Date(s.date + 'T12:00:00');
    const dow = d.getDay();
    const hrs = calcShiftHours(s);
    hoursByDay[dow] += hrs;
    ptsByDay[dow] += calcShiftTotal(s).total;
    countByDay[dow]++;
  });
  const maxHrs = Math.max(...hoursByDay, 1);
  let html = '';
  for (let i = 1; i <= 7; i++) {
    const idx = i % 7; // Mon first, Sun last
    const pct = maxHrs > 0 ? (hoursByDay[idx] / maxHrs * 100) : 0;
    html += `<div class="heatmap-row">
      <span class="hm-label">${days[idx]}</span>
      <div style="flex:1;display:flex;gap:4px;align-items:center;">
        <div class="heatmap-bar" style="width:${pct}%"></div>
        <div class="heatmap-bar green" style="width:${maxHrs > 0 ? (ptsByDay[idx] / Math.max(...ptsByDay, 1) * 100) : 0}%"></div>
      </div>
      <span class="hm-value">${hoursByDay[idx].toFixed(0)}h / ${ptsByDay[idx].toFixed(0)}pts</span>
    </div>`;
  }
  document.getElementById('dowContent').innerHTML = html || '<p style="color:var(--text-dim);font-size:0.85rem;">No data.</p>';
}

function renderWeekendVsWeekday() {
  let wdHrs = 0, wdPts = 0, wdN = 0, weHrs = 0, wePts = 0, weN = 0;
  Object.values(data.shifts).forEach(s => {
    const hrs = calcShiftHours(s);
    const pts = calcShiftTotal(s).total;
    if (isWeekend(s.date)) { weHrs += hrs; wePts += pts; weN++; }
    else { wdHrs += hrs; wdPts += pts; wdN++; }
  });
  let html = '<div class="summary-grid">';
  html += `<div class="summary-item"><div class="label">Weekday Avg Pts</div><div class="value blue">${wdN > 0 ? (wdPts/wdN).toFixed(1) : '0'}</div></div>`;
  html += `<div class="summary-item"><div class="label">Weekend Avg Pts</div><div class="value green">${weN > 0 ? (wePts/weN).toFixed(1) : '0'}</div></div>`;
  html += `<div class="summary-item"><div class="label">Weekday Avg Hrs</div><div class="value blue">${wdN > 0 ? (wdHrs/wdN).toFixed(1) : '0'}</div></div>`;
  html += `<div class="summary-item"><div class="label">Weekend Avg Hrs</div><div class="value green">${weN > 0 ? (weHrs/weN).toFixed(1) : '0'}</div></div>`;
  html += `<div class="summary-item"><div class="label">Weekday Shifts</div><div class="value">${wdN}</div></div>`;
  html += `<div class="summary-item"><div class="label">Weekend Shifts</div><div class="value">${weN}</div></div>`;
  html += '</div>';
  document.getElementById('wkndContent').innerHTML = html;
}

function renderNightCallFreq() {
  const allShifts = Object.values(data.shifts);
  const total = allShifts.length;
  let nightCount = 0, callEligibleCount = 0, multiEntryCount = 0;
  allShifts.forEach(s => {
    const start = timeToMinutes(s.startTime);
    if (start >= 1020) nightCount++;
    if (UNRESTRICTED_CALL_TYPES.has(s.assignmentType)) callEligibleCount++;
    if (s.timeEntries && s.timeEntries.length > 1) multiEntryCount++;
  });
  let html = `<div class="efficiency-item"><span class="eff-label">Night Shifts (start >= 17:00)</span><span class="eff-value">${nightCount} (${total > 0 ? round2(nightCount/total*100).toFixed(0) : 0}%)</span></div>`;
  html += `<div class="efficiency-item"><span class="eff-label">Call-Eligible Shifts</span><span class="eff-value">${callEligibleCount} (${total > 0 ? round2(callEligibleCount/total*100).toFixed(0) : 0}%)</span></div>`;
  html += `<div class="efficiency-item"><span class="eff-label">Multi-Entry Shifts</span><span class="eff-value">${multiEntryCount}</span></div>`;
  html += `<div class="efficiency-item"><span class="eff-label">Total Shifts</span><span class="eff-value">${total}</span></div>`;
  document.getElementById('nightContent').innerHTML = html;
}

// ================================================================
// ANALYTICS TAB
// ================================================================
// ================================================================
// DAILY TAB
// ================================================================
let dailyMonth = new Date().getMonth();
let dailyYear = new Date().getFullYear();

function updateDailyMonthLabel() {
  const monthNames = ['January','February','March','April','May','June','July','August','September','October','November','December'];
  document.getElementById('dailyMonthLabel').textContent = monthNames[dailyMonth] + ' ' + dailyYear;
}

document.getElementById('dailyPrevMonth').addEventListener('click', () => {
  dailyMonth--; if (dailyMonth < 0) { dailyMonth = 11; dailyYear--; }
  renderDailyTab();
});
document.getElementById('dailyNextMonth').addEventListener('click', () => {
  dailyMonth++; if (dailyMonth > 11) { dailyMonth = 0; dailyYear++; }
  renderDailyTab();
});

function renderDailyTab() {
  updateDailyMonthLabel();
  const prefix = dailyYear + '-' + String(dailyMonth + 1).padStart(2, '0');
  const daysInMonth = new Date(dailyYear, dailyMonth + 1, 0).getDate();
  const firstDow = new Date(dailyYear, dailyMonth, 1).getDay(); // 0=Sun
  const today = new Date();
  const todayStr = today.getFullYear() + '-' + String(today.getMonth()+1).padStart(2,'0') + '-' + String(today.getDate()).padStart(2,'0');

  // Compute daily totals
  const dailyPts = {};
  const dailyTypes = {};
  Object.values(data.shifts).forEach(s => {
    if (!s.date || !s.date.startsWith(prefix)) return;
    const day = parseInt(s.date.split('-')[2]);
    const t = calcShiftTotal(s);
    dailyPts[day] = (dailyPts[day] || 0) + t.total;
    dailyTypes[day] = s.assignmentType;
  });

  // Build calendar grid
  let html = '<div class="daily-cal">';
  const dayNames = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
  dayNames.forEach(d => { html += `<div class="daily-cal-header">${d}</div>`; });

  // Empty cells for days before month starts
  for (let i = 0; i < firstDow; i++) {
    html += '<div class="daily-cal-cell empty"></div>';
  }

  let monthTotal = 0;
  let shiftCount = 0;
  for (let d = 1; d <= daysInMonth; d++) {
    const dateStr = prefix + '-' + String(d).padStart(2, '0');
    const pts = round2(dailyPts[d] || 0);
    const shiftType = dailyTypes[d];
    const isToday = dateStr === todayStr;
    const isVac = shiftType === 'vacation';
    monthTotal += pts;
    if (shiftType) shiftCount++;

    let classes = 'daily-cal-cell';
    if (isToday) classes += ' today';
    if (isVac) classes += ' vacation';

    const typeName = shiftType ? getAssignmentTypeName(shiftType) : '';
    const ptsClass = pts > 0 ? '' : ' zero';

    html += `<div class="${classes}" onclick="openDayDetail('${dateStr}')">`;
    html += `<div class="daily-cal-day">${d}</div>`;
    html += `<div class="daily-cal-pts${ptsClass}">${pts > 0 ? pts.toFixed(1) : (isVac ? 'VAC' : '—')}</div>`;
    if (typeName) html += `<div class="daily-cal-type">${typeName}</div>`;
    html += '</div>';
  }
  html += '</div>';

  document.getElementById('dailyCalendarContainer').innerHTML = html;

  // Summary
  const avgPerShift = shiftCount > 0 ? (monthTotal / shiftCount).toFixed(1) : '—';
  document.getElementById('dailyMonthSummary').innerHTML =
    `<span style="font-size:1.3rem;font-weight:700;color:var(--accent);">${round2(monthTotal).toFixed(1)}</span> <span style="color:var(--text-dim);">total pts</span> &bull; <strong>${shiftCount}</strong> shifts &bull; <strong>${avgPerShift}</strong> avg pts/shift`;
}

// ================================================================
// DAY DETAIL — Navigate to Today page from Daily tab
// ================================================================
let dayDetailDate = '';
let returnToDailyTab = false;

function openDayDetail(dateStr) {
  dayDetailDate = dateStr;
  returnToDailyTab = true;
  // Set working date and navigate to Today page
  setWorkingDate(dateStr);
  document.querySelectorAll('.bottom-nav button').forEach(b => b.classList.remove('active'));
  document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
  const todayBtn = document.querySelector('.bottom-nav button[data-page="today"]');
  if (todayBtn) todayBtn.classList.add('active');
  document.getElementById('page-today').classList.add('active');
  renderToday();
  window.scrollTo(0, 0);
}

function renderDayDetailContent() {
  const dateStr = dayDetailDate;
  if (!dateStr) return;
  const shift = data.shifts[dateStr];
  const shiftCases = data.cases.filter(c => c.shiftDate === dateStr);
  const body = document.getElementById('dayDetailBody');

  if (!shift) {
    body.innerHTML = '<p style="color:var(--text-dim);font-size:0.85rem;margin:12px 0;">No shift saved for this date.</p>' +
      (shiftCases.length > 0 ? renderDDCaseList(shiftCases, null) : '');
    return;
  }

  const totals = calcShiftTotal(shift);
  const isVacation = shift.assignmentType === 'vacation';
  const entries = shift.timeEntries || [{ start: shift.startTime, end: shift.endTime }];
  let timesText = '';
  if (isVacation) {
    timesText = 'Vacation Day';
  } else if (entries.length === 1) {
    timesText = (entries[0].start || '?') + ' - ' + (entries[0].end || '?');
  } else {
    timesText = entries.length + ' time entries';
  }

  let html = '';
  // Shift bar
  html += `<div class="dd-shift-bar">
    <span class="dd-badge${isVacation ? ' vacation' : ''}">${escHtml(getAssignmentTypeName(shift.assignmentType))}</span>
    <span class="dd-times">${escHtml(timesText)}</span>
    <button class="btn btn-outline btn-sm" onclick="openShiftEdit('${dateStr}')" style="padding:4px 10px;font-size:0.72rem;">Edit</button>
  </div>`;

  // Point summary
  html += `<div class="dd-summary">
    <div class="dd-summary-item"><div class="dd-label">Availability</div><div class="dd-value blue">${totals.ar.toFixed(1)}</div></div>
    <div class="dd-summary-item"><div class="dd-label">Productivity</div><div class="dd-value green">${totals.prod.toFixed(1)}</div></div>
    <div class="dd-summary-item"><div class="dd-label">Call / Other</div><div class="dd-value yellow">${(totals.call + totals.subspec + totals.supervision).toFixed(1)}</div></div>
    <div class="dd-summary-item"><div class="dd-label">Total</div><div class="dd-value green">${totals.total.toFixed(1)}</div></div>
  </div>`;

  // Case list
  if (!isVacation) {
    html += `<h3 style="font-size:0.85rem;margin-bottom:6px;">Cases (${shiftCases.length})</h3>`;
    html += renderDDCaseList(shiftCases, shift);
  }

  body.innerHTML = html;
}

function renderDDCaseList(cases, shift) {
  if (cases.length === 0) return '<p style="color:var(--text-dim);font-size:0.8rem;">No cases logged.</p>';
  let html = '';
  cases.forEach(c => {
    const pts = shift ? calcCasePoints(c, shift) : 0;
    const name = c.caseType === 'standard' ? (c.procedure || 'Standard Case') : getCaseTypeName(c.caseType);
    const timeStr = c.startTime && c.endTime ? `${c.startTime} - ${c.endTime}` : (c.startTime ? c.startTime : '');
    html += `<div class="dd-case-item">
      <div class="dd-case-info">
        <div class="dd-case-name">${escHtml(name)}</div>
        ${timeStr ? `<div class="dd-case-detail">${escHtml(timeStr)}</div>` : ''}
      </div>
      <div class="dd-case-actions">
        <span class="dd-case-pts">${pts.toFixed(1)}</span>
        <button class="btn btn-outline btn-sm" onclick="openCaseEdit('${c.id}')" style="padding:2px 8px;font-size:0.68rem;">Edit</button>
        <button class="btn btn-danger btn-sm" onclick="deleteCaseDayDetail('${c.id}')" style="padding:2px 8px;font-size:0.68rem;">Del</button>
      </div>
    </div>`;
  });
  return html;
}

function deleteCaseDayDetail(id) {
  if (!confirm('Delete this case?')) return;
  data.cases = data.cases.filter(c => c.id !== id);
  saveData(data);
  updateHeaderPoints();
  renderDayDetailContent();
  renderDailyTab();
  renderDECaseList();
  updateDETally();
  showToast('Case deleted');
}

document.getElementById('closeDayDetail').addEventListener('click', () => {
  document.getElementById('dayDetailModal').classList.add('hidden');
});

document.getElementById('dayDetailModal').addEventListener('click', (e) => {
  if (e.target.id === 'dayDetailModal') document.getElementById('dayDetailModal').classList.add('hidden');
});

function renderAnalyticsTab() {
  renderCaseMix();
  renderAddOnUtil();
  renderTopProcedures();
  renderAvgUnits();
  renderShiftDistChart();
}

function renderCaseMix() {
  const freq = {};
  data.cases.forEach(c => {
    const name = c.caseType === 'standard' ? (c.procedure || 'Standard') : getCaseTypeName(c.caseType);
    freq[name] = (freq[name] || 0) + 1;
  });
  const sorted = Object.entries(freq).sort((a, b) => b[1] - a[1]);
  const maxCount = sorted.length > 0 ? sorted[0][1] : 1;
  if (sorted.length === 0) {
    document.getElementById('caseMixContent').innerHTML = '<div class="empty-state"><p>No case data.</p></div>';
    return;
  }
  let html = '';
  sorted.slice(0, 20).forEach(([name, count]) => {
    const pct = (count / maxCount * 100);
    html += `<div class="case-mix-item"><span class="cm-label" title="${escHtml(name)}">${escHtml(name)}</span><div class="case-mix-bar-wrap"><div class="case-mix-bar" style="width:${pct}%"></div></div><span class="cm-count">${count}</span></div>`;
  });
  document.getElementById('caseMixContent').innerHTML = html;
}

function renderAddOnUtil() {
  const stdCases = data.cases.filter(c => c.caseType === 'standard');
  const total = stdCases.length;
  if (total === 0) { document.getElementById('addOnContent').innerHTML = '<p style="color:var(--text-dim);font-size:0.85rem;">No standard cases.</p>'; return; }
  const counts = { 'Nerve Block': 0, 'Central Line': 0, 'Arterial Line': 0, 'PAC': 0, 'TEE': 0 };
  stdCases.forEach(c => {
    if (c.nerveBlock && c.nerveBlock !== 'none') counts['Nerve Block']++;
    if (c.hasCentralLine) counts['Central Line']++;
    if (c.hasArterialLine) counts['Arterial Line']++;
    if (c.hasPAC) counts['PAC']++;
    if (c.hasTEEAddOn) counts['TEE']++;
  });
  let html = '';
  Object.entries(counts).forEach(([name, count]) => {
    const pct = round2(count / total * 100);
    html += `<div class="efficiency-item"><span class="eff-label">${name}</span><span class="eff-value">${count} (${pct.toFixed(0)}%)</span></div>`;
  });
  document.getElementById('addOnContent').innerHTML = html;
}

function renderTopProcedures() {
  const procData = {};
  data.cases.forEach(c => {
    if (!c.startTime || !c.endTime) return;
    let s = timeToMinutes(c.startTime);
    let e = timeToMinutes(c.endTime);
    if (e <= s) e += 1440;
    const hrs = (e - s) / 60;
    if (hrs <= 0) return;
    const name = c.caseType === 'standard' ? (c.procedure || 'Standard') : getCaseTypeName(c.caseType);
    const shift = data.shifts[c.shiftDate];
    const pts = calcCasePoints(c, shift);
    if (!procData[name]) procData[name] = { totalPts: 0, totalHrs: 0, count: 0 };
    procData[name].totalPts += pts;
    procData[name].totalHrs += hrs;
    procData[name].count++;
  });
  const entries = Object.entries(procData).filter(([, d]) => d.count >= 2);
  const sorted = entries.map(([name, d]) => ({ name, ptsPerHr: d.totalPts / d.totalHrs, count: d.count }))
    .sort((a, b) => b.ptsPerHr - a.ptsPerHr).slice(0, 10);
  if (sorted.length === 0) { document.getElementById('topProcContent').innerHTML = '<p style="color:var(--text-dim);font-size:0.85rem;">No data (need 2+ timed cases per procedure).</p>'; return; }
  let html = '';
  sorted.forEach((p, i) => {
    html += `<div class="efficiency-item"><span class="eff-label">${i+1}. ${escHtml(p.name)} <span style="color:var(--text-dim);font-size:0.75rem;">(${p.count})</span></span><span class="eff-value">${p.ptsPerHr.toFixed(1)} pts/hr</span></div>`;
  });
  document.getElementById('topProcContent').innerHTML = html;
}

function renderAvgUnits() {
  const stdCases = data.cases.filter(c => c.caseType === 'standard' && parseFloat(c.baseUnits) > 0);
  if (stdCases.length === 0) { document.getElementById('avgUnitsContent').innerHTML = '<p style="color:var(--text-dim);font-size:0.85rem;">No standard cases with units.</p>'; return; }
  const totalUnits = stdCases.reduce((s, c) => s + (parseFloat(c.baseUnits) || 0), 0);
  const avg = round2(totalUnits / stdCases.length);
  const maxUnits = Math.max(...stdCases.map(c => parseFloat(c.baseUnits) || 0));
  const minUnits = Math.min(...stdCases.map(c => parseFloat(c.baseUnits) || 0));
  let html = '<div class="summary-grid">';
  html += `<div class="summary-item"><div class="label">Average</div><div class="value blue">${avg.toFixed(1)}</div></div>`;
  html += `<div class="summary-item"><div class="label">Cases</div><div class="value green">${stdCases.length}</div></div>`;
  html += `<div class="summary-item"><div class="label">Min</div><div class="value">${minUnits}</div></div>`;
  html += `<div class="summary-item"><div class="label">Max</div><div class="value">${maxUnits}</div></div>`;
  html += '</div>';
  document.getElementById('avgUnitsContent').innerHTML = html;
}

function renderShiftDistChart() {
  const counts = {};
  Object.values(data.shifts).forEach(s => {
    const name = getAssignmentTypeName(s.assignmentType);
    counts[name] = (counts[name] || 0) + 1;
  });
  const labels = Object.keys(counts);
  const values = Object.values(counts);
  if (labels.length === 0) return;
  const ctx = document.getElementById('shiftDistChart').getContext('2d');
  if (shiftDistChart) shiftDistChart.destroy();
  const colors = ['#3b82f6','#10b981','#f59e0b','#8b5cf6','#ec4899','#ef4444','#06b6d4','#84cc16','#f97316','#6366f1','#14b8a6','#e11d48','#a855f7'];
  shiftDistChart = new Chart(ctx, {
    type: 'doughnut',
    data: {
      labels,
      datasets: [{ data: values, backgroundColor: colors.slice(0, labels.length), borderWidth: 0 }]
    },
    options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { position: 'bottom', labels: { color: '#94a3b8', padding: 12, font: { size: 11 } } } } }
  });
}

let editingCaseId = null;
let editCaseType = 'standard';

// Edit modal case type select
document.getElementById('editCaseTypeSelect').addEventListener('change', function() {
  editCaseType = this.value;
  const isStd = editCaseType === 'standard';
  const isLabor = editCaseType === 'labor_epidural';
  const isAPS = editCaseType === 'aps_rounding';
  document.getElementById('editStandardFields').classList.toggle('hidden', !isStd);
  document.getElementById('editLaborEpiduralFields').classList.toggle('hidden', !isLabor);
  document.getElementById('editApsRoundingFields').classList.toggle('hidden', !isAPS);
  document.getElementById('editSimpleFields').classList.toggle('hidden', isStd || isLabor || isAPS);
});

document.getElementById('editCaseAcutePain').addEventListener('change', function() {
  document.getElementById('editAcutePainUnitsRow').classList.toggle('hidden', !this.checked);
});

document.getElementById('editCaseShared').addEventListener('change', function() {
  document.getElementById('editSharedPctRow').classList.toggle('hidden', !this.checked);
});

function openCaseEdit(caseId) {
  const c = data.cases.find(x => x.id === caseId);
  if (!c) return;
  editingCaseId = caseId;
  editCaseType = c.caseType || 'standard';

  // Set case type
  document.getElementById('editCaseTypeSelect').value = editCaseType;
  const isStd = editCaseType === 'standard';
  const isLabor = editCaseType === 'labor_epidural';
  const isAPS = editCaseType === 'aps_rounding';
  document.getElementById('editStandardFields').classList.toggle('hidden', !isStd);
  document.getElementById('editLaborEpiduralFields').classList.toggle('hidden', !isLabor);
  document.getElementById('editApsRoundingFields').classList.toggle('hidden', !isAPS);
  document.getElementById('editSimpleFields').classList.toggle('hidden', isStd || isLabor || isAPS);

  // Fill fields
  document.getElementById('editCaseProcedure').value = c.procedure || '';
  document.getElementById('editCaseBaseUnits').value = c.baseUnits || '';
  document.getElementById('editCasePhysicalStatus').value = c.physicalStatus || 'P2';
  document.getElementById('editCaseStart').value = c.startTime || '';
  document.getElementById('editCaseEnd').value = c.endTime || '';
  document.getElementById('editCaseEmergency').checked = c.isEmergency || false;
  document.getElementById('editCaseAcutePain').checked = c.isAcutePain || false;
  document.getElementById('editAcutePainUnitsRow').classList.toggle('hidden', !c.isAcutePain);
  document.getElementById('editCaseAcutePainUnits').value = c.acutePainUnits || 0;
  document.getElementById('editCaseHighRiskPeds').checked = c.isHighRiskPeds || false;
  document.getElementById('editCaseNotes').value = c.notes || '';
  document.getElementById('editSimpleNotes').value = c.notes || '';

  // Add-ons
  document.getElementById('editNerveBlock').value = c.nerveBlock || 'none';
  document.getElementById('editCentralLine').checked = c.hasCentralLine || false;
  document.getElementById('editArterialLine').checked = c.hasArterialLine || false;
  document.getElementById('editPAC').checked = c.hasPAC || false;
  document.getElementById('editTEEAddOn').checked = c.hasTEEAddOn || false;
  document.getElementById('editITMorphine').checked = c.hasITMorphine || false;

  // Labor epidural fields
  if (editCaseType === 'labor_epidural') {
    document.getElementById('editLaborStart').value = c.startTime || '';
    document.getElementById('editLaborEnd').value = c.endTime || '';
  }

  // APS rounding fields
  if (editCaseType === 'aps_rounding') {
    document.getElementById('editApsEpiduralCount').value = c.epiduralRounds || 0;
    document.getElementById('editApsPainCount').value = c.painRounds || 0;
  }

  // Shared case
  document.getElementById('editCaseShared').checked = c.isSharedCase || false;
  document.getElementById('editCaseSharedPct').value = c.sharedStartupPct || 50;
  document.getElementById('editSharedPctRow').classList.toggle('hidden', !c.isSharedCase);

  // OR Case checkbox visibility
  const shift = data.shifts[c.shiftDate];
  const isSF = shift && ['SF1','SF2'].includes(shift.assignmentType);
  document.getElementById('editORCaseRow').classList.toggle('hidden', !isSF);
  document.getElementById('editCaseORCase').checked = c.isORCase || false;

  document.getElementById('caseEditModal').classList.remove('hidden');
}

document.getElementById('saveCaseEdit').addEventListener('click', () => {
  const c = data.cases.find(x => x.id === editingCaseId);
  if (!c) return;
  c.caseType = editCaseType;
  if (editCaseType === 'standard') {
    c.procedure = document.getElementById('editCaseProcedure').value;
    c.baseUnits = document.getElementById('editCaseBaseUnits').value;
    c.physicalStatus = document.getElementById('editCasePhysicalStatus').value;
    c.startTime = document.getElementById('editCaseStart').value;
    c.endTime = document.getElementById('editCaseEnd').value;
    c.isEmergency = document.getElementById('editCaseEmergency').checked;
    c.isAcutePain = document.getElementById('editCaseAcutePain').checked;
    c.acutePainUnits = document.getElementById('editCaseAcutePainUnits').value;
    c.isHighRiskPeds = document.getElementById('editCaseHighRiskPeds').checked;
    c.isORCase = document.getElementById('editCaseORCase').checked;
    c.isSharedCase = document.getElementById('editCaseShared').checked;
    c.sharedStartupPct = document.getElementById('editCaseSharedPct').value;
    c.nerveBlock = document.getElementById('editNerveBlock').value;
    c.hasCentralLine = document.getElementById('editCentralLine').checked;
    c.hasArterialLine = document.getElementById('editArterialLine').checked;
    c.hasPAC = document.getElementById('editPAC').checked;
    c.hasTEEAddOn = document.getElementById('editTEEAddOn').checked;
    c.hasITMorphine = document.getElementById('editITMorphine').checked;
    c.notes = document.getElementById('editCaseNotes').value;
  } else if (editCaseType === 'labor_epidural') {
    c.procedure = 'Labor Epidural';
    c.startTime = document.getElementById('editLaborStart').value;
    c.endTime = document.getElementById('editLaborEnd').value;
    c.notes = document.getElementById('editCaseNotes').value;
  } else if (editCaseType === 'aps_rounding') {
    c.procedure = 'APS Rounding';
    c.epiduralRounds = document.getElementById('editApsEpiduralCount').value;
    c.painRounds = document.getElementById('editApsPainCount').value;
    c.notes = document.getElementById('editCaseNotes').value;
  } else {
    c.notes = document.getElementById('editSimpleNotes').value || document.getElementById('editCaseNotes').value;
  }
  saveData(data);
  updateHeaderPoints();
  renderCaseLogTable();
  renderToday();
  renderDailyTab();
  renderDECaseList();
  updateDETally();
  document.getElementById('caseEditModal').classList.add('hidden');
  showToast('Case updated');
});

document.getElementById('cancelCaseEdit').addEventListener('click', () => {
  document.getElementById('caseEditModal').classList.add('hidden');
});

document.getElementById('caseEditModal').addEventListener('click', (e) => {
  if (e.target.id === 'caseEditModal') document.getElementById('caseEditModal').classList.add('hidden');
});

document.getElementById('deleteCaseEdit').addEventListener('click', () => {
  if (!editingCaseId) return;
  if (!confirm('Delete this case?')) return;
  data.cases = data.cases.filter(c => c.id !== editingCaseId);
  saveData(data);
  updateHeaderPoints();
  renderCaseLogTable();
  renderToday();
  renderDailyTab();
  renderDECaseList();
  updateDETally();
  document.getElementById('caseEditModal').classList.add('hidden');
  showToast('Case deleted');
});

function deleteCaseFromList(id) {
  if (!confirm('Delete this case?')) return;
  data.cases = data.cases.filter(c => c.id !== id);
  saveData(data);
  updateHeaderPoints();
  renderCaseLogTable();
  renderDECaseList();
  updateDETally();
  showToast('Case deleted');
}

// ================================================================
// EXPORT / IMPORT
// ================================================================
document.getElementById('exportCSVBtn').addEventListener('click', () => {
  const prefix = `${historyYear}-${String(historyMonth+1).padStart(2,'0')}`;
  const monthShifts = Object.values(data.shifts).filter(s => s.date.startsWith(prefix)).sort((a,b) => a.date.localeCompare(b.date));
  let csv = 'Date,Assignment,Time Entries,Entries Count,AR Points,Productivity Points,Call Points,Subspec Points,Supervision Points,Total Points,Cases\n';
  monthShifts.forEach(shift => {
    const totals = calcShiftTotal(shift);
    const cc = data.cases.filter(c => c.shiftDate === shift.date).length;
    const entries = shift.timeEntries || [{ start: shift.startTime, end: shift.endTime }];
    const timeStr = entries.map(e => `${e.start}-${e.end || '?'}`).join('; ');
    csv += `${shift.date},${getAssignmentTypeName(shift.assignmentType)},"${timeStr}",${entries.length},${totals.ar.toFixed(2)},${totals.prod.toFixed(2)},${totals.call.toFixed(2)},${totals.subspec.toFixed(2)},${totals.supervision.toFixed(2)},${totals.total.toFixed(2)},${cc}\n`;
  });
  const namePrefix = settings.name ? settings.name.replace(/\s+/g, '_') + '_' : '';
  downloadFile(csv, `${namePrefix}mwa-points-${prefix}.csv`, 'text/csv');
  showToast('CSV exported!');
});

document.getElementById('exportAllBtn').addEventListener('click', () => {
  const namePrefix = settings.name ? settings.name.replace(/\s+/g, '_') + '_' : '';
  downloadFile(JSON.stringify(data, null, 2), `${namePrefix}mwa-backup.json`, 'application/json');
  showToast('Data exported!');
});

document.getElementById('importFile').addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (ev) => {
    try {
      const imported = JSON.parse(ev.target.result);
      if (imported.shifts && imported.cases) {
        if (confirm('This will replace all existing data. Continue?')) {
          data = imported;
          migrateData(data); // handles timeEntries migration for old format
          saveData(data);
          updateHeaderPoints();
          showToast('Data imported!');
          renderHistory();
        }
      } else { showToast('Invalid file format'); }
    } catch(err) { showToast('Error reading file'); }
  };
  reader.readAsText(file);
  e.target.value = '';
});

document.getElementById('clearAllBtn').addEventListener('click', () => {
  if (confirm('Are you sure you want to delete ALL data? This cannot be undone.')) {
    if (confirm('Really delete everything?')) {
      data = { shifts: {}, cases: [] };
      saveData(data);
      updateHeaderPoints();
      showToast('All data cleared');
      renderHistory();
    }
  }
});

document.getElementById('copyFlaggedEmailBtn').addEventListener('click', () => {
  const text = document.getElementById('flaggedEmailPreview').dataset.emailText || '';
  navigator.clipboard.writeText(text).then(() => {
    document.getElementById('flaggedCopyStatus').textContent = 'Copied!';
    setTimeout(() => document.getElementById('flaggedCopyStatus').textContent = '', 2000);
  });
});
document.getElementById('clearAllFlagsBtn').addEventListener('click', () => {
  Object.values(data.shifts).forEach(s => s.flagged = false);
  data.cases.forEach(c => c.flagged = false);
  saveData();
  renderFlaggedEmail();
  if (activeDashTab === 'caselogs') renderCaseLogTable();
  if (activeDashTab === 'shiftlogs') renderShiftLogTable();
});

document.getElementById('loadTestDataBtn').addEventListener('click', () => {
  if (Object.keys(data.shifts).length > 0 || data.cases.length > 0) {
    if (!confirm('This will ADD test data alongside your existing data. Continue?')) return;
  }
  generateTestData();
  saveData(data);
  updateHeaderPoints();
  renderHistory();
  showToast('Test data loaded — 3 months of shifts & cases');
});

function generateTestData() {
  const today = new Date();
  const threeMonthsAgo = new Date(today.getFullYear(), today.getMonth() - 3, 1);
  const yesterday = new Date(today);
  yesterday.setDate(yesterday.getDate() - 1);

  const procedures = [
    { name: 'Lap Cholecystectomy', units: 7 },
    { name: 'Total Knee Arthroplasty', units: 10 },
    { name: 'Total Hip Arthroplasty', units: 10 },
    { name: 'Lap Appendectomy', units: 6 },
    { name: 'Hernia Repair', units: 5 },
    { name: 'Thyroidectomy', units: 6 },
    { name: 'Rotator Cuff Repair', units: 5 },
    { name: 'ACL Reconstruction', units: 7 },
    { name: 'Lumbar Laminectomy', units: 10 },
    { name: 'Craniotomy', units: 13 },
    { name: 'CABG', units: 20 },
    { name: 'Colectomy', units: 10 },
    { name: 'Mastectomy', units: 6 },
    { name: 'Hysterectomy', units: 8 },
    { name: 'Cystoscopy', units: 3 },
    { name: 'TURP', units: 5 },
    { name: 'Carotid Endarterectomy', units: 10 },
    { name: 'Spinal Fusion', units: 13 },
    { name: 'Whipple', units: 20 },
    { name: 'AAA Repair', units: 15 },
    { name: 'Colonoscopy', units: 4 },
    { name: 'EGD', units: 5 },
    { name: 'Tonsillectomy', units: 5 },
    { name: 'Shoulder Arthroscopy', units: 4 },
    { name: 'Carpal Tunnel Release', units: 3 }
  ];

  const physStatuses = ['P1','P2','P2','P2','P3','P3','P3','P3','P4','P4'];
  const nerveBlocks = ['none','none','none','none','none','brachial_plexus','other'];
  const rand = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
  const pick = arr => arr[rand(0, arr.length - 1)];
  const pad2 = n => String(n).padStart(2, '0');
  const fmtDate = d => `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`;
  const fmtTime = (h, m) => `${pad2(h)}:${pad2(m)}`;

  // Weekday schedule patterns (weighted distribution)
  const weekdaySchedules = [
    { type: 'OR', weight: 40 },
    { type: 'OB_restricted', weight: 8 },
    { type: 'SF1', weight: 8 },
    { type: 'SF2', weight: 5 },
    { type: 'endo', weight: 6 },
    { type: 'NORA', weight: 5 },
    { type: 'ACS', weight: 3 },
    { type: 'cardiac_liver', weight: 3 },
    { type: 'mole', weight: 4 },
    { type: '1st_call', weight: 6 },
    { type: '2nd_call', weight: 4 },
    { type: '3rd_call', weight: 3 },
    { type: 'CRNA_supervision', weight: 5 }
  ];

  const weekendSchedules = [
    { type: 'OB_restricted', weight: 25 },
    { type: '1st_call', weight: 25 },
    { type: '2nd_call', weight: 20 },
    { type: '4th_call', weight: 15 },
    { type: 'cardiac_liver', weight: 10 },
    { type: '3rd_call', weight: 5 }
  ];

  function pickWeighted(items) {
    const total = items.reduce((s, i) => s + i.weight, 0);
    let r = Math.random() * total;
    for (const item of items) {
      r -= item.weight;
      if (r <= 0) return item.type;
    }
    return items[items.length - 1].type;
  }

  function getShiftTimes(aType, isWeekend) {
    switch (aType) {
      case 'OR': return { start: '07:10', end: fmtTime(rand(15,17), rand(0,3)*15) };
      case 'OB_restricted':
        if (isWeekend) return { start: '07:00', end: '19:00' };
        return rand(0,1) ? { start: '07:00', end: '19:00' } : { start: '19:00', end: '07:00' };
      case 'SF1': return { start: '07:00', end: fmtTime(rand(14,17), rand(0,3)*15) };
      case 'SF2': return { start: '07:00', end: fmtTime(rand(13,16), rand(0,3)*15) };
      case 'endo': return { start: '07:00', end: fmtTime(rand(13,15), rand(0,3)*15) };
      case 'NORA': return { start: '07:00', end: fmtTime(rand(14,16), 0) };
      case 'ACS': return { start: '07:00', end: fmtTime(rand(15,17), rand(0,3)*15) };
      case 'cardiac_liver': return { start: '07:00', end: fmtTime(rand(15,18), rand(0,3)*15) };
      case 'mole': return { start: '07:00', end: fmtTime(rand(15,17), rand(0,3)*15) };
      case '1st_call': case '2nd_call': case '3rd_call':
        if (isWeekend) return { start: '07:00', end: '07:00' };
        return { start: '17:00', end: fmtTime(rand(22,23), rand(0,3)*15) };
      case '4th_call': return { start: '07:00', end: '07:00' };
      case 'CRNA_supervision': return { start: '07:00', end: fmtTime(rand(15,17), 0) };
      default: return { start: '07:00', end: '17:00' };
    }
  }

  // Generate call shifts with multiple time entries
  function makeTimeEntries(aType, baseTimes, isWeekend) {
    if (['1st_call','2nd_call','3rd_call','4th_call'].includes(aType)) {
      // Call shifts: sometimes multiple call-ins
      const numEntries = rand(1,3);
      if (numEntries === 1) return [{ start: baseTimes.start, end: baseTimes.end }];
      const entries = [];
      if (isWeekend) {
        // Weekend call: scattered through 24hr period
        const starts = [rand(8,10), rand(13,15), rand(19,21)].slice(0, numEntries).sort((a,b)=>a-b);
        for (const h of starts) {
          const dur = rand(1,3);
          entries.push({ start: fmtTime(h, rand(0,3)*15), end: fmtTime(h+dur, rand(0,3)*15) });
        }
      } else {
        // Weekday evening call
        const starts = [17, rand(19,20), rand(21,22)].slice(0, numEntries);
        for (const h of starts) {
          const dur = rand(1,2);
          entries.push({ start: fmtTime(h, rand(0,3)*15), end: fmtTime(Math.min(h+dur,23), rand(0,3)*15) });
        }
      }
      return entries;
    }
    return [{ start: baseTimes.start, end: baseTimes.end }];
  }

  // Track which dates already have shifts to avoid overwriting
  const existingDates = new Set(Object.keys(data.shifts));

  // Generate data day by day
  const cur = new Date(threeMonthsAgo);
  while (cur <= yesterday) {
    const dateStr = fmtDate(cur);
    const dow = cur.getDay();
    const isWeekend = dow === 0 || dow === 6;

    // Skip ~20% of weekdays (days off), skip ~60% of weekends
    if (!existingDates.has(dateStr)) {
      const workChance = isWeekend ? 0.4 : 0.8;
      if (Math.random() < workChance) {
        const aType = isWeekend ? pickWeighted(weekendSchedules) : pickWeighted(weekdaySchedules);
        const baseTimes = getShiftTimes(aType, isWeekend);
        const timeEntries = makeTimeEntries(aType, baseTimes, isWeekend);

        const shift = {
          date: dateStr,
          assignmentType: aType,
          startTime: timeEntries[0].start,
          endTime: timeEntries[timeEntries.length - 1].end,
          timeEntries: timeEntries,
          isHoliday: false,
          forcedOff: false,
          subspecCoverage: false,
          teeCount: 0,
          supervisionStart: '',
          supervisionEnd: '',
          preCallStart: '',
          preCallEnd: '',
          tempCoverage: []
        };

        // CRNA supervision: add supervision times
        if (aType === 'CRNA_supervision') {
          shift.supervisionStart = timeEntries[0].start;
          shift.supervisionEnd = timeEntries[0].end;
        }

        // OR/SF1/SF2 occasionally get CRNA supervision overlay
        if (['OR','SF1','SF2'].includes(aType) && Math.random() < 0.1) {
          shift.supervisionStart = timeEntries[0].start;
          shift.supervisionEnd = fmtTime(rand(10,12), 0);
        }

        // Random temp coverage on pager-eligible shifts (~8%)
        if (getPagerPayWindow(aType, isWeekend) !== null && Math.random() < 0.08) {
          const tcType = Math.random() < 0.5 ? 'covered' : 'covering';
          const tcStartHr = rand(17, 20);
          const tcEndHr = Math.min(tcStartHr + rand(1, 3), 23);
          const tcEntry = { type: tcType, start: fmtTime(tcStartHr, 0), end: fmtTime(tcEndHr, 0), timeEntries: [] };
          if (tcType === 'covering') {
            tcEntry.timeEntries = [{ start: fmtTime(tcStartHr, 15), end: fmtTime(tcEndHr - 1 < tcStartHr ? tcStartHr + 1 : tcEndHr, 45) }];
          }
          shift.tempCoverage = [tcEntry];
        }

        data.shifts[dateStr] = shift;

        // Generate cases for this shift
        if (aType !== 'CRNA_supervision') {
          generateCasesForShift(dateStr, aType, timeEntries, isWeekend, procedures, physStatuses, nerveBlocks);
        }
      }
    }

    cur.setDate(cur.getDate() + 1);
  }
}

function generateCasesForShift(dateStr, aType, timeEntries, isWeekend, procedures, physStatuses, nerveBlocks) {
  const rand = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
  const pick = arr => arr[rand(0, arr.length - 1)];
  const pad2 = n => String(n).padStart(2, '0');
  const fmtTime = (h, m) => `${pad2(h)}:${pad2(m)}`;

  // Determine number of cases based on shift type
  let numCases;
  switch (aType) {
    case 'OR': numCases = rand(3, 6); break;
    case 'OB_restricted': numCases = rand(1, 4); break;
    case 'SF1': case 'SF2': numCases = rand(2, 5); break;
    case 'endo': numCases = rand(4, 8); break;
    case 'NORA': numCases = rand(3, 6); break;
    case 'ACS': numCases = rand(2, 5); break;
    case 'cardiac_liver': numCases = rand(1, 3); break;
    case 'mole': numCases = rand(2, 4); break;
    case '1st_call': case '2nd_call': case '3rd_call': case '4th_call':
      numCases = rand(0, 3); break;
    default: numCases = rand(2, 4);
  }

  // For endo shifts, mostly colonoscopies/EGDs
  const endoProcs = [
    { name: 'Colonoscopy', units: 4 },
    { name: 'EGD', units: 5 },
    { name: 'EGD + Colonoscopy', units: 5 },
    { name: 'Colonoscopy', units: 4 },
    { name: 'Colonoscopy', units: 4 }
  ];

  // Decide if we should include special case types
  const includeLabor = ['OB_restricted'].includes(aType) && Math.random() < 0.6;
  const includeAPS = Math.random() < 0.08;

  // Use first time entry start as case time baseline
  const entryStart = timeEntries[0].start;
  let caseHour = parseInt(entryStart.split(':')[0]);
  let caseMin = parseInt(entryStart.split(':')[1]) + rand(10, 30);
  if (caseMin >= 60) { caseHour++; caseMin -= 60; }

  for (let i = 0; i < numCases; i++) {
    const startH = caseHour;
    const startM = caseMin;

    // Determine case type
    let caseType = 'standard';
    if (i === 0 && includeLabor) caseType = 'labor_epidural';
    else if (i === numCases - 1 && includeAPS) caseType = 'aps_rounding';

    const c = {
      id: genId() + '_' + i + '_' + dateStr.replace(/-/g,''),
      shiftDate: dateStr,
      caseType: caseType,
      timestamp: new Date().toISOString()
    };

    if (caseType === 'standard') {
      const proc = aType === 'endo' ? pick(endoProcs) : pick(procedures);
      const duration = aType === 'endo' ? rand(15, 35) : rand(30, 180);
      const endTotalMin = startH * 60 + startM + duration;
      const endH = Math.min(Math.floor(endTotalMin / 60), 23);
      const endM = endTotalMin % 60;

      c.procedure = proc.name;
      c.baseUnits = proc.units;
      c.physicalStatus = pick(physStatuses);
      c.startTime = fmtTime(startH, startM);
      c.endTime = fmtTime(endH, endM);
      c.isEmergency = Math.random() < 0.05;
      c.isMedicalProc = false;
      c.medicalUnits = 0;
      c.isAcutePain = false;
      c.acutePainUnits = 0;
      c.isHighRiskPeds = Math.random() < 0.03;
      c.isORCase = ['SF1','SF2'].includes(aType) ? (Math.random() < 0.3) : false;
      c.nerveBlock = pick(nerveBlocks);
      c.hasCentralLine = Math.random() < 0.08;
      c.hasArterialLine = Math.random() < 0.12;
      c.hasPAC = Math.random() < 0.05;
      c.hasTEEAddOn = aType === 'cardiac_liver' ? (Math.random() < 0.3) : (Math.random() < 0.02);
      c.hasITMorphine = Math.random() < 0.06;
      c.isSharedCase = Math.random() < 0.08;
      c.sharedStartupPct = c.isSharedCase ? pick([50, 50, 50, 25, 75]) : 50;
      c.epiduralRounds = 0;
      c.painRounds = 0;
      c.notes = '';

      // Advance time for next case
      caseHour = endH;
      caseMin = endM + rand(10, 30);
      if (caseMin >= 60) { caseHour++; caseMin -= 60; }

    } else if (caseType === 'labor_epidural') {
      const duration = rand(60, 480);
      const endTotalMin = startH * 60 + startM + duration;
      const endH = Math.min(Math.floor(endTotalMin / 60), 23);
      const endM = endTotalMin % 60;

      c.procedure = 'Labor Epidural';
      c.baseUnits = '';
      c.physicalStatus = pick(['P1','P2','P2','P2','P3']);
      c.startTime = fmtTime(startH, startM);
      c.endTime = fmtTime(endH, endM);
      c.isEmergency = false;
      c.isMedicalProc = false;
      c.medicalUnits = 0;
      c.isAcutePain = false;
      c.acutePainUnits = 0;
      c.isHighRiskPeds = false;
      c.isORCase = false;
      c.nerveBlock = 'none';
      c.hasCentralLine = false;
      c.hasArterialLine = false;
      c.hasPAC = false;
      c.hasTEEAddOn = false;
      c.epiduralRounds = 0;
      c.painRounds = 0;
      c.notes = '';

      caseHour = endH;
      caseMin = endM + rand(10, 30);
      if (caseMin >= 60) { caseHour++; caseMin -= 60; }

    } else if (caseType === 'aps_rounding') {
      c.procedure = 'APS Rounding';
      c.baseUnits = '';
      c.physicalStatus = '';
      c.startTime = '';
      c.endTime = '';
      c.isEmergency = false;
      c.isMedicalProc = false;
      c.medicalUnits = 0;
      c.isAcutePain = false;
      c.acutePainUnits = 0;
      c.isHighRiskPeds = false;
      c.isORCase = false;
      c.nerveBlock = 'none';
      c.hasCentralLine = false;
      c.hasArterialLine = false;
      c.hasPAC = false;
      c.hasTEEAddOn = false;
      c.epiduralRounds = rand(2, 8);
      c.painRounds = rand(1, 6);
      c.notes = '';
    }

    data.cases.push(c);
  }
}

function downloadFile(content, filename, type) {
  const blob = new Blob([content], { type });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
}

// ================================================================
// SETTINGS
// ================================================================
const nameInput = document.getElementById('settingsName');
nameInput.value = settings.name || '';
nameInput.addEventListener('change', () => {
  settings.name = nameInput.value;
  saveSettings(settings);
  showToast('Name saved');
});

const pointValueInput = document.getElementById('settingsPointValue');
const dashPointValueInput = document.getElementById('dashPointValue');
pointValueInput.value = settings.pointValue || '';
dashPointValueInput.value = settings.pointValue || '';

function syncPointValue(source) {
  settings.pointValue = parseFloat(source.value) || 0;
  saveSettings(settings);
  // Keep both inputs in sync
  pointValueInput.value = source.value;
  dashPointValueInput.value = source.value;
  // Re-render projections that depend on $/pt
  renderStabilization();
  renderProjectedAnnual();
  renderMonthlyPace();
  renderPipelineChart();
  renderMonthlyChart();
}

pointValueInput.addEventListener('change', () => {
  syncPointValue(pointValueInput);
  showToast('Point value saved');
});

dashPointValueInput.addEventListener('change', () => {
  syncPointValue(dashPointValueInput);
  showToast('Point value saved');
});

// December advance paycheck toggle
const decAdvToggle = document.getElementById('decAdvanceToggle');
decAdvToggle.checked = settings.decemberAdvance !== false;
decAdvToggle.addEventListener('change', () => {
  settings.decemberAdvance = decAdvToggle.checked;
  saveSettings(settings);
  renderStabilization();
  renderPipelineChart();
});

document.getElementById('pipelineProjectToggle').addEventListener('change', () => {
  renderPipelineChart();
});

// ================================================================
// HEADER POINTS
// ================================================================
function updateHeaderPoints() {
  const date = workingDate;
  const shift = data.shifts[date];
  const dailyPts = shift ? calcShiftTotal(shift).total : 0;
  // Monthly total
  const prefix = date.substring(0, 7);
  let monthPts = 0;
  const monthShifts = [];
  Object.values(data.shifts).forEach(s => {
    if (s.date && s.date.startsWith(prefix)) {
      monthPts += calcShiftTotal(s).total;
      monthShifts.push(s);
    }
  });
  monthPts = round2(monthPts);

  // Pace calculation — how far ahead/behind prior month average
  let paceHtml = '';
  const now = new Date();
  const thisPrefix = now.getFullYear() + '-' + String(now.getMonth() + 1).padStart(2, '0');
  if (prefix === thisPrefix) {
    const dayOfMonth = now.getDate();
    const daysInMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0).getDate();
    const vacDays = monthShifts.filter(s => s.assignmentType === 'vacation');
    const vacDaysPassed = vacDays.filter(s => parseInt(s.date.split('-')[2]) <= dayOfMonth).length;
    const workingDaysInMonth = daysInMonth - vacDays.length;
    const workingDaysElapsed = dayOfMonth - vacDaysPassed;
    const vacRatio = workingDaysInMonth / daysInMonth;

    const mt = getMonthlyTotals();
    let sumAtDay = 0;
    let curveCount = 0;
    for (let offset = 1; offset <= 6; offset++) {
      const d = new Date(now.getFullYear(), now.getMonth() - offset, 1);
      const key = d.getFullYear() + '-' + String(d.getMonth() + 1).padStart(2, '0');
      if (!mt[key]) continue;
      const mDays = new Date(d.getFullYear(), d.getMonth() + 1, 0).getDate();
      const shifts = Object.values(data.shifts).filter(s => s.date.startsWith(key));
      if (shifts.length === 0) continue;
      const dailyP = new Array(mDays + 1).fill(0);
      shifts.forEach(s => { dailyP[parseInt(s.date.split('-')[2])] += calcShiftTotal(s).total; });
      const cum = new Array(mDays + 1).fill(0);
      for (let i = 1; i <= mDays; i++) cum[i] = cum[i - 1] + dailyP[i];
      const frac = workingDaysInMonth > 0 ? workingDaysElapsed / workingDaysInMonth : 0;
      const mapped = frac * mDays;
      const lo = Math.floor(mapped);
      const hi = Math.min(Math.ceil(mapped), mDays);
      const f = mapped - lo;
      sumAtDay += lo >= 1 ? cum[lo] * (1 - f) + cum[hi] * f : cum[hi] * f;
      curveCount++;
    }
    if (curveCount > 0) {
      const expected = round2((sumAtDay / curveCount) * vacRatio);
      const delta = round2(monthPts - expected);
      const cls = delta >= 0 ? 'ahead' : 'behind';
      const sign = delta >= 0 ? '+' : '';
      paceHtml = `<span class="pace ${cls}">${sign}${delta.toFixed(0)} pace</span>`;
    }
  }

  const el = document.getElementById('headerPoints');
  el.innerHTML = `<span class="daily">${dailyPts.toFixed(1)} pts</span><br><span class="monthly">${monthPts.toFixed(0)} mo</span>` + (paceHtml ? `<br>${paceHtml}` : '');
}

// ================================================================
// RECONCILE PAGE — Tab switching
// ================================================================
// Main reconcile tabs
document.querySelectorAll('#page-reconcile > .tab-bar > .tab-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('#page-reconcile > .tab-bar > .tab-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    document.getElementById('rtab-qgenda').classList.toggle('hidden', btn.dataset.rtab !== 'qgenda');
    document.getElementById('rtab-production').classList.toggle('hidden', btn.dataset.rtab !== 'production');
  });
});


function renderReconTabs() {
  updateReconMonthLabels();
}

// ================================================================
// QGENDA RECONCILIATION
// ================================================================
let qgendaData = [];
let qYear = new Date().getFullYear();
let qMonth = new Date().getMonth();
let shiftReconDiffs = [];
let shiftReconCurrentDiff = 0;
let shiftReconDecisions = {};

function loadShiftReconDecisions() {
  try {
    const raw = localStorage.getItem(SHIFT_RECON_DECISIONS_KEY);
    if (raw) shiftReconDecisions = JSON.parse(raw);
  } catch(e) { shiftReconDecisions = {}; }
}
function saveShiftReconDecisions() {
  localStorage.setItem(SHIFT_RECON_DECISIONS_KEY, JSON.stringify(shiftReconDecisions));
}

function updateReconMonthLabels() {
  const mn = ['January','February','March','April','May','June','July','August','September','October','November','December'];
  document.getElementById('qMonthLabel').textContent = `${mn[qMonth]} ${qYear}`;
  document.getElementById('pMonthLabel').textContent = `${mn[pMonth]} ${pYear}`;
}

document.getElementById('qPrevMonth').addEventListener('click', () => { qMonth--; if (qMonth < 0) { qMonth = 11; qYear--; } updateReconMonthLabels(); renderQgendaRecon(); });
document.getElementById('qNextMonth').addEventListener('click', () => { qMonth++; if (qMonth > 11) { qMonth = 0; qYear++; } updateReconMonthLabels(); renderQgendaRecon(); });

// Upload area
document.getElementById('qgendaUploadArea').addEventListener('click', () => document.getElementById('qgendaFile').click());

function processQgendaRows(rows) {
  qgendaData = rows.map(r => {
    let schedDate = parseExcelDate(r['Schedule Date']);
    let clockInDate = parseExcelDate(r['Effective Clock In Date']);
    let clockOutDate = parseExcelDate(r['Effective Clock Out Date']);
    return {
      scheduleDate: schedDate,
      clockInDate: clockInDate,
      clockInTime: parseExcelTime(r['Effective Clock In Time']),
      clockOutDate: clockOutDate,
      clockOutTime: parseExcelTime(r['Effective Clock Out Time']),
      duration: parseFloat(r['Duration']) || 0,
      task: String(r['Scheduled Task Abbreviation'] || ''),
      location: String(r['Location Name'] || ''),
      notes: String(r['Notes'] || '')
    };
  });
  localStorage.setItem(QGENDA_KEY, JSON.stringify(qgendaData));
  showToast(`Loaded ${qgendaData.length} QGenda entries`);
  if (qgendaData.length > 0 && qgendaData[0].scheduleDate) {
    const d = new Date(qgendaData[0].scheduleDate + 'T12:00:00');
    if (!isNaN(d)) { qYear = d.getFullYear(); qMonth = d.getMonth(); updateReconMonthLabels(); }
  }
  renderQgendaRecon();
}

function parseCSVRows(text) {
  const lines = text.split('\n').map(l => l.trim()).filter(l => l);
  if (lines.length < 2) return [];
  // Parse header row — handle quoted fields
  const parseCSVLine = (line) => {
    const fields = [];
    let current = '', inQuotes = false;
    for (let i = 0; i < line.length; i++) {
      const ch = line[i];
      if (ch === '"') { inQuotes = !inQuotes; }
      else if (ch === ',' && !inQuotes) { fields.push(current.trim()); current = ''; }
      else { current += ch; }
    }
    fields.push(current.trim());
    return fields;
  };
  const headers = parseCSVLine(lines[0]);
  const rows = [];
  for (let i = 1; i < lines.length; i++) {
    const vals = parseCSVLine(lines[i]);
    const obj = {};
    headers.forEach((h, idx) => { obj[h] = vals[idx] || ''; });
    rows.push(obj);
  }
  return rows;
}

document.getElementById('qgendaFile').addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const isImage = /\.(png|jpg|jpeg)$/i.test(file.name);
  const isCSV = /\.csv$/i.test(file.name);

  if (isImage) {
    try {
      showToast('Running OCR on image...');
      const text = await ocrImage(file);
      qgendaData = parseQgendaScreenshot(text);
      localStorage.setItem(QGENDA_KEY, JSON.stringify(qgendaData));
      showToast(`OCR found ${qgendaData.length} QGenda entries`);
      if (qgendaData.length > 0 && qgendaData[0].scheduleDate) {
        const d = new Date(qgendaData[0].scheduleDate + 'T12:00:00');
        if (!isNaN(d)) { qYear = d.getFullYear(); qMonth = d.getMonth(); updateReconMonthLabels(); }
      }
      renderQgendaRecon();
    } catch(err) {
      showToast('OCR error: ' + err.message);
    }
  } else if (isCSV) {
    const reader = new FileReader();
    reader.onload = (ev) => {
      try {
        const rows = parseCSVRows(ev.target.result);
        processQgendaRows(rows);
      } catch(err) {
        showToast('Error reading CSV: ' + err.message);
      }
    };
    reader.readAsText(file);
  } else {
    const reader = new FileReader();
    reader.onload = (ev) => {
      try {
        const wb = XLSX.read(ev.target.result, { type: 'array' });
        const ws = wb.Sheets[wb.SheetNames[0]];
        const rows = XLSX.utils.sheet_to_json(ws, { defval: '' });
        processQgendaRows(rows);
      } catch(err) {
        showToast('Error reading QGenda file: ' + err.message);
      }
    };
    reader.readAsArrayBuffer(file);
  }
  e.target.value = '';
});

function parseExcelDate(val) {
  if (!val && val !== 0) return '';
  // Excel serial number
  if (typeof val === 'number') {
    const d = new Date((val - 25569) * 86400 * 1000);
    return d.getUTCFullYear() + '-' + String(d.getUTCMonth()+1).padStart(2,'0') + '-' + String(d.getUTCDate()).padStart(2,'0');
  }
  // String like "1/2/2026" or "2026-01-02"
  const s = String(val).trim();
  if (s.includes('-') && s.length === 10) return s; // already YYYY-MM-DD
  const parts = s.split('/');
  if (parts.length === 3) {
    let [m, d, y] = parts.map(Number);
    if (y < 100) y += 2000;
    return y + '-' + String(m).padStart(2,'0') + '-' + String(d).padStart(2,'0');
  }
  return s;
}

function parseExcelTime(val) {
  if (!val && val !== 0) return '';
  // Excel fractional day (0.0 to ~1.0) or full serial date-time (extract fractional part)
  if (typeof val === 'number') {
    const frac = val >= 1 ? val - Math.floor(val) : val;
    const totalMin = Math.round(frac * 1440);
    const h = Math.floor(totalMin / 60) % 24;
    const m = totalMin % 60;
    return String(h).padStart(2,'0') + ':' + String(m).padStart(2,'0');
  }
  // String like "7:00" or "13:01"
  const s = String(val).trim();
  if (s.includes(':')) {
    const [h, m] = s.split(':').map(Number);
    return String(h).padStart(2,'0') + ':' + String(m || 0).padStart(2,'0');
  }
  return s;
}

function renderQgendaRecon() {
  // Load cached data if needed
  if (qgendaData.length === 0) {
    try {
      const cached = localStorage.getItem(QGENDA_KEY);
      if (cached) qgendaData = JSON.parse(cached);
    } catch(e) {}
  }
  loadShiftReconDecisions();

  const container = document.getElementById('qgendaResults');
  const prefix = `${qYear}-${String(qMonth+1).padStart(2,'0')}`;

  // Filter QGenda entries for month (by Schedule Date)
  const qEntries = qgendaData.filter(e => e.scheduleDate && e.scheduleDate.startsWith(prefix));
  const trackerShifts = Object.values(data.shifts).filter(s => s.date.startsWith(prefix));

  if (qgendaData.length === 0) {
    container.innerHTML = '<div class="empty-state"><p>Upload a QGenda export file to begin reconciliation.</p></div>';
    return;
  }

  if (qEntries.length === 0 && trackerShifts.length === 0) {
    container.innerHTML = '<div class="empty-state"><p>No data for this month in QGenda or Tracker.</p></div>';
    return;
  }

  // Group QGenda by schedule date
  const qByDate = {};
  qEntries.forEach(e => {
    if (!qByDate[e.scheduleDate]) qByDate[e.scheduleDate] = [];
    qByDate[e.scheduleDate].push(e);
  });

  // Get all unique dates
  const allDates = new Set([...Object.keys(qByDate), ...trackerShifts.map(s => s.date)]);
  const sortedDates = [...allDates].sort();

  // Build diffs and totals
  let qTotalHours = 0;
  let tTotalHours = 0;
  let matchCount = 0;
  shiftReconDiffs = [];

  sortedDates.forEach(date => {
    const qDay = qByDate[date] || [];
    const tShift = data.shifts[date];

    const qHours = qDay.reduce((s, e) => s + e.duration, 0);
    qTotalHours += qHours;

    let tHours = 0;
    if (tShift) {
      tHours = calcShiftHours(tShift);
      tTotalHours += tHours;
    }

    // Determine QGenda assignment info
    const qTask = qDay.length > 0 ? qDay[0].task : '';
    const qAssignType = qTask ? mapTaskToAssignmentType(qTask, date) : '';
    const tAssignType = tShift ? tShift.assignmentType : '';

    // Build QGenda time entries for potential shift creation/update
    const sortedQ = [...qDay].filter(e => e.clockInTime).sort((a, b) => a.clockInTime.localeCompare(b.clockInTime));
    const qTimeEntries = sortedQ.map(e => ({ start: e.clockInTime, end: e.clockOutTime || '' }));

    if (qDay.length > 0 && tShift) {
      const hourDiff = Math.abs(qHours - tHours);
      if (hourDiff <= 0.25 && qAssignType === tAssignType) {
        matchCount++;
      } else if (hourDiff > 0.25) {
        shiftReconDiffs.push({
          date, type: 'hour_mismatch',
          qgendaEntries: qDay, qgendaHours: qHours, qgendaTask: qTask,
          qgendaAssignmentType: qAssignType, qgendaTimeEntries: qTimeEntries,
          trackerShift: tShift, trackerHours: tHours, trackerAssignmentType: tAssignType,
          hourDiff
        });
      } else {
        shiftReconDiffs.push({
          date, type: 'type_mismatch',
          qgendaEntries: qDay, qgendaHours: qHours, qgendaTask: qTask,
          qgendaAssignmentType: qAssignType, qgendaTimeEntries: qTimeEntries,
          trackerShift: tShift, trackerHours: tHours, trackerAssignmentType: tAssignType,
          hourDiff: hourDiff
        });
      }
    } else if (qDay.length > 0 && !tShift) {
      shiftReconDiffs.push({
        date, type: 'missing_tracker',
        qgendaEntries: qDay, qgendaHours: qHours, qgendaTask: qTask,
        qgendaAssignmentType: qAssignType, qgendaTimeEntries: qTimeEntries,
        trackerShift: null, trackerHours: 0, trackerAssignmentType: '',
        hourDiff: qHours
      });
    } else if (qDay.length === 0 && tShift) {
      shiftReconDiffs.push({
        date, type: 'missing_qgenda',
        qgendaEntries: [], qgendaHours: 0, qgendaTask: '',
        qgendaAssignmentType: '', qgendaTimeEntries: [],
        trackerShift: tShift, trackerHours: tHours, trackerAssignmentType: tAssignType,
        hourDiff: tHours
      });
    }
  });

  // Clamp stepper index
  if (shiftReconCurrentDiff >= shiftReconDiffs.length) shiftReconCurrentDiff = Math.max(0, shiftReconDiffs.length - 1);

  // Calculate tracker points for the month
  let tTotalPoints = 0;
  trackerShifts.forEach(s => {
    const t = calcShiftTotal(s);
    tTotalPoints += t.total;
  });
  tTotalPoints = round2(tTotalPoints);

  // Summary card
  const issueCount = shiftReconDiffs.length;
  let html = '<div class="card"><h2>Summary</h2><div class="summary-grid">';
  html += `<div class="summary-item"><div class="label">QGenda Hours</div><div class="value blue">${qTotalHours.toFixed(1)}</div></div>`;
  html += `<div class="summary-item"><div class="label">Tracker Hours</div><div class="value green">${tTotalHours.toFixed(1)}</div></div>`;
  html += `<div class="summary-item"><div class="label">Tracker Points</div><div class="value green">${tTotalPoints.toFixed(1)}</div></div>`;
  html += `<div class="summary-item"><div class="label">Matched</div><div class="value green">${matchCount}</div></div>`;
  html += `<div class="summary-item"><div class="label">Issues</div><div class="value" style="color:var(--danger)">${issueCount}</div></div>`;
  html += '</div></div>';

  if (issueCount === 0) {
    html += '<div class="card" style="text-align:center;padding:24px;"><p style="color:var(--accent);font-size:1.1rem;font-weight:600;">All shifts match!</p></div>';
  } else {
    html += '<div id="shiftReconStepperContainer"></div>';
    html += '<div id="shiftReconFlaggedSection"></div>';
  }

  container.innerHTML = html;

  if (issueCount > 0) {
    renderShiftReconStepper();
    renderShiftReconFlagged();
  }
}

// ================================================================
// QGENDA SHIFT RECON — INTERACTIVE DIFFERENCE REVIEWER
// ================================================================
function renderShiftReconStepper() {
  const container = document.getElementById('shiftReconStepperContainer');
  if (!container || shiftReconDiffs.length === 0) return;

  const d = shiftReconDiffs[shiftReconCurrentDiff];
  const key = d.date;
  const decision = shiftReconDecisions[key];
  const isResolved = decision && (decision.accepted === 'qgenda' || decision.accepted === 'app');
  const isFlagged = decision && decision.flagged;

  let html = `<div class="diff-stepper${isResolved ? ' resolved' : ''}${isFlagged ? ' flagged' : ''}">`;
  html += '<div class="diff-stepper-header">';
  html += `<span class="counter">Difference ${shiftReconCurrentDiff + 1} of ${shiftReconDiffs.length}</span>`;
  html += '<div class="diff-stepper-nav">';
  html += `<button onclick="shiftReconNav(-1)"${shiftReconCurrentDiff === 0 ? ' disabled' : ''}>&larr;</button>`;
  html += `<button onclick="shiftReconNav(1)"${shiftReconCurrentDiff >= shiftReconDiffs.length - 1 ? ' disabled' : ''}>&rarr;</button>`;
  html += '</div></div>';

  html += '<div class="diff-stepper-body">';
  html += `<div class="diff-date">${formatDateShort(d.date)}</div>`;

  // Type label
  const typeLabels = {
    hour_mismatch: 'Hour Mismatch',
    type_mismatch: 'Assignment Type Mismatch',
    missing_tracker: 'Missing from Tracker',
    missing_qgenda: 'Missing from QGenda'
  };
  html += `<div style="font-size:0.75rem;color:var(--accent2);margin-bottom:8px;">${typeLabels[d.type] || d.type}</div>`;

  if (isResolved) {
    html += `<p style="color:var(--accent);font-size:0.85rem;font-weight:600;">Accepted: ${decision.accepted === 'qgenda' ? 'QGenda' : 'App'} value</p>`;
  } else if (isFlagged) {
    html += `<p style="color:var(--accent2);font-size:0.85rem;font-weight:600;">Flagged for office</p>`;
  }

  html += '<div class="diff-compare">';

  // QGenda column
  html += '<div class="diff-col">';
  html += '<h4>QGenda</h4>';
  if (d.qgendaEntries.length > 0) {
    html += `<div class="detail">${escHtml(d.qgendaTask || '-')}</div>`;
    html += `<div class="val">${getAssignmentTypeName(d.qgendaAssignmentType)}</div>`;
    d.qgendaEntries.forEach(e => {
      html += `<div class="detail">${e.clockInTime || '?'} - ${e.clockOutTime || '?'}</div>`;
    });
    html += `<div class="val">${d.qgendaHours.toFixed(1)}h</div>`;
  } else {
    html += '<div class="val" style="color:var(--danger)">No QGenda entry</div>';
  }
  html += '</div>';

  // App column
  html += '<div class="diff-col">';
  html += '<h4>App</h4>';
  if (d.trackerShift) {
    html += `<div class="val">${getAssignmentTypeName(d.trackerAssignmentType)}</div>`;
    const tEntries = d.trackerShift.timeEntries || [{ start: d.trackerShift.startTime, end: d.trackerShift.endTime }];
    tEntries.forEach(e => {
      html += `<div class="detail">${e.start || '?'} - ${e.end || '?'}</div>`;
    });
    html += `<div class="val">${d.trackerHours.toFixed(1)}h</div>`;
    const shiftTotals = calcShiftTotal(d.trackerShift);
    html += `<div class="val" style="font-size:0.8rem;color:var(--accent)">${shiftTotals.total.toFixed(1)} pts</div>`;
  } else {
    html += '<div class="val" style="color:var(--danger)">No shift</div>';
  }
  html += '</div></div>';

  // Action buttons
  if (!isResolved && !isFlagged) {
    html += '<div class="diff-actions">';
    html += `<button class="btn btn-accept-billing" onclick="shiftReconAcceptQgenda(${shiftReconCurrentDiff})">Accept QGenda</button>`;
    if (d.trackerShift) {
      html += `<button class="btn btn-accept-app" onclick="shiftReconAcceptApp(${shiftReconCurrentDiff})">Accept App</button>`;
    }
    html += `<button class="btn btn-flag" onclick="shiftReconFlag(${shiftReconCurrentDiff})">Flag for Office</button>`;
    html += '</div>';
  }

  html += '</div></div>';

  // Progress
  const reviewed = Object.keys(shiftReconDecisions).filter(k => {
    return shiftReconDiffs.some(diff => diff.date === k);
  }).length;
  html += `<p style="font-size:0.75rem;color:var(--text-dim);margin-top:8px;text-align:center;">${reviewed} of ${shiftReconDiffs.length} reviewed</p>`;

  container.innerHTML = html;
}

function shiftReconNav(dir) {
  shiftReconCurrentDiff = Math.max(0, Math.min(shiftReconDiffs.length - 1, shiftReconCurrentDiff + dir));
  renderShiftReconStepper();
}

function shiftReconAcceptQgenda(idx) {
  const d = shiftReconDiffs[idx];

  if (d.type === 'missing_tracker') {
    // Create new shift from QGenda data
    const entries = d.qgendaEntries;
    const sortedEntries = [...entries].filter(e => e.clockInTime).sort((a, b) => a.clockInTime.localeCompare(b.clockInTime));
    const timeEntries = sortedEntries.map(e => ({ start: e.clockInTime, end: e.clockOutTime || '' }));
    let earliest = '23:59', latest = '00:00';
    entries.forEach(e => {
      if (e.clockInTime && e.clockInTime < earliest) earliest = e.clockInTime;
      if (e.clockOutTime && e.clockOutTime > latest) latest = e.clockOutTime;
    });
    const reconAssignType = d.qgendaAssignmentType || 'OR';
    const reconHasPager = getPagerPayWindow(reconAssignType, isWeekend(d.date)) !== null;
    const reconTimeEntries = timeEntries.length > 0
      ? timeEntries
      : reconHasPager ? [] : [{ start: earliest, end: latest }];
    data.shifts[d.date] = {
      date: d.date,
      assignmentType: reconAssignType,
      startTime: timeEntries.length > 0 ? earliest : '',
      endTime: timeEntries.length > 0 ? latest : '',
      timeEntries: reconTimeEntries,
      isHoliday: false,
      forcedOff: false,
      subspecCoverage: false,
      teeCount: 0,
      supervisionStart: '',
      supervisionEnd: '',
      preCallStart: '',
      preCallEnd: '',
      tempCoverage: []
    };
    // Detect pre-call entries in QGenda data
    const pcPattern = /UVH\/SFH\s*WORK/i;
    const pcEntries = entries.filter(e => e.clockInTime && pcPattern.test(e.task || ''));
    if (pcEntries.length > 0 && ['mole','OB_restricted'].includes(reconAssignType)) {
      const sortedPC = [...pcEntries].sort((a, b) => a.clockInTime.localeCompare(b.clockInTime));
      data.shifts[d.date].preCallStart = sortedPC[0].clockInTime;
      data.shifts[d.date].preCallEnd = sortedPC[sortedPC.length - 1].clockOutTime || '';
    }
    showToast(`Created shift for ${formatDateShort(d.date)}`);
  } else if (d.type === 'hour_mismatch' || d.type === 'type_mismatch') {
    // Update existing shift to match QGenda
    const shift = data.shifts[d.date];
    if (shift) {
      if (d.qgendaTimeEntries.length > 0) {
        shift.timeEntries = d.qgendaTimeEntries;
        let earliest = '23:59', latest = '00:00';
        d.qgendaEntries.forEach(e => {
          if (e.clockInTime && e.clockInTime < earliest) earliest = e.clockInTime;
          if (e.clockOutTime && e.clockOutTime > latest) latest = e.clockOutTime;
        });
        shift.startTime = earliest;
        shift.endTime = latest;
      }
      if (d.type === 'type_mismatch' && d.qgendaAssignmentType) {
        shift.assignmentType = d.qgendaAssignmentType;
      }
      showToast(`Updated shift for ${formatDateShort(d.date)}`);
    }
  } else if (d.type === 'missing_qgenda') {
    // QGenda has nothing — accepting QGenda means removing app shift
    delete data.shifts[d.date];
    showToast(`Removed shift for ${formatDateShort(d.date)}`);
  }

  saveData(data);
  updateHeaderPoints();
  shiftReconDecisions[d.date] = { accepted: 'qgenda', flagged: false };
  saveShiftReconDecisions();
  if (shiftReconCurrentDiff < shiftReconDiffs.length - 1) shiftReconCurrentDiff++;
  renderShiftReconStepper();
  renderShiftReconFlagged();
}

function shiftReconAcceptApp(idx) {
  const d = shiftReconDiffs[idx];
  shiftReconDecisions[d.date] = { accepted: 'app', flagged: true };
  saveShiftReconDecisions();
  if (shiftReconCurrentDiff < shiftReconDiffs.length - 1) shiftReconCurrentDiff++;
  renderShiftReconStepper();
  renderShiftReconFlagged();
}

function shiftReconFlag(idx) {
  const d = shiftReconDiffs[idx];
  shiftReconDecisions[d.date] = { accepted: '', flagged: true };
  saveShiftReconDecisions();
  if (shiftReconCurrentDiff < shiftReconDiffs.length - 1) shiftReconCurrentDiff++;
  renderShiftReconStepper();
  renderShiftReconFlagged();
}

function renderShiftReconFlagged() {
  const section = document.getElementById('shiftReconFlaggedSection');
  if (!section) return;

  const mn = ['January','February','March','April','May','June','July','August','September','October','November','December'];
  const monthLabel = `${mn[qMonth]} ${qYear}`;

  // Collect all flagged from decisions
  const allFlagged = [];
  shiftReconDiffs.forEach(d => {
    const dec = shiftReconDecisions[d.date];
    if (dec && dec.flagged) {
      allFlagged.push(d);
    }
  });

  if (allFlagged.length === 0) {
    section.innerHTML = '';
    return;
  }

  let html = '<div class="card"><h2>Flagged Issues (' + allFlagged.length + ')</h2>';
  html += '<ul class="flagged-list">';
  allFlagged.forEach(f => {
    const qTimes = f.qgendaEntries.map(e => `${e.clockInTime || '?'}-${e.clockOutTime || '?'}`).join(', ');
    const tEntries = f.trackerShift && f.trackerShift.timeEntries ? f.trackerShift.timeEntries : (f.trackerShift ? [{ start: f.trackerShift.startTime, end: f.trackerShift.endTime }] : []);
    const tTimes = tEntries.map(e => `${e.start || '?'}-${e.end || '?'}`).join(', ');

    if (f.type === 'missing_tracker') {
      html += `<li>${formatDateShort(f.date)} — Missing from Tracker (QGenda: ${f.qgendaHours.toFixed(1)}h, ${qTimes})</li>`;
    } else if (f.type === 'missing_qgenda') {
      html += `<li>${formatDateShort(f.date)} — Missing from QGenda (App: ${getAssignmentTypeName(f.trackerAssignmentType)}, ${f.trackerHours.toFixed(1)}h)</li>`;
    } else if (f.type === 'type_mismatch') {
      html += `<li>${formatDateShort(f.date)} — Type mismatch: QGenda=${getAssignmentTypeName(f.qgendaAssignmentType)}, App=${getAssignmentTypeName(f.trackerAssignmentType)}</li>`;
    } else {
      html += `<li>${formatDateShort(f.date)} — QGenda: ${f.qgendaHours.toFixed(1)}h, App: ${f.trackerHours.toFixed(1)}h (${f.hourDiff.toFixed(1)}h diff)</li>`;
    }
  });
  html += '</ul>';

  html += '<div style="margin-top:16px;">';
  html += '<button class="btn btn-primary" onclick="generateShiftReconEmail()" style="width:100%;margin-bottom:8px;">Generate Email</button>';
  html += '<div id="shiftReconEmailPreview"></div>';
  html += '</div></div>';

  section.innerHTML = html;
}

function generateShiftReconEmail() {
  const mn = ['January','February','March','April','May','June','July','August','September','October','November','December'];
  const monthLabel = `${mn[qMonth]} ${qYear}`;
  const userName = settings.name || '[Your Name]';

  const allFlagged = [];
  shiftReconDiffs.forEach(d => {
    const dec = shiftReconDecisions[d.date];
    if (dec && dec.flagged) {
      allFlagged.push(d);
    }
  });

  let emailText = `Subject: QGenda Time Discrepancies — ${monthLabel}\n\nHi,\n\nI found the following time discrepancies during QGenda reconciliation for ${monthLabel}:\n\n`;

  allFlagged.forEach((f, i) => {
    const dateFormatted = f.date.replace(/(\d{4})-(\d{2})-(\d{2})/, '$2/$3/$1');
    const qTimes = f.qgendaEntries.map(e => `${e.clockInTime || '?'}-${e.clockOutTime || '?'}`).join(', ');
    const tEntries = f.trackerShift && f.trackerShift.timeEntries ? f.trackerShift.timeEntries : (f.trackerShift ? [{ start: f.trackerShift.startTime, end: f.trackerShift.endTime }] : []);
    const tTimes = tEntries.map(e => `${e.start || '?'}-${e.end || '?'}`).join(', ');

    if (f.type === 'missing_tracker') {
      emailText += `${i + 1}. Date: ${dateFormatted} — QGenda: ${f.qgendaHours.toFixed(1)}h (${qTimes}), not in app\n   Please verify this shift was recorded\n\n`;
    } else if (f.type === 'missing_qgenda') {
      emailText += `${i + 1}. Date: ${dateFormatted} — Shift missing from QGenda (App: ${getAssignmentTypeName(f.trackerAssignmentType)}, ${f.trackerHours.toFixed(1)}h)\n   Please verify this shift was recorded\n\n`;
    } else if (f.type === 'type_mismatch') {
      emailText += `${i + 1}. Date: ${dateFormatted} — Assignment type mismatch: QGenda=${getAssignmentTypeName(f.qgendaAssignmentType)}, App=${getAssignmentTypeName(f.trackerAssignmentType)}\n   App times are correct\n\n`;
    } else {
      emailText += `${i + 1}. Date: ${dateFormatted} — QGenda: ${f.qgendaHours.toFixed(1)}h (${qTimes}), App: ${f.trackerHours.toFixed(1)}h (${tTimes})\n   ${f.hourDiff.toFixed(1)}h difference — app times are correct\n\n`;
    }
  });

  emailText += `Please review and advise.\n\nThanks,\n${userName}`;

  const preview = document.getElementById('shiftReconEmailPreview');
  preview.innerHTML = `<div class="email-preview">${escHtml(emailText)}</div>`;
  preview.innerHTML += '<button class="btn btn-primary" onclick="copyShiftReconEmail()" style="width:100%;margin-top:8px;">Copy to Clipboard</button>';
  preview.dataset.emailText = emailText;
}

function copyShiftReconEmail() {
  const preview = document.getElementById('shiftReconEmailPreview');
  const text = preview.dataset.emailText || '';
  navigator.clipboard.writeText(text).then(() => {
    showToast('Email copied to clipboard!');
  }).catch(() => {
    showToast('Failed to copy — try selecting and copying manually');
  });
}

// ================================================================
// PRODUCTION RECONCILIATION (PDF)
// ================================================================
let prodData = [];
let pYear = new Date().getFullYear();
let pMonth = new Date().getMonth();

document.getElementById('pPrevMonth').addEventListener('click', () => { pMonth--; if (pMonth < 0) { pMonth = 11; pYear--; } updateReconMonthLabels(); renderProdRecon(); });
document.getElementById('pNextMonth').addEventListener('click', () => { pMonth++; if (pMonth > 11) { pMonth = 0; pYear++; } updateReconMonthLabels(); renderProdRecon(); });

document.getElementById('prodUploadArea').addEventListener('click', () => document.getElementById('prodFile').click());

document.getElementById('prodFile').addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const isImage = /\.(png|jpg|jpeg)$/i.test(file.name);

  try {
    let allText = '';
    if (isImage) {
      showToast('Running OCR on image...');
      allText = await ocrImage(file);
      // Normalize OCR output: replace multiple spaces with tab for parseProdText
      allText = allText.split('\n').map(line => line.replace(/\s{2,}/g, '\t')).join('\n');
    } else {
      showToast('Parsing PDF...');
      allText = await extractPDFText(file);
    }

    prodData = parseProdText(allText);
    localStorage.setItem(PROD_KEY, JSON.stringify(prodData));
    showToast(`Loaded ${prodData.length} billing cases`);

    if (prodData.length > 0 && prodData[0].date) {
      const d = new Date(prodData[0].date + 'T12:00:00');
      if (!isNaN(d)) { pYear = d.getFullYear(); pMonth = d.getMonth(); updateReconMonthLabels(); }
    }
    renderProdRecon();
  } catch(err) {
    showToast('Error reading file: ' + err.message);
    console.error(err);
  }
  e.target.value = '';
});

// ================================================================
// TESSERACT OCR
// ================================================================
function loadTesseract() {
  if (window.Tesseract) return Promise.resolve();
  return new Promise((resolve, reject) => {
    const s = document.createElement('script');
    s.src = 'https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js';
    s.onload = resolve;
    s.onerror = () => reject(new Error('Failed to load Tesseract.js'));
    document.head.appendChild(s);
  });
}

async function ocrImage(file) {
  await loadTesseract();
  const worker = await Tesseract.createWorker('eng');
  const { data } = await worker.recognize(file);
  await worker.terminate();
  return data.text;
}

async function extractPDFText(file) {
  if (!window.pdfjsLib) {
    const pdfjs = await import('https://cdn.jsdelivr.net/npm/pdfjs-dist@4.0.379/build/pdf.mjs');
    window.pdfjsLib = pdfjs;
    pdfjs.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@4.0.379/build/pdf.worker.mjs';
  }
  const arrayBuffer = await file.arrayBuffer();
  const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;

  // First try native text extraction
  let allText = '';
  for (let i = 1; i <= pdf.numPages; i++) {
    const page = await pdf.getPage(i);
    const textContent = await page.getTextContent();
    const items = textContent.items;
    const rows = {};
    items.forEach(item => {
      const y = Math.round(item.transform[5]);
      if (!rows[y]) rows[y] = [];
      rows[y].push({ x: item.transform[4], text: item.str });
    });
    const sortedYs = Object.keys(rows).map(Number).sort((a, b) => b - a);
    sortedYs.forEach(y => {
      const row = rows[y].sort((a, b) => a.x - b.x);
      allText += row.map(r => r.text).join('\t') + '\n';
    });
  }

  // Check if we got meaningful text (at least one date-like pattern)
  const hasContent = /\d{1,2}\/\d{1,2}\/\d{2,4}/.test(allText);
  if (hasContent) return allText;

  // Fallback: render pages to canvas and OCR each one
  showToast('Image-based PDF detected, running OCR...');
  await loadTesseract();
  const worker = await Tesseract.createWorker('eng');
  let ocrText = '';

  for (let i = 1; i <= pdf.numPages; i++) {
    showToast(`OCR page ${i} of ${pdf.numPages}...`);
    const page = await pdf.getPage(i);
    const viewport = page.getViewport({ scale: 2.0 });
    const canvas = document.createElement('canvas');
    canvas.width = viewport.width;
    canvas.height = viewport.height;
    const ctx = canvas.getContext('2d');
    await page.render({ canvasContext: ctx, viewport }).promise;
    const { data } = await worker.recognize(canvas);
    ocrText += data.text + '\n';
  }

  await worker.terminate();
  // Normalize OCR output: replace multiple spaces with tab
  ocrText = ocrText.split('\n').map(line => line.replace(/\s{2,}/g, '\t')).join('\n');
  return ocrText;
}

// ================================================================
// QGENDA SCREENSHOT PARSER
// ================================================================
function parseQgendaScreenshot(text) {
  const lines = text.split('\n').map(l => l.trim()).filter(l => l);
  const entries = [];
  let currentYear = new Date().getFullYear();

  for (const line of lines) {
    // Look for date patterns: M/D, M/D/YY, M/D/YYYY
    const dateMatch = line.match(/(\d{1,2})\/(\d{1,2})(?:\/(\d{2,4}))?/);
    if (!dateMatch) continue;

    let [, month, day, year] = dateMatch;
    month = parseInt(month); day = parseInt(day);
    if (year) {
      year = parseInt(year);
      if (year < 100) year += 2000;
    } else {
      year = currentYear;
    }
    if (month < 1 || month > 12 || day < 1 || day > 31) continue;
    currentYear = year; // remember year for subsequent lines

    const dateStr = year + '-' + String(month).padStart(2,'0') + '-' + String(day).padStart(2,'0');

    // Look for military time pairs (H:MM or HH:MM)
    const times = line.match(/\d{1,2}:\d{2}/g);
    if (!times || times.length < 2) continue;

    // Parse time pairs
    for (let i = 0; i < times.length - 1; i += 2) {
      const clockIn = times[i].length === 4 ? '0' + times[i] : times[i];
      const clockOut = times[i+1].length === 4 ? '0' + times[i+1] : times[i+1];
      const inMin = timeToMinutes(clockIn);
      let outMin = timeToMinutes(clockOut);
      if (outMin <= inMin) outMin += 1440;
      const duration = (outMin - inMin) / 60;

      // Extract task abbreviation — text before or after the times
      const afterTimes = line.substring(line.lastIndexOf(times[i+1]) + times[i+1].length).trim();
      const beforeDate = line.substring(0, line.indexOf(dateMatch[0])).trim();
      const betweenDateAndTime = line.substring(line.indexOf(dateMatch[0]) + dateMatch[0].length, line.indexOf(times[i])).trim();
      const task = afterTimes || betweenDateAndTime || beforeDate || '';

      entries.push({
        scheduleDate: dateStr,
        clockInDate: dateStr,
        clockInTime: clockIn,
        clockOutDate: dateStr,
        clockOutTime: clockOut,
        duration: round2(duration),
        task: task.replace(/[^a-zA-Z0-9\s\/\-]/g, '').trim(),
        location: '',
        notes: ''
      });
    }
  }
  return entries;
}

// ================================================================
// IMPORT SHIFTS FROM QGENDA
// ================================================================
function mapTaskToAssignmentType(task, dateStr) {
  const t = (task || '').toUpperCase();
  // "UVH/SFH Work" → pre-call (standalone; when paired with mole/OB, import handler uses overlay)
  if (/UVH\/SFH\s*WORK/.test(t)) return 'pre_call';
  // "Post" anything → always general OR (Post 1-4, Post SF 1/2, etc.)
  if (/\bPOST\b/.test(t)) return 'OR';
  // SFH prefix → SF1 or SF2 (check before call keywords so "SFH 1st Call" → SF1)
  if (/\bSFH\b/.test(t)) {
    if (/2/.test(t)) return 'SF2';
    return 'SF1';
  }
  // Call shifts: check for 1st-4th call keywords (may be prefixed with "UVH")
  if (/4TH|4C/.test(t)) return (dateStr && isWeekend(dateStr)) ? '4th_call' : 'ACS';
  if (/3RD|3C/.test(t)) return '3rd_call';
  if (/2ND|2C/.test(t)) return '2nd_call';
  if (/1ST|1C/.test(t)) return '1st_call';
  // "UVH" + number (without call keyword) → general OR (e.g. "UVH 3", "UVH 7")
  if (/\bUVH\s*\d/.test(t)) return 'OR';
  if (t.includes('NORA')) return 'NORA';
  if (t.includes('ACS') || t.includes('TOCR')) return 'ACS';
  if (t.includes('C/L') || t.includes('CARDIAC')) return 'cardiac_liver';
  if (t.includes('MOLE')) return 'mole';
  if (t.includes('CRNA')) return 'CRNA_supervision';
  if (t.includes('ENDO')) return (dateStr && isWeekend(dateStr)) ? 'mole' : 'endo';
  if (t.includes('SF1') || t.includes('SF 1')) return 'SF1';
  if (t.includes('SF2') || t.includes('SF 2')) return 'SF2';
  if (t.includes('OB') || t.includes('UVOC')) return 'OB_restricted';
  if (t.includes('OR')) return 'OR';
  return 'OR'; // fallback
}

let importTimeData = [];

function showImportTimePreview() {
  const area = document.getElementById('importTimeAction');
  const preview = document.getElementById('importTimePreview');
  if (importTimeData.length === 0) {
    area.classList.add('hidden');
    preview.innerHTML = '';
    return;
  }
  area.classList.remove('hidden');

  // Group by date for preview
  const byDate = {};
  importTimeData.forEach(e => {
    const d = e.scheduleDate;
    if (!d) return;
    if (!byDate[d]) byDate[d] = [];
    byDate[d].push(e);
  });

  const dates = Object.keys(byDate).sort();
  const existing = dates.filter(d => data.shifts[d]).length;
  const newDates = dates.filter(d => !data.shifts[d]).length;

  let html = '<div class="card" style="margin-top:12px;"><h3>Preview</h3>';
  html += `<p style="font-size:0.8rem;color:var(--text-dim);margin-bottom:8px;">${dates.length} date${dates.length > 1 ? 's' : ''} found &mdash; ${newDates} new, ${existing} already exist</p>`;
  html += '<div style="max-height:250px;overflow-y:auto;font-size:0.8rem;">';
  dates.forEach(date => {
    const entries = byDate[date];
    const hasShift = data.shifts[date];
    const task = entries[0].task || '';
    const times = entries.map(e => `${e.clockInTime}-${e.clockOutTime}`).join(', ');
    const assignType = getAssignmentTypeName(mapTaskToAssignmentType(task, date));
    html += `<div style="padding:6px 0;border-bottom:1px solid var(--border);${hasShift ? 'opacity:0.5;' : ''}">`;
    html += `<strong>${formatDateShort(date)}</strong> &mdash; ${assignType}`;
    html += `<br><span style="color:var(--text-dim)">${times}${task ? ' (' + escHtml(task) + ')' : ''}${hasShift ? ' — already exists, will skip' : ''}</span>`;
    html += '</div>';
  });
  html += '</div></div>';
  preview.innerHTML = html;
}

// Import tab — time punch upload
document.getElementById('importTimeUploadArea').addEventListener('click', () => document.getElementById('importTimeFile').click());

document.getElementById('importTimeFile').addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const isImage = /\.(png|jpg|jpeg)$/i.test(file.name);
  const isCSV = /\.csv$/i.test(file.name);

  try {
    if (isImage) {
      showToast('Running OCR on image...');
      const text = await ocrImage(file);
      importTimeData = parseQgendaScreenshot(text);
      showToast(`OCR found ${importTimeData.length} entries`);
    } else if (isCSV) {
      const text = await file.text();
      const rows = parseCSVRows(text);
      importTimeData = rows.map(r => {
        let schedDate = parseExcelDate(r['Schedule Date']);
        return {
          scheduleDate: schedDate,
          clockInDate: parseExcelDate(r['Effective Clock In Date']),
          clockInTime: parseExcelTime(r['Effective Clock In Time']),
          clockOutDate: parseExcelDate(r['Effective Clock Out Date']),
          clockOutTime: parseExcelTime(r['Effective Clock Out Time']),
          duration: parseFloat(r['Duration']) || 0,
          timeClockTask: String(r['Time Clock Task'] || ''),
          task: String(r['Scheduled Task Abbreviation'] || ''),
          location: String(r['Location Name'] || ''),
          notes: String(r['Notes'] || '')
        };
      });
      showToast(`Loaded ${importTimeData.length} entries from CSV`);
    } else {
      const arrayBuffer = await file.arrayBuffer();
      const wb = XLSX.read(arrayBuffer, { type: 'array' });
      const ws = wb.Sheets[wb.SheetNames[0]];
      const rows = XLSX.utils.sheet_to_json(ws, { defval: '' });
      importTimeData = rows.map(r => {
        let schedDate = parseExcelDate(r['Schedule Date']);
        return {
          scheduleDate: schedDate,
          clockInDate: parseExcelDate(r['Effective Clock In Date']),
          clockInTime: parseExcelTime(r['Effective Clock In Time']),
          clockOutDate: parseExcelDate(r['Effective Clock Out Date']),
          clockOutTime: parseExcelTime(r['Effective Clock Out Time']),
          duration: parseFloat(r['Duration']) || 0,
          timeClockTask: String(r['Time Clock Task'] || ''),
          task: String(r['Scheduled Task Abbreviation'] || ''),
          location: String(r['Location Name'] || ''),
          notes: String(r['Notes'] || '')
        };
      });
      showToast(`Loaded ${importTimeData.length} entries from xlsx`);
    }
    showImportTimePreview();
  } catch(err) {
    showToast('Error reading file: ' + err.message);
    console.error(err);
  }
  e.target.value = '';
});

let pendingImportAction = null;

document.getElementById('importShiftsBtn').addEventListener('click', () => {
  // Group entries by date, pick earliest clock-in and latest clock-out
  const byDate = {};
  importTimeData.forEach(e => {
    const d = e.scheduleDate;
    if (!d) return;
    if (!byDate[d]) byDate[d] = [];
    byDate[d].push(e);
  });

  let toImport = 0, toSkip = 0;
  const shiftsToCreate = [];

  Object.keys(byDate).sort().forEach(date => {
    if (data.shifts[date]) { toSkip++; return; }
    const entries = byDate[date];
    // Separate work hours from supervision entries
    const workEntries = entries.filter(e => e.clockInTime && (e.timeClockTask || '').toUpperCase() !== 'CARE TEAM SUPERVISOR');
    const supEntries = entries.filter(e => e.clockInTime && (e.timeClockTask || '').toUpperCase() === 'CARE TEAM SUPERVISOR');
    const allClocked = [...entries].filter(e => e.clockInTime).sort((a, b) => a.clockInTime.localeCompare(b.clockInTime));
    const timeEntries = allClocked.map(e => ({ start: e.clockInTime, end: e.clockOutTime || '' }));
    let earliest = '23:59', latest = '00:00';
    const allTasks = [];
    entries.forEach(e => {
      if (e.clockInTime && e.clockInTime < earliest) earliest = e.clockInTime;
      if (e.clockOutTime && e.clockOutTime > latest) latest = e.clockOutTime;
      if (e.task) allTasks.push(e.task);
    });
    // Prefer call/mole/endo task over pre-call OR work (e.g. "UVH/SFH Work" + "Mole" → use "Mole")
    const callTaskPatterns = /MOLE|ENDO|1ST|2ND|3RD|4TH|CALL|SFH\s*\d/i;
    const task = allTasks.find(t => callTaskPatterns.test(t)) || allTasks[0] || '';
    // Detect CRNA supervision period
    let supervisionStart = '', supervisionEnd = '';
    if (supEntries.length > 0) {
      const sorted = [...supEntries].sort((a, b) => a.clockInTime.localeCompare(b.clockInTime));
      supervisionStart = sorted[0].clockInTime;
      supervisionEnd = sorted[sorted.length - 1].clockOutTime || '';
    }
    // If ALL entries are supervision (standalone CRNA shift), use CRNA_supervision type
    const assignmentType = workEntries.length === 0 && supEntries.length > 0
      ? 'CRNA_supervision'
      : mapTaskToAssignmentType(task, date);

    // Detect pre-call: "UVH/SFH Work" entries paired with mole/OB
    let preCallStart = '', preCallEnd = '';
    const preCallPattern = /UVH\/SFH\s*WORK/i;
    const preCallEntries = entries.filter(e => e.clockInTime && preCallPattern.test(e.task || ''));
    if (preCallEntries.length > 0 && ['mole','OB_restricted'].includes(assignmentType)) {
      const sortedPC = [...preCallEntries].sort((a, b) => a.clockInTime.localeCompare(b.clockInTime));
      preCallStart = sortedPC[0].clockInTime;
      preCallEnd = sortedPC[sortedPC.length - 1].clockOutTime || '';
    }

    // If no clock punches but shift type has pager pay, allow with empty time entries
    const hasPager = getPagerPayWindow(assignmentType, isWeekend(date)) !== null;
    const finalTimeEntries = timeEntries.length > 0
      ? timeEntries
      : hasPager ? [] : [{ start: earliest, end: latest }];
    shiftsToCreate.push({
      date, assignmentType,
      startTime: timeEntries.length > 0 ? earliest : '',
      endTime: timeEntries.length > 0 ? latest : '',
      timeEntries: finalTimeEntries,
      task, supervisionStart, supervisionEnd,
      preCallStart, preCallEnd
    });
    toImport++;
  });

  if (toImport === 0) {
    showToast(toSkip > 0 ? `All ${toSkip} dates already have shifts` : 'No shifts to import');
    return;
  }

  // Show confirmation modal
  const body = document.getElementById('importConfirmBody');
  body.innerHTML = `<p>Import <strong>${toImport}</strong> shift${toImport > 1 ? 's' : ''} from QGenda?</p>` +
    (toSkip > 0 ? `<p style="font-size:0.8rem;color:var(--text-dim);">${toSkip} date${toSkip > 1 ? 's' : ''} already have shifts and will be skipped.</p>` : '') +
    `<div style="max-height:200px;overflow-y:auto;margin-top:8px;font-size:0.8rem;">` +
    shiftsToCreate.map(s => `<div style="padding:4px 0;border-bottom:1px solid var(--border);">${formatDateShort(s.date)} &mdash; ${getAssignmentTypeName(s.assignmentType)}${s.startTime ? ` (${s.startTime}-${s.endTime})` : ' (pager only)'}</div>`).join('') +
    `</div>`;
  document.getElementById('importConfirmTitle').textContent = 'Import Shifts';

  pendingImportAction = () => {
    shiftsToCreate.forEach(s => {
      data.shifts[s.date] = {
        date: s.date,
        assignmentType: s.assignmentType,
        startTime: s.startTime,
        endTime: s.endTime,
        timeEntries: s.timeEntries || [{ start: s.startTime, end: s.endTime }],
        isHoliday: false,
        forcedOff: false,
        subspecCoverage: false,
        teeCount: 0,
        supervisionStart: s.supervisionStart || '',
        supervisionEnd: s.supervisionEnd || '',
        preCallStart: s.preCallStart || '',
        preCallEnd: s.preCallEnd || ''
      };
    });
    saveData(data);
    updateHeaderPoints();
    showToast(`Imported ${shiftsToCreate.length} shifts`);
    showImportTimePreview();
    renderQgendaRecon();
  };

  document.getElementById('importConfirmModal').classList.remove('hidden');
});

document.getElementById('confirmImport').addEventListener('click', () => {
  document.getElementById('importConfirmModal').classList.add('hidden');
  if (pendingImportAction) { pendingImportAction(); pendingImportAction = null; }
});

document.getElementById('cancelImport').addEventListener('click', () => {
  document.getElementById('importConfirmModal').classList.add('hidden');
  pendingImportAction = null;
});

// ================================================================
// CSV CASE IMPORT (Google Sheet export)
// ================================================================
document.getElementById('csvUploadArea').addEventListener('click', () => document.getElementById('csvFile').click());

document.getElementById('csvFile').addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const ext = file.name.split('.').pop().toLowerCase();

  try {
    let result;
    if (ext === 'xlsx' || ext === 'xls') {
      showToast('Parsing Excel file...');
      result = await parseCaseExcel(file);
    } else if (ext === 'pdf') {
      showToast('Parsing PDF...');
      result = await parseCasePDF(file);
    } else if (/^(png|jpg|jpeg)$/.test(ext)) {
      showToast('Running OCR on image...');
      const text = await ocrImage(file);
      result = parseGoogleSheetCSV(text);
    } else {
      // CSV (default)
      const text = await file.text();
      result = parseGoogleSheetCSV(text);
    }

    if (result.cases.length === 0) {
      showToast('No cases found in file');
      return;
    }
    showCSVImportConfirmation(result);
  } catch(err) {
    showToast('Error parsing file: ' + err.message);
    console.error(err);
  }
  e.target.value = '';
});

function convertAMPMToMilitary(timeStr) {
  if (!timeStr) return '';
  const s = timeStr.trim().toUpperCase();
  // Already military format?
  if (s.match(/^\d{1,2}:\d{2}$/) && !s.includes('AM') && !s.includes('PM')) {
    const [h, m] = s.split(':').map(Number);
    return String(h).padStart(2,'0') + ':' + String(m).padStart(2,'0');
  }
  const match = s.match(/(\d{1,2}):(\d{2})(?::\d{2})?\s*(AM|PM)/i);
  if (!match) return '';
  let [, h, m, ampm] = match;
  h = parseInt(h); m = parseInt(m);
  if (ampm === 'PM' && h !== 12) h += 12;
  if (ampm === 'AM' && h === 12) h = 0;
  return String(h).padStart(2,'0') + ':' + String(m).padStart(2,'0');
}

function buildCaseMonthSummary(cases) {
  const mn = ['January','February','March','April','May','June','July','August','September','October','November','December'];
  const buckets = {};
  cases.forEach(c => {
    if (!c.shiftDate) return;
    const [y, m] = c.shiftDate.split('-').map(Number);
    const key = y + '-' + String(m).padStart(2,'0');
    if (!buckets[key]) buckets[key] = { year: y, month: m, label: mn[m - 1] + ' ' + y, count: 0 };
    buckets[key].count++;
  });
  return Object.values(buckets).sort((a, b) => (a.year - b.year) || (a.month - b.month));
}

function parseDateField(raw) {
  if (!raw) return '';
  const s = raw.trim();
  const now = new Date();
  const curYear = now.getFullYear();
  const curMonth = now.getMonth() + 1;

  // M/D/YYYY or M/D/YY or M/D
  const slashMatch = s.match(/^(\d{1,2})\/(\d{1,2})(?:\/(\d{2,4}))?$/);
  if (slashMatch) {
    let [, month, day, year] = slashMatch;
    month = parseInt(month); day = parseInt(day);
    if (year) { year = parseInt(year); if (year < 100) year += 2000; }
    else { year = month > curMonth + 3 ? curYear - 1 : curYear; }
    return year + '-' + String(month).padStart(2,'0') + '-' + String(day).padStart(2,'0');
  }

  // D-Mon or D-Mon-YY (e.g., "1-Nov", "15-Jan", "3-Dec-25")
  const monNames = { jan:1, feb:2, mar:3, apr:4, may:5, jun:6, jul:7, aug:8, sep:9, oct:10, nov:11, dec:12 };
  const monMatch = s.match(/^(\d{1,2})-([A-Za-z]{3})(?:-(\d{2,4}))?$/);
  if (monMatch) {
    const day = parseInt(monMatch[1]);
    const mon = monNames[monMatch[2].toLowerCase()];
    if (!mon) return '';
    let year = monMatch[3] ? parseInt(monMatch[3]) : null;
    if (year !== null && year < 100) year += 2000;
    if (year === null) {
      // Infer year: if month is far ahead of current, likely previous year
      year = mon > curMonth + 3 ? curYear - 1 : curYear;
    }
    return year + '-' + String(mon).padStart(2,'0') + '-' + String(day).padStart(2,'0');
  }

  return '';
}

function parseGoogleSheetCSV(text) {
  const lines = text.split('\n').map(l => l.trim()).filter(l => l);
  const cases = [];

  for (const line of lines) {
    // Handle quoted CSV fields properly
    const cols = [];
    let inQuote = false, field = '';
    for (let i = 0; i < line.length; i++) {
      const ch = line[i];
      if (ch === '"') { inQuote = !inQuote; continue; }
      if (ch === ',' && !inQuote) { cols.push(field.trim()); field = ''; continue; }
      field += ch;
    }
    cols.push(field.trim());

    if (cols.length < 3) continue;

    const dateStr = parseDateField(cols[0]);
    if (!dateStr) continue;

    const surgeon = (cols[1] || '').trim();
    const baseUnits = parseFloat(cols[2]) || 0;
    const startTime = convertAMPMToMilitary(cols[3] || '');
    const endTime = convertAMPMToMilitary(cols[4] || '');
    const modifiers = cols.length > 5 ? (cols[5] || '') : '';
    const blockVal = cols.length > 6 ? (parseFloat(cols[6]) || 0) : 0;
    const shared = cols.length > 7 ? (cols[7] || '').trim() : '';

    // Detect special case types from surgeon column
    const surgeonUpper = surgeon.toUpperCase().trim();

    // Skip CRNA supervision entries (these are shift-level, not case-level)
    if (surgeonUpper.startsWith('SUPERVISING') || surgeonUpper === 'CRNA' || surgeonUpper === 'CRNAS') continue;

    // APS Rounding
    if (surgeonUpper === 'APS') {
      cases.push({
        id: genId(),
        caseType: 'aps_rounding',
        procedure: 'APS Rounding',
        baseUnits: 0,
        physicalStatus: 'P2',
        startTime: '', endTime: '',
        shiftDate: dateStr,
        isEmergency: false,
        isMedicalProc: false, medicalUnits: 0,
        isAcutePain: false, acutePainUnits: 0,
        isHighRiskPeds: false, isORCase: false,
        isSharedCase: false, sharedStartupPct: 100,
        nerveBlock: 'none',
        hasCentralLine: false, hasArterialLine: false,
        hasPAC: false, hasTEEAddOn: false, hasITMorphine: false,
        epiduralRounds: baseUnits === 3 ? 1 : 0,
        painRounds: baseUnits === 2 ? 1 : 0,
        notes: '', timestamp: new Date().toISOString()
      });
      continue;
    }

    // Labor epidural
    if (surgeonUpper === 'EPIDURAL' || surgeonUpper === 'LABOR EPIDURAL') {
      cases.push({
        id: genId(),
        caseType: 'labor_epidural',
        procedure: 'Labor Epidural',
        baseUnits: 0,
        physicalStatus: 'P2',
        startTime: startTime, endTime: endTime,
        shiftDate: dateStr,
        isEmergency: false,
        isMedicalProc: false, medicalUnits: 0,
        isAcutePain: false, acutePainUnits: 0,
        isHighRiskPeds: false, isORCase: false,
        isSharedCase: false, sharedStartupPct: 100,
        nerveBlock: 'none',
        hasCentralLine: false, hasArterialLine: false,
        hasPAC: false, hasTEEAddOn: false, hasITMorphine: false,
        notes: '', timestamp: new Date().toISOString()
      });
      continue;
    }

    // Modifiers: text "E" for emergency, "4"/"5" for physical status
    const isEmergency = /\bE\b/.test(modifiers);
    let physicalStatus = 'P2';
    const psMatch = modifiers.match(/\bASA\s*([45])\b/i) || modifiers.match(/^([45])$/);
    if (psMatch) physicalStatus = 'P' + psMatch[1];

    // If modifier column has a numeric value and block column is empty, it may be misplaced
    const modNum = parseFloat(modifiers) || 0;
    const effectiveBlock = blockVal > 0 ? blockVal : modNum;

    // Nerve block: detect from block point value (3=brachial plexus, 2.6=other)
    let nerveBlock = 'none';
    if (effectiveBlock >= 3) nerveBlock = 'brachial_plexus';
    else if (effectiveBlock >= 2.5) nerveBlock = 'other_nerve';

    // Arterial line: 0.6 in block or modifier column
    const hasArterialLine = Math.abs(effectiveBlock - 0.6) < 0.01;
    if (hasArterialLine) nerveBlock = 'none';

    // Central line: 0.8
    const hasCentralLine = Math.abs(effectiveBlock - 0.8) < 0.01;
    if (hasCentralLine) nerveBlock = 'none';

    // Shared case
    const isShared = shared.toUpperCase() === 'Y';

    if (baseUnits <= 0 && !startTime) continue;

    cases.push({
      id: genId(),
      caseType: 'standard',
      procedure: surgeon,
      baseUnits: baseUnits,
      physicalStatus: physicalStatus,
      startTime: startTime,
      endTime: endTime,
      shiftDate: dateStr,
      isEmergency: isEmergency,
      isMedicalProc: false, medicalUnits: 0,
      isAcutePain: false, acutePainUnits: 0,
      isHighRiskPeds: false, isORCase: false,
      isSharedCase: isShared,
      sharedStartupPct: isShared ? 50 : 100,
      nerveBlock: nerveBlock,
      hasCentralLine: hasCentralLine,
      hasArterialLine: hasArterialLine,
      hasPAC: false, hasTEEAddOn: false, hasITMorphine: false,
      notes: surgeon,
      timestamp: new Date().toISOString()
    });
  }

  return { cases, months: buildCaseMonthSummary(cases) };
}

function showCSVImportConfirmation(result) {
  const { cases, months } = result;

  // Check for duplicates
  const existingKeys = new Set(data.cases.map(c => c.shiftDate + '|' + c.startTime));
  const newCases = cases.filter(c => !existingKeys.has(c.shiftDate + '|' + c.startTime));
  const dupes = cases.length - newCases.length;

  if (newCases.length === 0) {
    showToast(`All ${cases.length} cases already exist`);
    return;
  }

  const monthLabel = months.length === 1 ? months[0].label : months.length + ' months';
  let monthBreakdown = '';
  if (months.length > 1) {
    monthBreakdown = '<ul style="margin:8px 0;padding-left:20px;font-size:0.85rem;">' +
      months.map(m => `<li>${m.label}: ${m.count} case${m.count > 1 ? 's' : ''}</li>`).join('') + '</ul>';
  }

  const body = document.getElementById('importConfirmBody');
  body.innerHTML = `<p>Found <strong>${cases.length}</strong> cases across <strong>${monthLabel}</strong>.</p>` +
    monthBreakdown +
    (dupes > 0 ? `<p style="font-size:0.8rem;color:var(--text-dim);">${dupes} duplicate${dupes > 1 ? 's' : ''} will be skipped.</p>` : '') +
    `<p>Import <strong>${newCases.length}</strong> new case${newCases.length > 1 ? 's' : ''}?</p>`;
  document.getElementById('importConfirmTitle').textContent = 'Import Cases';

  pendingImportAction = () => {
    // Create placeholder shifts for dates without one
    const caseDates = {};
    newCases.forEach(c => {
      if (!caseDates[c.shiftDate]) caseDates[c.shiftDate] = { earliest: '23:59', latest: '00:00' };
      if (c.startTime && c.startTime < caseDates[c.shiftDate].earliest) caseDates[c.shiftDate].earliest = c.startTime;
      if (c.endTime && c.endTime > caseDates[c.shiftDate].latest) caseDates[c.shiftDate].latest = c.endTime;
    });

    let shiftsCreated = 0;
    Object.keys(caseDates).forEach(date => {
      if (!data.shifts[date]) {
        const st = caseDates[date].earliest || '07:00';
        const en = caseDates[date].latest || '17:00';
        data.shifts[date] = {
          date, assignmentType: 'OR',
          startTime: st, endTime: en,
          timeEntries: [{ start: st, end: en }],
          isHoliday: false,
          forcedOff: false, subspecCoverage: false,
          teeCount: 0, supervisionStart: '', supervisionEnd: '', preCallStart: '', preCallEnd: '', tempCoverage: []
        };
        shiftsCreated++;
      }
    });

    data.cases.push(...newCases);
    saveData(data);
    updateHeaderPoints();
    showToast(`Imported ${newCases.length} cases` + (shiftsCreated > 0 ? ` and created ${shiftsCreated} placeholder shifts` : ''));
  };

  document.getElementById('importConfirmModal').classList.remove('hidden');
}

async function parseCaseExcel(file) {
  const arrayBuffer = await file.arrayBuffer();
  const wb = XLSX.read(arrayBuffer, { type: 'array' });
  const ws = wb.Sheets[wb.SheetNames[0]];
  const rows = XLSX.utils.sheet_to_json(ws, { defval: '' });
  if (rows.length === 0) return { cases: [], months: [] };

  // Flexible column header matching
  const headers = Object.keys(rows[0]);
  const findCol = (...patterns) => headers.find(h => patterns.some(p => h.toLowerCase().includes(p.toLowerCase()))) || '';
  const dateCol = findCol('date', 'dos', 'Date');
  const surgeonCol = findCol('surgeon', 'provider', 'attending');
  const unitsCol = findCol('units', 'points', 'base');
  const startCol = findCol('start', 'begin');
  const endCol = findCol('end', 'stop', 'finish');
  const modCol = findCol('modifier', 'mod');
  const sharedCol = findCol('shared', 'split');
  const procCol = findCol('procedure', 'proc', 'description', 'case');

  if (!dateCol) throw new Error('No date column found. Expected: Date, DOS, or similar.');

  const cases = [];
  for (const row of rows) {
    const dateVal = row[dateCol];
    if (!dateVal && dateVal !== 0) continue;
    const dateStr = parseExcelDate(dateVal);
    if (!dateStr || dateStr.length !== 10) continue;

    const baseUnits = parseFloat(row[unitsCol]) || 0;
    const startTime = startCol ? parseExcelTime(row[startCol]) : '';
    const endTime = endCol ? parseExcelTime(row[endCol]) : '';
    if (baseUnits <= 0 && !startTime) continue;

    const surgeon = surgeonCol ? String(row[surgeonCol]) : '';
    const modifiers = modCol ? String(row[modCol]) : '';
    const shared = sharedCol ? String(row[sharedCol]) : '';
    const procedure = procCol ? String(row[procCol]) : '';

    const isEmergency = /\bE\b/i.test(modifiers);
    let physicalStatus = 'P3';
    const psMatch = modifiers.match(/\b([45])\b/);
    if (psMatch) physicalStatus = 'P' + psMatch[1];

    cases.push({
      id: genId(),
      caseType: 'standard',
      procedure: procedure,
      baseUnits: baseUnits,
      physicalStatus: physicalStatus,
      startTime: startTime,
      endTime: endTime,
      shiftDate: dateStr,
      isEmergency: isEmergency,
      isMedicalProcedure: false,
      medicalProcedureUnits: 0,
      isAcutePain: false,
      acutePainUnits: 0,
      isHighRiskPeds: false,
      isORCase: false,
      nerveBlock: 'none',
      centralLine: false,
      arterialLine: false,
      pac: false,
      teeAddOn: false,
      notes: surgeon + (shared && /^y/i.test(shared) ? ' (shared)' : ''),
      timestamp: new Date().toISOString()
    });
  }
  return { cases, months: buildCaseMonthSummary(cases) };
}

async function parseCasePDF(file) {
  const allText = await extractPDFText(file);

  const prodCases = parseProdText(allText);
  // Convert production format to case import format, skipping add-on rows
  const cases = [];
  for (const pc of prodCases) {
    if (pc.isAddOn) continue;
    cases.push({
      id: genId(),
      caseType: 'standard',
      procedure: pc.cptCode || '',
      baseUnits: pc.units || 0,
      physicalStatus: 'P2',
      startTime: pc.startTime || '',
      endTime: pc.endTime || '',
      shiftDate: pc.date,
      isEmergency: false,
      isMedicalProcedure: false,
      medicalProcedureUnits: 0,
      isAcutePain: false,
      acutePainUnits: 0,
      isHighRiskPeds: false,
      isORCase: false,
      nerveBlock: 'none',
      centralLine: false,
      arterialLine: false,
      pac: false,
      teeAddOn: false,
      notes: pc.cptCode ? 'CPT ' + pc.cptCode : '',
      timestamp: new Date().toISOString()
    });
  }
  return { cases, months: buildCaseMonthSummary(cases) };
}

const CPT_ADDON_MAP = {
  '64415': 'brachial_plexus', '64416': 'brachial_plexus', '64417': 'brachial_plexus',
  '64400': 'other_nerve', '64405': 'other_nerve', '64408': 'other_nerve',
  '64418': 'other_nerve', '64420': 'other_nerve', '64421': 'other_nerve',
  '64425': 'other_nerve', '64430': 'other_nerve', '64435': 'other_nerve',
  '64445': 'other_nerve', '64446': 'other_nerve', '64447': 'other_nerve',
  '64448': 'other_nerve', '64449': 'other_nerve', '64450': 'other_nerve',
  '64461': 'other_nerve', '64462': 'other_nerve', '64463': 'other_nerve',
  '64466': 'other_nerve', '64467': 'other_nerve', '64468': 'other_nerve',
  '64469': 'other_nerve', '64472': 'other_nerve', '64474': 'other_nerve',
  '64486': 'other_nerve', '64487': 'other_nerve', '64488': 'other_nerve',
  '64489': 'other_nerve',
  '62322': 'it_morphine', '62323': 'it_morphine',
  '36620': 'arterial_line',
  '36556': 'central_line',
  // 01996 (epidural rounding) and 99231 (pain rounding) are tracked as cases in the app,
  // not add-ons — they are matched at the case level during reconciliation
  '93312': 'tee', '93313': 'tee', '93314': 'tee',
  '93315': 'tee', '93316': 'tee', '93355': 'tee',
  '99241': 'pac', '99242': 'pac', '99243': 'pac',
  '99244': 'pac', '99245': 'pac'
};

function parseProdText(text) {
  const lines = text.split('\n');
  const cases = [];
  let currentDate = '';

  for (const line of lines) {
    const cols = line.split('\t').map(c => c.trim());

    // Try to find date of service pattern: M/D/YY or M/D/YYYY
    const dateMatch = cols[0] && cols[0].match(/^(\d{1,2})\/(\d{1,2})\/(\d{2,4})$/);
    if (dateMatch) {
      let [, m, d, y] = dateMatch;
      y = parseInt(y);
      if (y < 100) y += 2000;
      currentDate = y + '-' + String(parseInt(m)).padStart(2,'0') + '-' + String(parseInt(d)).padStart(2,'0');
    }

    if (!currentDate) continue;

    // Extract CPT code first (5-digit number)
    let cptCode = '';
    for (const c of cols) {
      if (c.match(/^\d{5}$/)) { cptCode = c; break; }
    }

    // Extract account number — numeric string 6-10 digits, not a CPT code or time
    let accountNumber = '';
    for (const c of cols) {
      if (c.match(/^\d{6,10}$/) && c !== cptCode) {
        accountNumber = c;
        break;
      }
    }

    // Scan columns for military time (3-4 digit number between 0 and 2359)
    let startTime = '', endTime = '';
    for (let i = 0; i < cols.length; i++) {
      const val = cols[i].replace(/[^0-9]/g, '');
      if (val.length >= 3 && val.length <= 4) {
        const num = parseInt(val);
        if (num >= 0 && num <= 2359) {
          if (!startTime) startTime = val;
          else if (!endTime) { endTime = val; break; }
        }
      }
    }

    // Check if this is an add-on row (CPT maps to add-on type AND no start/end times)
    const addOnType = cptCode ? (CPT_ADDON_MAP[cptCode] || '') : '';
    if (addOnType && (!startTime || !endTime)) {
      // Extract points for add-on rows
      const nums = cols.filter(c => c && !isNaN(parseFloat(c)));
      const totalPoints = nums.length > 0 ? parseFloat(nums[nums.length - 1]) || 0 : 0;
      let units = 0;
      for (const c of cols) {
        const n = parseFloat(c);
        if (!isNaN(n) && n >= 1 && n <= 30 && Number.isInteger(n)) { units = n; break; }
      }
      cases.push({
        date: currentDate, startTime: '', endTime: '',
        mdMinutes: 0, totalPoints, units,
        locCode: '', cptCode, accountNumber,
        isAddOn: true, addOnType
      });
      continue;
    }

    // Rounding CPT codes (01996, 99231) — these are cases, not add-ons,
    // even if they lack start/end times on the billing document
    const isRoundingCPT = cptCode === '01996' || cptCode === '99231';
    if (isRoundingCPT && (!startTime || !endTime)) {
      const nums = cols.filter(c => c && !isNaN(parseFloat(c)));
      const totalPoints = nums.length > 0 ? parseFloat(nums[nums.length - 1]) || 0 : 0;
      let units = 0;
      for (const c of cols) {
        const n = parseFloat(c);
        if (!isNaN(n) && n >= 1 && n <= 30 && Number.isInteger(n)) { units = n; break; }
      }
      cases.push({
        date: currentDate, startTime: '', endTime: '',
        mdMinutes: 0, totalPoints, units,
        locCode: '', cptCode, accountNumber,
        isAddOn: false, addOnType: '',
        isRounding: true
      });
      continue;
    }

    // Standard case row — needs start/end times
    const lastNum = cols.filter(c => c && !isNaN(parseFloat(c)));
    if (lastNum.length >= 2 && startTime && endTime) {
      let totalPoints = parseFloat(lastNum[lastNum.length - 1]) || 0;
      let units = 0, locCode = '';
      for (const c of cols) {
        const n = parseFloat(c);
        if (!isNaN(n) && n >= 1 && n <= 30 && Number.isInteger(n) && c !== startTime && c !== endTime) { units = n; break; }
      }
      for (const c of cols) {
        if (c.match(/^[A-Z]{2,4}$/) && c !== 'Y') { locCode = c; break; }
      }

      if (totalPoints !== 0 || units > 0) {
        cases.push({
          date: currentDate,
          startTime: formatMilitaryTime(startTime),
          endTime: formatMilitaryTime(endTime),
          mdMinutes: 0, totalPoints, units, locCode, cptCode, accountNumber,
          isAddOn: false, addOnType: addOnType
        });
      }
    }
  }

  // Keep add-on rows (no times) + rounding rows (no times) + case rows (with times)
  return cases.filter(c => c.isAddOn || c.isRounding || (c.startTime && c.endTime));
}

function formatMilitaryTime(val) {
  const s = val.padStart(4, '0');
  return s.substring(0, 2) + ':' + s.substring(2, 4);
}

// Reconciliation state
let reconDifferences = [];
let reconFlaggedItems = [];
let reconAutoAdjusted = [];
let reconCurrentDiff = 0;
let reconDecisions = {};

function loadReconDecisions() {
  try {
    const raw = localStorage.getItem(RECON_DECISIONS_KEY);
    if (raw) reconDecisions = JSON.parse(raw);
  } catch(e) { reconDecisions = {}; }
}
function saveReconDecisions() {
  localStorage.setItem(RECON_DECISIONS_KEY, JSON.stringify(reconDecisions));
}

function getAddOnTypeName(type) {
  const names = {
    brachial_plexus: 'Brachial Plexus Block', other_nerve: 'Other Nerve Block',
    it_morphine: 'IT Morphine', arterial_line: 'Arterial Line',
    central_line: 'Central Line', epidural_round: 'Epidural Rounding',
    pain_round: 'Pain Rounding', tee: 'TEE', pac: 'PAC'
  };
  return names[type] || type;
}

function countAppAddOns(trackerCases, date) {
  const dayCases = trackerCases.filter(c => c.shiftDate === date);
  const counts = {};
  dayCases.forEach(c => {
    if (c.nerveBlock === 'brachial_plexus') counts.brachial_plexus = (counts.brachial_plexus || 0) + 1;
    else if (c.nerveBlock === 'other') counts.other_nerve = (counts.other_nerve || 0) + 1;
    if (c.hasCentralLine) counts.central_line = (counts.central_line || 0) + 1;
    if (c.hasArterialLine) counts.arterial_line = (counts.arterial_line || 0) + 1;
    if (c.hasPAC) counts.pac = (counts.pac || 0) + 1;
    if (c.hasTEEAddOn) counts.tee = (counts.tee || 0) + 1;
    if (c.hasITMorphine) counts.it_morphine = (counts.it_morphine || 0) + 1;
  });
  return counts;
}

function renderAddOnTally(billingCases, trackerCases, prefix) {
  const billingAddOns = billingCases.filter(c => c.isAddOn);
  if (billingAddOns.length === 0) return '';

  // Group billing add-ons by date and type
  const bByDateType = {};
  billingAddOns.forEach(c => {
    const key = `${c.date}|${c.addOnType}`;
    bByDateType[key] = (bByDateType[key] || 0) + 1;
  });

  // Get all unique dates and types
  const allDates = new Set(billingAddOns.map(c => c.date));
  trackerCases.filter(c => c.shiftDate && c.shiftDate.startsWith(prefix)).forEach(c => allDates.add(c.shiftDate));
  const sortedDates = [...allDates].sort();

  const allTypes = new Set(billingAddOns.map(c => c.addOnType));

  // Per-date app add-on counts
  const appCountsByDate = {};
  sortedDates.forEach(d => { appCountsByDate[d] = countAppAddOns(trackerCases, d); });

  // Also check app for types not in billing
  sortedDates.forEach(d => {
    Object.keys(appCountsByDate[d]).forEach(t => allTypes.add(t));
  });

  // Build discrepancy rows
  const rows = [];
  sortedDates.forEach(date => {
    const appCounts = appCountsByDate[date] || {};
    allTypes.forEach(type => {
      const bCount = bByDateType[`${date}|${type}`] || 0;
      const aCount = appCounts[type] || 0;
      if (bCount !== aCount) {
        rows.push({ date, type, billing: bCount, app: aCount });
      }
    });
  });

  // Monthly summary totals
  const monthBilling = {}, monthApp = {};
  allTypes.forEach(type => {
    monthBilling[type] = 0;
    monthApp[type] = 0;
  });
  sortedDates.forEach(date => {
    allTypes.forEach(type => {
      monthBilling[type] += bByDateType[`${date}|${type}`] || 0;
      monthApp[type] += (appCountsByDate[date] || {})[type] || 0;
    });
  });

  let html = '<div class="card"><h2>Additional Procedure Tally</h2>';

  // Monthly summary
  html += '<table class="addon-tally-table"><thead><tr><th>Procedure</th><th>Billing</th><th>App</th><th>Diff</th></tr></thead><tbody>';
  allTypes.forEach(type => {
    const b = monthBilling[type], a = monthApp[type];
    const diff = b - a;
    const cls = diff === 0 ? 'addon-match' : Math.abs(diff) === 1 ? 'addon-warn' : 'addon-miss';
    html += `<tr class="${cls}"><td>${getAddOnTypeName(type)}</td><td>${b}</td><td>${a}</td><td>${diff > 0 ? '+' : ''}${diff}</td></tr>`;
  });
  html += '</tbody></table>';

  // Per-day discrepancies
  if (rows.length > 0) {
    html += '<h3 style="margin-top:16px;font-size:0.85rem;">Daily Discrepancies</h3>';
    html += '<table class="addon-tally-table"><thead><tr><th>Date</th><th>Procedure</th><th>Billing</th><th>App</th><th>Action</th></tr></thead><tbody>';
    rows.forEach((r, idx) => {
      const diff = Math.abs(r.billing - r.app);
      const cls = diff === 1 ? 'addon-warn' : 'addon-miss';
      let actionHtml = '';
      if (r.billing > r.app) {
        // App is missing — offer to add to a case
        const dayCases = data.cases.filter(c => c.shiftDate === r.date);
        if (dayCases.length > 0) {
          actionHtml = `<select class="addon-select" id="addonSelect_${idx}" data-date="${r.date}" data-type="${r.type}">`;
          actionHtml += '<option value="">Add to Case...</option>';
          dayCases.forEach(c => {
            actionHtml += `<option value="${c.id}">${c.startTime || ''} ${escHtml(c.procedure || c.caseType).substring(0,20)}</option>`;
          });
          actionHtml += '</select>';
        } else {
          actionHtml = '<span style="font-size:0.7rem;color:var(--text-dim)">No cases for date</span>';
        }
      } else {
        // Billing is missing — flag for office
        actionHtml = `<button class="addon-action-btn" onclick="flagAddonForOffice('${r.date}','${r.type}',${r.app},${r.billing})">Flag for Office</button>`;
      }
      html += `<tr class="${cls}"><td>${formatDateShort(r.date)}</td><td>${getAddOnTypeName(r.type)}</td><td>${r.billing}</td><td>${r.app}</td><td>${actionHtml}</td></tr>`;
    });
    html += '</tbody></table>';
  } else {
    html += '<p style="color:var(--accent);font-size:0.8rem;margin-top:8px;">All additional procedures match!</p>';
  }

  html += '</div>';
  return html;
}

function flagAddonForOffice(date, type, appCount, billingCount) {
  reconFlaggedItems.push({
    type: 'addon',
    date, addOnType: type,
    description: `${getAddOnTypeName(type)}: App has ${appCount}, billing has ${billingCount}`
  });
  showToast('Flagged for office');
  renderProdRecon();
}

function renderProdRecon() {
  loadReconDecisions();
  reconFlaggedItems = [];
  reconAutoAdjusted = [];

  if (prodData.length === 0) {
    try {
      const cached = localStorage.getItem(PROD_KEY);
      if (cached) prodData = JSON.parse(cached);
    } catch(e) {}
  }

  const container = document.getElementById('prodResults');
  const prefix = `${pYear}-${String(pMonth+1).padStart(2,'0')}`;
  const mn = ['January','February','March','April','May','June','July','August','September','October','November','December'];
  const monthLabel = `${mn[pMonth]} ${pYear}`;

  const allBilling = prodData.filter(c => c.date && c.date.startsWith(prefix));
  const billingCases = allBilling.filter(c => !c.isAddOn);
  const trackerCases = data.cases.filter(c => c.shiftDate && c.shiftDate.startsWith(prefix));

  if (prodData.length === 0) {
    container.innerHTML = '<div class="empty-state"><p>Upload a Charge Detail PDF to begin reconciliation.</p></div>';
    return;
  }
  if (allBilling.length === 0 && trackerCases.length === 0) {
    container.innerHTML = '<div class="empty-state"><p>No data for this month.</p></div>';
    return;
  }

  // Group by date (cases only, not add-on rows)
  const bByDate = {};
  billingCases.forEach(c => { if (!bByDate[c.date]) bByDate[c.date] = []; bByDate[c.date].push(c); });
  const tByDate = {};
  trackerCases.forEach(c => { if (!tByDate[c.shiftDate]) tByDate[c.shiftDate] = []; tByDate[c.shiftDate].push(c); });

  const allDates = new Set([...Object.keys(bByDate), ...Object.keys(tByDate)]);
  const sortedDates = [...allDates].sort();

  let bTotalPts = 0, tTotalPts = 0, bTotalCases = 0, tTotalCases = 0, matchCount = 0, issueCount = 0;

  // Build differences list for the stepper
  reconDifferences = [];

  // Day-level summary table
  let dayHtml = '<div class="card"><h2>Billing vs Tracker by Day</h2>';
  dayHtml += '<table class="recon-table"><thead><tr><th>Date</th><th>Billing</th><th>Tracker</th><th>Status</th></tr></thead><tbody>';

  sortedDates.forEach(date => {
    const bDay = (bByDate[date] || []);
    const tDay = (tByDate[date] || []);
    const shift = data.shifts[date];

    const bPts = bDay.reduce((s, c) => s + c.totalPoints, 0);
    const tPts = tDay.reduce((s, c) => s + calcCasePoints(c, shift), 0);
    bTotalPts += bPts; tTotalPts += tPts;
    bTotalCases += bDay.length; tTotalCases += tDay.length;

    const caseDiff = Math.abs(bDay.length - tDay.length);
    const ptDiff = Math.abs(bPts - tPts);
    let status = '', rowClass = '';
    if (bDay.length === 0) { status = 'Not in billing'; rowClass = 'warn'; issueCount++; }
    else if (tDay.length === 0) { status = 'Not in tracker'; rowClass = 'miss'; issueCount++; }
    else if (caseDiff === 0 && ptDiff < 5) { status = 'Match'; rowClass = 'match'; matchCount++; }
    else if (caseDiff <= 1 && ptDiff < 15) { status = 'Close'; rowClass = 'warn'; issueCount++; }
    else { status = 'Mismatch'; rowClass = 'miss'; issueCount++; }

    dayHtml += `<tr class="${rowClass}"><td>${formatDateShort(date)}</td>
      <td>${bDay.length} cases<br><span style="font-size:0.7rem;color:var(--text-dim)">${bPts.toFixed(1)} pts</span></td>
      <td>${tDay.length} cases<br><span style="font-size:0.7rem;color:var(--text-dim)">${tPts.toFixed(1)} pts</span></td>
      <td>${status}</td></tr>`;

    // Per-case matching for difference building
    if (bDay.length > 0 || tDay.length > 0) {
      const usedTracker = new Set();
      const usedBilling = new Set();

      // Pass 1: Match rounding billing rows (no times) by CPT code
      bDay.forEach((bc, bIdx) => {
        if (bc.startTime && bc.endTime) return; // skip timed cases
        if (!bc.isRounding) return;
        const roundingType = bc.cptCode === '01996' ? '01996' : (bc.cptCode === '99231' ? '99231' : null);
        if (!roundingType) return;

        // Find an unmatched app case of matching type on this date
        let bestMatch = null;
        tDay.forEach((tc, idx) => {
          if (usedTracker.has(idx)) return;
          // Match against standalone rounding case types or APS rounding
          if (tc.caseType === roundingType) { bestMatch = idx; return; }
          if (tc.caseType === 'aps_rounding' && roundingType === '01996' && (parseInt(tc.epiduralRounds) || 0) > 0) { bestMatch = idx; return; }
          if (tc.caseType === 'aps_rounding' && roundingType === '99231' && (parseInt(tc.painRounds) || 0) > 0) { bestMatch = idx; return; }
        });

        if (bestMatch !== null) {
          usedTracker.add(bestMatch);
          usedBilling.add(bIdx);
          const tc = tDay[bestMatch];
          const tcPts = calcCasePoints(tc, shift);
          const ptsDiff = Math.abs(bc.totalPoints - tcPts);
          if (ptsDiff >= 3) {
            reconDifferences.push({ date, shift, billingCase: bc, trackerCase: tc, billingPts: bc.totalPoints, trackerPts: tcPts, type: 'mismatch' });
          }
        } else {
          usedBilling.add(bIdx);
          reconDifferences.push({ date, shift, billingCase: bc, trackerCase: null, billingPts: bc.totalPoints, trackerPts: 0, type: 'missing_tracker' });
        }
      });

      // Pass 2: Match timed cases by start time overlap
      bDay.forEach((bc, bIdx) => {
        if (usedBilling.has(bIdx)) return;
        const bStart = timeToMinutes(bc.startTime);
        let bestMatch = null, bestDiff = 999;
        tDay.forEach((tc, idx) => {
          if (usedTracker.has(idx)) return;
          const tStart = timeToMinutes(tc.startTime || '');
          if (!tStart) return;
          const diff = Math.abs(bStart - tStart);
          if (diff < bestDiff && diff <= 30) { bestDiff = diff; bestMatch = idx; }
        });

        if (bestMatch !== null) {
          usedTracker.add(bestMatch);
          const tc = tDay[bestMatch];
          const tcPts = calcCasePoints(tc, shift);
          const ptsDiff = Math.abs(bc.totalPoints - tcPts);

          // Auto-adjust shared cases with < 5pt difference
          if (tc.isSharedCase && ptsDiff > 0 && ptsDiff < 5) {
            const oldPts = tcPts;
            // Back-calculate baseUnits to match billing total
            const isOBShift = shift && ['OB_restricted','SF1','SF2'].includes(shift.assignmentType);
            const obMult = (isOBShift && !tc.isORCase) ? 2 : 1;
            const addOns = calcAddOnPoints(tc);
            let caseStartMin = timeToMinutes(tc.startTime);
            let caseEndMin = timeToMinutes(tc.endTime);
            if (caseEndMin <= caseStartMin) caseEndMin += 1440;
            const caseHours = (caseEndMin - caseStartMin) / 60;
            const tm = getTimeMultiplier(tc.physicalStatus, shift.isHoliday, isWeekend(shift.date), caseStartMin, tc.isHighRiskPeds);
            const timePts = caseHours * tm * 6;
            const emergPts = tc.isEmergency ? 1 : 0;
            const medPts = tc.isMedicalProc ? 0.20 * (parseFloat(tc.medicalUnits) || 0) : 0;
            const acutePts = tc.isAcutePain ? 0.375 * (parseFloat(tc.acutePainUnits) || 0) : 0;
            // billingTotal = (basePts + timePts + medPts + acutePts + emergPts + addOns) * obMult
            // basePts = billingTotal/obMult - timePts - medPts - acutePts - emergPts - addOns
            const targetBase = bc.totalPoints / obMult - timePts - medPts - acutePts - emergPts - addOns;
            const pct = (parseFloat(tc.sharedStartupPct) || 50) / 100;
            if (pct > 0) {
              tc.baseUnits = String(round2(targetBase / (0.5 * pct)));
            }
            saveData(data);
            reconAutoAdjusted.push({ date, startTime: tc.startTime, procedure: tc.procedure, oldPts, newPts: bc.totalPoints });
          } else if (ptsDiff >= 3) {
            // Add to difference reviewer
            reconDifferences.push({
              date, shift,
              billingCase: bc,
              trackerCase: tc,
              billingPts: bc.totalPoints,
              trackerPts: tcPts,
              type: 'mismatch'
            });
          }
        } else {
          // Billing case not in tracker
          reconDifferences.push({
            date, shift,
            billingCase: bc,
            trackerCase: null,
            billingPts: bc.totalPoints,
            trackerPts: 0,
            type: 'missing_tracker'
          });
        }
      });

      // Unmatched tracker cases
      tDay.forEach((tc, idx) => {
        if (usedTracker.has(idx)) return;
        const tcPts = calcCasePoints(tc, shift);
        reconDifferences.push({
          date, shift,
          billingCase: null,
          trackerCase: tc,
          billingPts: 0,
          trackerPts: tcPts,
          type: 'missing_billing'
        });
      });
    }
  });

  dayHtml += '</tbody></table></div>';

  // Summary
  let summary = '<div class="card"><h2>Production Summary</h2><div class="summary-grid">';
  summary += `<div class="summary-item"><div class="label">Billing Points</div><div class="value blue">${bTotalPts.toFixed(1)}</div></div>`;
  summary += `<div class="summary-item"><div class="label">Tracker Points</div><div class="value green">${tTotalPts.toFixed(1)}</div></div>`;
  summary += `<div class="summary-item"><div class="label">Billing Cases</div><div class="value blue">${bTotalCases}</div></div>`;
  summary += `<div class="summary-item"><div class="label">Tracker Cases</div><div class="value green">${tTotalCases}</div></div>`;
  summary += `<div class="summary-item"><div class="label">Days Matched</div><div class="value green">${matchCount}</div></div>`;
  summary += `<div class="summary-item"><div class="label">Days w/ Issues</div><div class="value" style="color:var(--danger)">${issueCount}</div></div>`;
  summary += '</div></div>';

  // Add-on tally
  const addonHtml = renderAddOnTally(allBilling, data.cases, prefix);

  // Auto-adjusted shared cases summary
  let autoAdjHtml = '';
  if (reconAutoAdjusted.length > 0) {
    autoAdjHtml = '<div class="card"><h2>Auto-Adjusted Shared Cases</h2>';
    autoAdjHtml += `<p style="font-size:0.8rem;color:var(--accent);margin-bottom:8px;">${reconAutoAdjusted.length} shared case${reconAutoAdjusted.length > 1 ? 's' : ''} auto-adjusted to match billing</p>`;
    autoAdjHtml += '<details><summary style="cursor:pointer;font-size:0.8rem;color:var(--primary);">Show details</summary>';
    autoAdjHtml += '<table class="recon-table"><thead><tr><th>Date</th><th>Case</th><th>Old</th><th>New</th></tr></thead><tbody>';
    reconAutoAdjusted.forEach(a => {
      autoAdjHtml += `<tr class="match"><td>${formatDateShort(a.date)}</td><td>${a.startTime} ${escHtml(a.procedure || '')}</td><td>${a.oldPts.toFixed(1)} pts</td><td>${a.newPts.toFixed(1)} pts</td></tr>`;
    });
    autoAdjHtml += '</tbody></table></details></div>';
  }

  // Difference reviewer stepper
  let reviewerHtml = '';
  if (reconDifferences.length > 0) {
    reviewerHtml = '<div class="card" id="reconReviewerCard">';
    reviewerHtml += `<h2>Review Differences (${reconDifferences.length})</h2>`;
    reviewerHtml += '<div id="reconStepperContainer"></div>';
    reviewerHtml += '</div>';
  }

  // Flagged items + email section
  let flaggedHtml = '<div id="reconFlaggedSection"></div>';

  container.innerHTML = summary + addonHtml + autoAdjHtml + dayHtml + reviewerHtml + flaggedHtml;

  // Wire up add-on select dropdowns
  container.querySelectorAll('.addon-select').forEach(sel => {
    sel.addEventListener('change', function() {
      const caseId = this.value;
      if (!caseId) return;
      const type = this.dataset.type;
      const c = data.cases.find(x => x.id === caseId);
      if (!c) return;
      // Add the add-on to the case
      if (type === 'brachial_plexus') c.nerveBlock = 'brachial_plexus';
      else if (type === 'other_nerve') c.nerveBlock = 'other';
      else if (type === 'central_line') c.hasCentralLine = true;
      else if (type === 'arterial_line') c.hasArterialLine = true;
      else if (type === 'it_morphine') c.hasITMorphine = true;
      else if (type === 'pac') c.hasPAC = true;
      else if (type === 'tee') c.hasTEEAddOn = true;
      saveData(data);
      showToast(`Added ${getAddOnTypeName(type)} to case`);
      renderProdRecon();
    });
  });

  // Render stepper if differences exist
  if (reconDifferences.length > 0) {
    reconCurrentDiff = 0;
    renderDiffStepper();
  }

  renderFlaggedSection(monthLabel);
}

function renderDiffStepper() {
  const container = document.getElementById('reconStepperContainer');
  if (!container || reconDifferences.length === 0) return;

  const d = reconDifferences[reconCurrentDiff];
  const key = `${d.date}_${d.billingCase ? d.billingCase.startTime : 'none'}_${d.billingCase ? d.billingCase.cptCode : 'tc'}`;
  const decision = reconDecisions[key];
  const isResolved = decision && (decision.accepted === 'app' || decision.accepted === 'billing');
  const isFlagged = decision && decision.flagged;

  let html = `<div class="diff-stepper${isResolved ? ' resolved' : ''}${isFlagged ? ' flagged' : ''}">`;
  html += '<div class="diff-stepper-header">';
  html += `<span class="counter">Difference ${reconCurrentDiff + 1} of ${reconDifferences.length}</span>`;
  html += '<div class="diff-stepper-nav">';
  html += `<button onclick="reconNav(-1)"${reconCurrentDiff === 0 ? ' disabled' : ''}>&larr;</button>`;
  html += `<button onclick="reconNav(1)"${reconCurrentDiff >= reconDifferences.length - 1 ? ' disabled' : ''}>&rarr;</button>`;
  html += '</div></div>';

  html += '<div class="diff-stepper-body">';
  html += `<div class="diff-date">${formatDateShort(d.date)} ${d.type === 'mismatch' ? '— ' + (d.billingCase.startTime || '') : ''}</div>`;

  if (d.billingCase && d.billingCase.accountNumber) {
    html += `<div class="diff-acct">Acct# ${d.billingCase.accountNumber}</div>`;
  }

  if (isResolved) {
    html += `<p style="color:var(--accent);font-size:0.85rem;font-weight:600;">Accepted: ${decision.accepted === 'billing' ? 'Billing' : 'App'} value</p>`;
  } else if (isFlagged) {
    html += `<p style="color:var(--accent2);font-size:0.85rem;font-weight:600;">Flagged for office</p>`;
  }

  html += '<div class="diff-compare">';

  // Billing column
  html += '<div class="diff-col">';
  html += '<h4>Billing</h4>';
  if (d.billingCase) {
    html += `<div class="val">${d.billingPts.toFixed(1)} pts</div>`;
    html += `<div class="detail">${d.billingCase.units || '-'} units</div>`;
    html += `<div class="detail">CPT ${d.billingCase.cptCode || '-'}</div>`;
    html += `<div class="detail">${d.billingCase.startTime || '-'} - ${d.billingCase.endTime || '-'}</div>`;
  } else {
    html += '<div class="val" style="color:var(--danger)">Not in billing</div>';
  }
  html += '</div>';

  // App column
  html += '<div class="diff-col">';
  html += '<h4>App</h4>';
  if (d.trackerCase) {
    const tcPts = calcCasePoints(d.trackerCase, d.shift);
    html += `<div class="val">${tcPts.toFixed(1)} pts</div>`;
    html += `<div class="detail">${d.trackerCase.baseUnits || '-'} units</div>`;
    html += `<div class="detail">${escHtml(d.trackerCase.procedure || d.trackerCase.caseType)}</div>`;
    html += `<div class="detail">${d.trackerCase.startTime || '-'} - ${d.trackerCase.endTime || '-'}</div>`;
    if (d.trackerCase.isSharedCase) html += `<div class="detail" style="color:var(--accent2)">Shared (${d.trackerCase.sharedStartupPct || 50}%)</div>`;
  } else {
    html += '<div class="val" style="color:var(--danger)">Not in app</div>';
  }
  html += '</div></div>';

  // Action buttons
  if (!isResolved && !isFlagged) {
    html += '<div class="diff-actions">';
    if (d.billingCase && d.trackerCase) {
      html += `<button class="btn btn-accept-billing" onclick="reconAcceptBilling(${reconCurrentDiff})">Accept Billing</button>`;
      html += `<button class="btn btn-accept-app" onclick="reconAcceptApp(${reconCurrentDiff})">Accept App</button>`;
    }
    html += `<button class="btn btn-flag" onclick="reconFlag(${reconCurrentDiff})">Flag for Office</button>`;
    html += '</div>';
  }

  html += '</div></div>';

  // Progress bar
  const reviewed = Object.keys(reconDecisions).length;
  html += `<p style="font-size:0.75rem;color:var(--text-dim);margin-top:8px;text-align:center;">${reviewed} of ${reconDifferences.length} reviewed</p>`;

  container.innerHTML = html;
}

function reconNav(dir) {
  reconCurrentDiff = Math.max(0, Math.min(reconDifferences.length - 1, reconCurrentDiff + dir));
  renderDiffStepper();
}

function reconAcceptBilling(idx) {
  const d = reconDifferences[idx];
  const key = `${d.date}_${d.billingCase ? d.billingCase.startTime : 'none'}_${d.billingCase ? d.billingCase.cptCode : 'tc'}`;

  if (d.trackerCase && d.billingCase) {
    // Back-calculate baseUnits so calcCasePoints matches billing total
    const tc = d.trackerCase;
    const shift = d.shift;
    const isOBShift = shift && ['OB_restricted','SF1','SF2'].includes(shift.assignmentType);
    const obMult = (isOBShift && !tc.isORCase) ? 2 : 1;
    const addOns = calcAddOnPoints(tc);
    let caseStartMin = timeToMinutes(tc.startTime);
    let caseEndMin = timeToMinutes(tc.endTime);
    if (caseEndMin <= caseStartMin) caseEndMin += 1440;
    const caseHours = (caseEndMin - caseStartMin) / 60;
    const tm = getTimeMultiplier(tc.physicalStatus, shift ? shift.isHoliday : false, shift ? isWeekend(shift.date) : false, caseStartMin, tc.isHighRiskPeds);
    const timePts = caseHours * tm * 6;
    const emergPts = tc.isEmergency ? 1 : 0;
    const medPts = tc.isMedicalProc ? 0.20 * (parseFloat(tc.medicalUnits) || 0) : 0;
    const acutePts = tc.isAcutePain ? 0.375 * (parseFloat(tc.acutePainUnits) || 0) : 0;

    const targetBase = d.billingCase.totalPoints / obMult - timePts - medPts - acutePts - emergPts - addOns;
    const pct = tc.isSharedCase ? ((parseFloat(tc.sharedStartupPct) || 50) / 100) : 1;
    if (pct > 0) {
      tc.baseUnits = String(round2(targetBase / (0.5 * pct)));
    }

    // Update in data array
    const realCase = data.cases.find(c => c.id === tc.id);
    if (realCase) realCase.baseUnits = tc.baseUnits;
    saveData(data);
    showToast(`Case updated to match billing (${d.billingCase.totalPoints.toFixed(1)} pts)`);
  }

  reconDecisions[key] = { accepted: 'billing', flagged: false };
  saveReconDecisions();
  updateHeaderPoints();
  if (reconCurrentDiff < reconDifferences.length - 1) reconCurrentDiff++;
  renderDiffStepper();
  renderFlaggedSection();
}

function reconAcceptApp(idx) {
  const d = reconDifferences[idx];
  const key = `${d.date}_${d.billingCase ? d.billingCase.startTime : 'none'}_${d.billingCase ? d.billingCase.cptCode : 'tc'}`;
  reconDecisions[key] = { accepted: 'app', flagged: false };
  saveReconDecisions();
  if (reconCurrentDiff < reconDifferences.length - 1) reconCurrentDiff++;
  renderDiffStepper();
  renderFlaggedSection();
}

function reconFlag(idx) {
  const d = reconDifferences[idx];
  const key = `${d.date}_${d.billingCase ? d.billingCase.startTime : 'none'}_${d.billingCase ? d.billingCase.cptCode : 'tc'}`;
  reconDecisions[key] = { accepted: '', flagged: true };
  saveReconDecisions();

  // Add to flagged items
  reconFlaggedItems.push({
    type: 'case',
    date: d.date,
    startTime: d.billingCase ? d.billingCase.startTime : (d.trackerCase ? d.trackerCase.startTime : ''),
    endTime: d.billingCase ? d.billingCase.endTime : (d.trackerCase ? d.trackerCase.endTime : ''),
    accountNumber: d.billingCase ? (d.billingCase.accountNumber || '') : '',
    billingPts: d.billingPts,
    trackerPts: d.trackerPts,
    diffType: d.type
  });

  if (reconCurrentDiff < reconDifferences.length - 1) reconCurrentDiff++;
  renderDiffStepper();
  renderFlaggedSection();
}

function renderFlaggedSection(monthLabel) {
  const section = document.getElementById('reconFlaggedSection');
  if (!section) return;

  if (!monthLabel) {
    const mn = ['January','February','March','April','May','June','July','August','September','October','November','December'];
    monthLabel = `${mn[pMonth]} ${pYear}`;
  }

  // Collect all flagged from decisions
  const allFlagged = [];
  reconDifferences.forEach(d => {
    const key = `${d.date}_${d.billingCase ? d.billingCase.startTime : 'none'}_${d.billingCase ? d.billingCase.cptCode : 'tc'}`;
    if (reconDecisions[key] && reconDecisions[key].flagged) {
      allFlagged.push({
        type: 'case', date: d.date,
        startTime: d.billingCase ? d.billingCase.startTime : (d.trackerCase ? d.trackerCase.startTime : ''),
        endTime: d.billingCase ? d.billingCase.endTime : (d.trackerCase ? d.trackerCase.endTime : ''),
        accountNumber: d.billingCase ? (d.billingCase.accountNumber || '') : '',
        billingPts: d.billingPts, trackerPts: d.trackerPts, diffType: d.type
      });
    }
  });

  // Also include addon flags
  reconFlaggedItems.filter(f => f.type === 'addon').forEach(f => allFlagged.push(f));

  if (allFlagged.length === 0) {
    section.innerHTML = '';
    return;
  }

  let html = '<div class="card"><h2>Flagged Issues (' + allFlagged.length + ')</h2>';
  html += '<ul class="flagged-list">';
  allFlagged.forEach(f => {
    if (f.type === 'case') {
      const acct = f.accountNumber ? ` — Acct# ${f.accountNumber}` : '';
      if (f.diffType === 'missing_billing') {
        html += `<li>${formatDateShort(f.date)} — ${f.startTime || '?'}-${f.endTime || '?'}${acct} — Missing from billing (App: ${f.trackerPts.toFixed(1)} pts)</li>`;
      } else if (f.diffType === 'missing_tracker') {
        html += `<li>${formatDateShort(f.date)} — ${f.startTime || '?'}-${f.endTime || '?'}${acct} — Missing from app (Billing: ${f.billingPts.toFixed(1)} pts)</li>`;
      } else {
        html += `<li>${formatDateShort(f.date)} — ${f.startTime || '?'}-${f.endTime || '?'}${acct} — Billing: ${f.billingPts.toFixed(1)} pts, App: ${f.trackerPts.toFixed(1)} pts (${Math.abs(f.billingPts - f.trackerPts).toFixed(1)} diff)</li>`;
      }
    } else if (f.type === 'addon') {
      html += `<li>${formatDateShort(f.date)} — ${f.description}</li>`;
    }
  });
  html += '</ul>';

  // Email generation
  html += '<div style="margin-top:16px;">';
  html += '<button class="btn btn-primary" onclick="generateReconEmail()" style="width:100%;margin-bottom:8px;">Generate Email</button>';
  html += '<div id="reconEmailPreview"></div>';
  html += '</div></div>';

  section.innerHTML = html;
}

function generateReconEmail() {
  const mn = ['January','February','March','April','May','June','July','August','September','October','November','December'];
  const monthLabel = `${mn[pMonth]} ${pYear}`;
  const userName = settings.name || '[Your Name]';

  // Collect all flagged
  const allFlagged = [];
  reconDifferences.forEach(d => {
    const key = `${d.date}_${d.billingCase ? d.billingCase.startTime : 'none'}_${d.billingCase ? d.billingCase.cptCode : 'tc'}`;
    if (reconDecisions[key] && reconDecisions[key].flagged) {
      allFlagged.push({
        type: 'case', date: d.date,
        startTime: d.billingCase ? d.billingCase.startTime : (d.trackerCase ? d.trackerCase.startTime : ''),
        endTime: d.billingCase ? d.billingCase.endTime : (d.trackerCase ? d.trackerCase.endTime : ''),
        accountNumber: d.billingCase ? (d.billingCase.accountNumber || '') : '',
        billingPts: d.billingPts, trackerPts: d.trackerPts, diffType: d.type
      });
    }
  });
  reconFlaggedItems.filter(f => f.type === 'addon').forEach(f => allFlagged.push(f));

  let emailText = `Subject: Billing Discrepancies — ${monthLabel}\n\nHi,\n\nI found the following discrepancies during reconciliation for ${monthLabel}:\n\n`;

  allFlagged.forEach((f, i) => {
    if (f.type === 'case') {
      const dateFormatted = f.date.replace(/(\d{4})-(\d{2})-(\d{2})/, '$2/$3/$1');
      const acct = f.accountNumber ? `, Account: ${f.accountNumber}` : '';
      if (f.diffType === 'missing_billing') {
        emailText += `${i + 1}. Date: ${dateFormatted}, Time: ${f.startTime || '?'}-${f.endTime || '?'}${acct}\n   Case not found in billing document (App: ${f.trackerPts.toFixed(1)} pts)\n\n`;
      } else if (f.diffType === 'missing_tracker') {
        emailText += `${i + 1}. Date: ${dateFormatted}, Time: ${f.startTime || '?'}-${f.endTime || '?'}${acct}\n   Case not found in app (Billing: ${f.billingPts.toFixed(1)} pts)\n\n`;
      } else {
        const diff = Math.abs(f.billingPts - f.trackerPts);
        emailText += `${i + 1}. Date: ${dateFormatted}, Time: ${f.startTime || '?'}-${f.endTime || '?'}${acct}\n   Billing: ${f.billingPts.toFixed(1)} pts | App: ${f.trackerPts.toFixed(1)} pts (${diff.toFixed(1)} pt difference)\n\n`;
      }
    } else if (f.type === 'addon') {
      emailText += `${i + 1}. Add-on discrepancy on ${f.date.replace(/(\d{4})-(\d{2})-(\d{2})/, '$2/$3/$1')}: ${f.description}\n\n`;
    }
  });

  emailText += `Please review and advise.\n\nThanks,\n${userName}`;

  const preview = document.getElementById('reconEmailPreview');
  preview.innerHTML = `<div class="email-preview">${escHtml(emailText)}</div>`;
  preview.innerHTML += '<button class="btn btn-primary" onclick="copyReconEmail()" style="width:100%;margin-top:8px;">Copy to Clipboard</button>';

  // Store for clipboard
  preview.dataset.emailText = emailText;
}

function copyReconEmail() {
  const preview = document.getElementById('reconEmailPreview');
  const text = preview.dataset.emailText || '';
  navigator.clipboard.writeText(text).then(() => {
    showToast('Email copied to clipboard!');
  }).catch(() => {
    showToast('Failed to copy — try selecting and copying manually');
  });
}

// ================================================================
// BILLING SHEET SCAN — ASA CODE LOOKUP
// ================================================================
const ASA_BASE_UNITS = {
  // Head
  '00100': 5, '00102': 6, '00103': 5, '00104': 4, '00120': 5, '00124': 4,
  '00126': 4, '00140': 5, '00142': 4, '00144': 6, '00145': 6, '00147': 4,
  '00148': 4, '00160': 7, '00162': 7, '00164': 4, '00170': 5, '00172': 6,
  '00174': 6, '00176': 7, '00190': 5, '00192': 7,
  // Neck
  '00210': 11, '00211': 11, '00212': 5, '00214': 4, '00215': 5, '00216': 7,
  '00218': 10, '00220': 6, '00222': 6,
  // Thorax
  '00300': 5, '00320': 5, '00322': 6, '00326': 6, '00350': 5, '00352': 5,
  '00400': 6, '00402': 6, '00404': 6, '00406': 8, '00410': 7, '00450': 5,
  '00454': 4, '00470': 10, '00472': 10, '00474': 13,
  // Spine & spinal cord
  '00500': 10, '00520': 5, '00522': 4, '00524': 10, '00528': 6, '00530': 6,
  '00532': 5, '00534': 13, '00537': 6, '00539': 10, '00540': 6, '00541': 6,
  '00542': 6, '00546': 7, '00548': 10, '00550': 7,
  // Upper abdomen
  '00600': 4, '00604': 4, '00620': 7, '00625': 7, '00626': 7, '00630': 7,
  '00632': 7, '00634': 7, '00635': 5, '00640': 7, '00670': 5, '00700': 4,
  '00702': 4,
  // Lower abdomen
  '00730': 5, '00731': 5, '00732': 5, '00740': 6, '00750': 4, '00752': 6,
  '00754': 7, '00756': 7, '00770': 7, '00790': 7, '00792': 7, '00794': 8,
  '00796': 7, '00797': 9,
  // Perineum
  '00800': 3, '00802': 5, '00810': 4, '00812': 5, '00820': 3, '00830': 5,
  '00832': 5, '00834': 4, '00836': 4, '00840': 6, '00842': 7, '00844': 7,
  '00846': 7, '00848': 4, '00851': 7, '00860': 5, '00862': 7, '00864': 4,
  '00865': 6, '00866': 6, '00868': 5, '00870': 5, '00872': 5, '00873': 7,
  '00880': 5, '00882': 5, '00902': 7, '00904': 5, '00906': 3, '00908': 4,
  '00910': 5, '00912': 5, '00914': 4, '00916': 5, '00918': 4, '00920': 3,
  '00921': 4, '00922': 4, '00924': 4, '00926': 4, '00928': 3, '00930': 5,
  '00932': 3, '00934': 5, '00936': 5, '00938': 3, '00940': 5, '00942': 5,
  '00944': 4, '00948': 4, '00950': 5, '00952': 5,
  // Upper leg
  '01200': 4, '01202': 7, '01210': 3, '01212': 5, '01214': 4, '01215': 5,
  '01220': 5, '01230': 3, '01232': 4, '01234': 4, '01250': 5, '01260': 7,
  '01270': 4, '01272': 8,
  // Knee & popliteal
  '01320': 5, '01340': 3, '01360': 5, '01380': 3, '01382': 7, '01390': 4,
  '01392': 4, '01400': 3, '01402': 6, '01404': 4, '01420': 5, '01430': 4,
  '01432': 3, '01440': 4, '01442': 7, '01444': 6,
  // Lower leg, ankle & foot
  '01462': 3, '01464': 4, '01470': 3, '01472': 3, '01474': 5, '01480': 3,
  '01482': 3, '01484': 3, '01486': 4, '01490': 3, '01500': 3, '01502': 3,
  '01520': 5, '01522': 4,
  // Shoulder & axilla
  '01610': 3, '01620': 5, '01622': 4, '01630': 4, '01634': 4, '01636': 4,
  '01638': 4, '01650': 4, '01652': 5, '01654': 5, '01656': 4, '01670': 4,
  // Upper arm & elbow
  '01710': 3, '01712': 5, '01714': 4, '01716': 4, '01730': 3, '01732': 5,
  '01740': 4, '01742': 6, '01744': 5, '01756': 3, '01758': 3, '01760': 3,
  '01770': 4, '01772': 4, '01780': 5, '01782': 7,
  // Forearm, wrist & hand
  '01810': 3, '01820': 3, '01829': 3, '01830': 3, '01832': 4, '01840': 3,
  '01842': 4, '01844': 3, '01850': 3, '01852': 3, '01860': 3, '01916': 5,
  '01920': 7, '01922': 7, '01924': 10, '01925': 7, '01926': 8, '01930': 5,
  '01931': 5, '01932': 5, '01933': 7, '01935': 5, '01936': 5, '01951': 3,
  '01952': 3, '01953': 5, '01958': 3, '01960': 3, '01961': 3, '01962': 5,
  '01963': 8, '01965': 5, '01966': 3, '01967': 5, '01968': 5, '01969': 7,
  '01990': 7, '01991': 7, '01992': 7, '01996': 3, '01999': 0,
  // Burn excisions / debridement
  '01951': 3, '01952': 3, '01953': 5,
  // Radiological
  '01916': 5, '01920': 7, '01922': 7, '01924': 10, '01925': 7, '01926': 8,
  // Obstetric
  '01958': 3, '01960': 3, '01961': 3, '01962': 5, '01963': 8, '01967': 5, '01968': 5, '01969': 7,
  // Other
  '01990': 7, '01991': 7, '01992': 7, '01999': 0,
  // Invasive / cardiac
  '00560': 15, '00561': 15, '00562': 15, '00563': 15, '00566': 25, '00567': 15,
  '00580': 10
};

// ================================================================
// BILLING SHEET SCAN — PARSER
// ================================================================
function parseBillingSheetText(text) {
  const cases = [];
  const lines = text.split('\n').map(l => l.trim()).filter(l => l.length > 0);
  const fullText = lines.join('\n');

  // Strategy: Look for ASA codes (5-digit numbers starting with 0) and times
  // The sheet has 4 case blocks; each block has a code, start/stop, and modifiers

  // Find all 5-digit ASA codes (00xxx or 01xxx)
  const asaPattern = /\b(0[01]\d{3})\b/g;
  const asaMatches = [];
  let m;
  while ((m = asaPattern.exec(fullText)) !== null) {
    asaMatches.push({ code: m[1], index: m.index });
  }

  if (asaMatches.length === 0) return cases;

  // Find all military times (4-digit HHMM or HH:MM)
  // Build set of ASA codes found to filter them out of time matches
  const asaCodeSet = new Set(asaMatches.map(a => a.code));
  const timePattern = /\b(\d{2}):?(\d{2})\b/g;
  const allTimes = [];
  while ((m = timePattern.exec(fullText)) !== null) {
    const h = parseInt(m[1]), min = parseInt(m[2]);
    if (h >= 0 && h <= 23 && min >= 0 && min <= 59 && h + min > 0) {
      const digits = m[1] + m[2];
      // Skip if it matches an ASA code or looks like a year (19xx, 20xx)
      if (asaCodeSet.has(digits)) continue;
      if (digits.startsWith('19') || digits.startsWith('20')) continue;
      allTimes.push({ time: String(h).padStart(2, '0') + ':' + String(min).padStart(2, '0'), index: m.index });
    }
  }

  // Segment text by ASA code positions — each code starts a new case block
  for (let i = 0; i < asaMatches.length; i++) {
    const blockStart = asaMatches[i].index;
    const blockEnd = i + 1 < asaMatches.length ? asaMatches[i + 1].index : fullText.length;
    const blockText = fullText.substring(blockStart, blockEnd);
    const blockTextUpper = blockText.toUpperCase();

    const asaCode = asaMatches[i].code;
    const baseUnits = ASA_BASE_UNITS[asaCode] || 0;

    // Find valid times in this block (ASA codes and years already filtered above)
    const validTimes = allTimes.filter(t => t.index > blockStart && t.index < blockEnd);

    let startTime = '', endTime = '';
    // Look for Start: and Stop: labels
    const startMatch = blockText.match(/start[:\s]*(\d{2}):?(\d{2})/i);
    const stopMatch = blockText.match(/stop[:\s]*(\d{2}):?(\d{2})/i);
    if (startMatch) {
      startTime = String(parseInt(startMatch[1])).padStart(2, '0') + ':' + String(parseInt(startMatch[2])).padStart(2, '0');
    }
    if (stopMatch) {
      endTime = String(parseInt(stopMatch[1])).padStart(2, '0') + ':' + String(parseInt(stopMatch[2])).padStart(2, '0');
    }
    // Fallback: use first two times if labels not found
    if (!startTime && validTimes.length >= 1) startTime = validTimes[0].time;
    if (!endTime && validTimes.length >= 2) endTime = validTimes[1].time;

    // Check modifiers — broadened checkbox symbols for OCR variance
    const checkMark = /[xXvV✓✗☒☑√✔✘\|\/\\+><\]\)}/;
    const isEmergency = /emergency/i.test(blockText) && checkMark.test(
      blockText.substring(blockText.search(/emergency/i) - 8, blockText.search(/emergency/i) + 15)
    ) || /[xXvV✓✗☒☑√✔✘]\s*emergency/i.test(blockText);
    const isShared = /shared/i.test(blockText) && checkMark.test(
      blockText.substring(Math.max(0, blockText.search(/shared/i) - 8), blockText.search(/shared/i) + 12)
    ) || /[xXvV✓✗☒☑√✔✘]\s*shared/i.test(blockText);

    // Check nerve block types — "PLXS" matches the actual form label "Brachial PLXS"
    let nerveBlock = 'none';
    const nbChecks = [
      { pattern: /brachial\s*pl[xks]+/i, type: 'brachial_plexus' },
      { pattern: /sciatic/i, type: 'other' },
      { pattern: /femoral/i, type: 'other' },
      { pattern: /abdominal\s*n?b?/i, type: 'other' },
      { pattern: /chest\s*wall/i, type: 'other' },
      { pattern: /paravertebral|esp/i, type: 'other' }
    ];
    for (const nb of nbChecks) {
      if (nb.pattern.test(blockText)) {
        const nbIdx = blockText.search(nb.pattern);
        const nbRegion = blockText.substring(Math.max(0, nbIdx - 12), nbIdx + 25);
        if (checkMark.test(nbRegion)) {
          nerveBlock = nb.type;
          break;
        }
      }
    }

    // Lumbar INJ / Thoracic INJ — check for single vs continuous
    let hasITMorphine = false;
    if (/lumbar\s*inj|thoracic\s*inj/i.test(blockText)) {
      const injIdx = blockText.search(/lumbar\s*inj|thoracic\s*inj/i);
      const injRegion = blockText.substring(Math.max(0, injIdx - 12), injIdx + 25);
      if (checkMark.test(injRegion)) {
        if (/single/i.test(blockTextUpper) && checkMark.test(
          blockText.substring(Math.max(0, blockText.search(/single/i) - 8), blockText.search(/single/i) + 15)
        )) {
          hasITMorphine = true;
        }
      }
    }

    // Other services — "Art" pattern requires nearby context to avoid false positives
    let hasCentralLine = false, hasArterialLine = false, hasTEE = false, hasBloodPatch = false, hasEmergIntub = false;
    const svcChecks = [
      { pattern: /\bCVC\b/i, set: () => hasCentralLine = true },
      { pattern: /\bArt(?:erial)?\b(?!\w)/i, set: () => hasArterialLine = true },
      { pattern: /\bTEE\b/i, set: () => hasTEE = true },
      { pattern: /blood\s*patch/i, set: () => hasBloodPatch = true },
      { pattern: /emerg\w*\s*intub/i, set: () => hasEmergIntub = true }
    ];
    for (const svc of svcChecks) {
      if (svc.pattern.test(blockText)) {
        const sIdx = blockText.search(svc.pattern);
        const sRegion = blockText.substring(Math.max(0, sIdx - 12), sIdx + 20);
        if (checkMark.test(sRegion)) svc.set();
      }
    }

    // Extract notes
    let notes = '';
    const notesMatch = blockText.match(/notes[:\s]+(.*?)(?:\n|$)/i);
    if (notesMatch && notesMatch[1].trim().length > 1) {
      notes = notesMatch[1].trim();
    }

    // Determine case type
    let caseType = 'standard';
    if (hasBloodPatch) caseType = 'epidural_blood_patch';
    else if (hasEmergIntub) caseType = 'emergency_intubation';

    cases.push({
      asaCode: asaCode,
      baseUnits: baseUnits,
      startTime: startTime,
      endTime: endTime,
      caseType: caseType,
      isEmergency: isEmergency,
      isShared: isShared,
      nerveBlock: nerveBlock,
      hasITMorphine: hasITMorphine,
      hasCentralLine: hasCentralLine,
      hasArterialLine: hasArterialLine,
      hasTEE: hasTEE,
      notes: notes
    });
  }

  return cases;
}

// ================================================================
// BILLING SHEET SCAN — PAGE LOGIC
// ================================================================
let scanParsedCases = [];

function initScanPage() {
  const dateInput = document.getElementById('scanDate');
  if (!dateInput.value) dateInput.value = workingDate || todayStr();
}

document.getElementById('scanCaptureArea').addEventListener('click', () => {
  document.getElementById('scanFileInput').click();
});

document.getElementById('scanFileInput').addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const preview = document.getElementById('scanPreviewImg');
  const reader = new FileReader();
  reader.onload = (ev) => {
    preview.src = ev.target.result;
    preview.classList.remove('hidden');
    document.getElementById('scanActions').classList.remove('hidden');
    document.getElementById('scanResultsArea').classList.add('hidden');
    setScanStatus('');
  };
  reader.readAsDataURL(file);
});

document.getElementById('scanRetakeBtn').addEventListener('click', () => {
  document.getElementById('scanFileInput').value = '';
  document.getElementById('scanPreviewImg').classList.add('hidden');
  document.getElementById('scanActions').classList.add('hidden');
  document.getElementById('scanResultsArea').classList.add('hidden');
  setScanStatus('');
  scanParsedCases = [];
});

// Preprocess image: grayscale, contrast boost, sharpen for better OCR
function preprocessScanImage(file) {
  return new Promise((resolve) => {
    const img = new Image();
    img.onload = () => {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = img.width;
      canvas.height = img.height;
      // Draw original
      ctx.drawImage(img, 0, 0);
      // Convert to grayscale and boost contrast
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const d = imageData.data;
      for (let i = 0; i < d.length; i += 4) {
        // Grayscale using luminance weights
        let gray = 0.299 * d[i] + 0.587 * d[i+1] + 0.114 * d[i+2];
        // Contrast stretch: push darks darker and lights lighter
        gray = ((gray / 255 - 0.5) * 1.6 + 0.5) * 255;
        // Threshold nudge: make near-white pixels fully white, darken text
        gray = gray > 180 ? 255 : gray < 80 ? 0 : gray;
        gray = Math.max(0, Math.min(255, gray));
        d[i] = d[i+1] = d[i+2] = gray;
      }
      ctx.putImageData(imageData, 0, 0);
      canvas.toBlob(blob => resolve(blob), 'image/png');
      URL.revokeObjectURL(img.src);
    };
    img.src = URL.createObjectURL(file);
  });
}

document.getElementById('scanProcessBtn').addEventListener('click', async () => {
  const fileInput = document.getElementById('scanFileInput');
  const file = fileInput.files[0];
  if (!file) { showToast('No image selected'); return; }

  setScanStatus('processing', 'Preprocessing image...');
  try {
    const preprocessed = await preprocessScanImage(file);
    await loadTesseract();
    setScanStatus('processing', 'Recognizing text...');
    const worker = await Tesseract.createWorker('eng');
    const { data } = await worker.recognize(preprocessed);
    await worker.terminate();

    const ocrText = data.text;
    const confidence = Math.round(data.confidence || 0);
    console.log('OCR confidence:', confidence + '%');
    console.log('OCR text:', ocrText);

    if (!ocrText || ocrText.trim().length < 10) {
      setScanStatus('error', 'Could not read text from image. Try a clearer photo.');
      showScanOCRDebug(ocrText, confidence);
      return;
    }

    setScanStatus('processing', 'Parsing billing sheet...');
    scanParsedCases = parseBillingSheetText(ocrText);

    if (scanParsedCases.length === 0) {
      setScanStatus('error', 'No cases found. Make sure the ASA codes are clearly visible.');
      showScanOCRDebug(ocrText, confidence);
      return;
    }

    setScanStatus('success', `Found ${scanParsedCases.length} case${scanParsedCases.length > 1 ? 's' : ''} (OCR ${confidence}% confidence)`);
    showScanOCRDebug(ocrText, confidence);
    renderScanCaseCards();
  } catch (err) {
    console.error('Scan error:', err);
    setScanStatus('error', 'OCR failed: ' + err.message);
  }
});

function setScanStatus(type, msg) {
  const el = document.getElementById('scanStatus');
  if (!type) { el.classList.add('hidden'); el.innerHTML = ''; return; }
  el.classList.remove('hidden');
  el.className = 'scan-status ' + type;
  if (type === 'processing') {
    el.innerHTML = '<div class="spinner"></div><span>' + msg + '</span>';
  } else {
    el.innerHTML = '<span>' + msg + '</span>';
  }
}

function showScanOCRDebug(ocrText, confidence) {
  const area = document.getElementById('scanResultsArea');
  area.classList.remove('hidden');
  let debugEl = document.getElementById('scanOCRDebug');
  if (!debugEl) {
    debugEl = document.createElement('details');
    debugEl.id = 'scanOCRDebug';
    debugEl.style.cssText = 'margin-top:12px;';
    area.prepend(debugEl);
  }
  debugEl.innerHTML = `<summary style="cursor:pointer;font-size:0.8rem;color:var(--text-dim);">Raw OCR Text (${confidence}% confidence)</summary><pre style="background:var(--bg);border:1px solid var(--border);border-radius:8px;padding:12px;font-size:0.72rem;white-space:pre-wrap;max-height:200px;overflow-y:auto;margin-top:8px;color:var(--text-dim);">${escHtml(ocrText || '(empty)')}</pre>`;
}

function renderScanCaseCards() {
  const area = document.getElementById('scanResultsArea');
  const container = document.getElementById('scanCaseCards');
  const countEl = document.getElementById('scanCaseCount');
  area.classList.remove('hidden');
  countEl.textContent = scanParsedCases.length + ' case' + (scanParsedCases.length !== 1 ? 's' : '');

  container.innerHTML = '';
  scanParsedCases.forEach((c, idx) => {
    const unitLabel = ASA_BASE_UNITS[c.asaCode] ? c.asaCode : 'Unknown';
    const tags = [];
    if (c.isEmergency) tags.push('<span class="scc-tag emergency">Emergency</span>');
    if (c.isShared) tags.push('<span class="scc-tag shared">Shared</span>');
    if (c.nerveBlock !== 'none') tags.push('<span class="scc-tag active">' + (c.nerveBlock === 'brachial_plexus' ? 'Brachial Plexus' : 'Nerve Block') + '</span>');
    if (c.hasITMorphine) tags.push('<span class="scc-tag active">IT Morphine</span>');
    if (c.hasCentralLine) tags.push('<span class="scc-tag active">CVC</span>');
    if (c.hasArterialLine) tags.push('<span class="scc-tag active">Art Line</span>');
    if (c.hasTEE) tags.push('<span class="scc-tag active">TEE</span>');

    const card = document.createElement('div');
    card.className = 'scan-case-card';
    card.innerHTML = `
      <div class="scc-header">
        <h4>Case ${idx + 1}</h4>
        <button class="scc-remove" data-idx="${idx}" title="Remove">&times;</button>
      </div>
      <div class="scc-row">
        <div class="scc-field">
          <label>ASA Code</label>
          <input type="text" value="${c.asaCode}" data-idx="${idx}" data-field="asaCode" maxlength="5">
        </div>
        <div class="scc-field">
          <label>Base Units</label>
          <input type="number" value="${c.baseUnits}" data-idx="${idx}" data-field="baseUnits" min="0" max="30">
        </div>
      </div>
      <div class="scc-row">
        <div class="scc-field">
          <label>Start</label>
          <input type="text" value="${c.startTime}" data-idx="${idx}" data-field="startTime" placeholder="HH:MM" maxlength="5">
        </div>
        <div class="scc-field">
          <label>Stop</label>
          <input type="text" value="${c.endTime}" data-idx="${idx}" data-field="endTime" placeholder="HH:MM" maxlength="5">
        </div>
      </div>
      <div class="scc-row">
        <div class="scc-field">
          <label>Case Type</label>
          <select data-idx="${idx}" data-field="caseType">
            <option value="standard" ${c.caseType === 'standard' ? 'selected' : ''}>Standard</option>
            <option value="epidural_blood_patch" ${c.caseType === 'epidural_blood_patch' ? 'selected' : ''}>Epidural Blood Patch</option>
            <option value="emergency_intubation" ${c.caseType === 'emergency_intubation' ? 'selected' : ''}>Emergency Intubation</option>
          </select>
        </div>
        <div class="scc-field">
          <label>Notes</label>
          <input type="text" value="${c.notes}" data-idx="${idx}" data-field="notes" placeholder="Surgeon, etc.">
        </div>
      </div>
      <div class="scc-tags">${tags.join('')}</div>
      <div style="margin-top:8px;display:flex;flex-wrap:wrap;gap:6px;">
        <label style="font-size:0.75rem;color:var(--text-dim);display:flex;align-items:center;gap:4px;">
          <input type="checkbox" data-idx="${idx}" data-field="isEmergency" ${c.isEmergency ? 'checked' : ''}> Emergency
        </label>
        <label style="font-size:0.75rem;color:var(--text-dim);display:flex;align-items:center;gap:4px;">
          <input type="checkbox" data-idx="${idx}" data-field="isShared" ${c.isShared ? 'checked' : ''}> Shared
        </label>
        <label style="font-size:0.75rem;color:var(--text-dim);display:flex;align-items:center;gap:4px;">
          <input type="checkbox" data-idx="${idx}" data-field="hasITMorphine" ${c.hasITMorphine ? 'checked' : ''}> IT Morphine
        </label>
        <label style="font-size:0.75rem;color:var(--text-dim);display:flex;align-items:center;gap:4px;">
          <input type="checkbox" data-idx="${idx}" data-field="hasCentralLine" ${c.hasCentralLine ? 'checked' : ''}> CVC
        </label>
        <label style="font-size:0.75rem;color:var(--text-dim);display:flex;align-items:center;gap:4px;">
          <input type="checkbox" data-idx="${idx}" data-field="hasArterialLine" ${c.hasArterialLine ? 'checked' : ''}> Art Line
        </label>
        <label style="font-size:0.75rem;color:var(--text-dim);display:flex;align-items:center;gap:4px;">
          <input type="checkbox" data-idx="${idx}" data-field="hasTEE" ${c.hasTEE ? 'checked' : ''}> TEE
        </label>
      </div>
      <div style="margin-top:6px;">
        <label style="font-size:0.75rem;color:var(--text-dim);">Nerve Block</label>
        <select data-idx="${idx}" data-field="nerveBlock" style="width:100%;padding:4px 6px;background:var(--bg);border:1px solid var(--border);border-radius:6px;color:var(--text);font-size:0.8rem;margin-top:2px;">
          <option value="none" ${c.nerveBlock === 'none' ? 'selected' : ''}>None</option>
          <option value="brachial_plexus" ${c.nerveBlock === 'brachial_plexus' ? 'selected' : ''}>Brachial Plexus</option>
          <option value="other_nerve" ${c.nerveBlock === 'other_nerve' ? 'selected' : ''}>Other Nerve Block</option>
        </select>
      </div>
    `;
    container.appendChild(card);
  });

  // Bind events
  container.querySelectorAll('.scc-remove').forEach(btn => {
    btn.addEventListener('click', () => {
      const idx = parseInt(btn.dataset.idx);
      scanParsedCases.splice(idx, 1);
      renderScanCaseCards();
    });
  });

  container.querySelectorAll('input[data-field], select[data-field]').forEach(el => {
    const handler = () => {
      const idx = parseInt(el.dataset.idx);
      const field = el.dataset.field;
      if (!scanParsedCases[idx]) return;
      if (el.type === 'checkbox') {
        scanParsedCases[idx][field] = el.checked;
      } else if (el.type === 'number') {
        scanParsedCases[idx][field] = parseInt(el.value) || 0;
      } else {
        scanParsedCases[idx][field] = el.value;
      }
      // Auto-lookup base units when ASA code changes
      if (field === 'asaCode' && el.value.length === 5) {
        const units = ASA_BASE_UNITS[el.value];
        if (units !== undefined) {
          scanParsedCases[idx].baseUnits = units;
          const unitsInput = container.querySelector(`input[data-idx="${idx}"][data-field="baseUnits"]`);
          if (unitsInput) unitsInput.value = units;
        }
      }
    };
    el.addEventListener('change', handler);
    if (el.type === 'text' || el.type === 'number') el.addEventListener('input', handler);
  });

  // Bind military time formatting on start/stop inputs
  container.querySelectorAll('input[data-field="startTime"], input[data-field="endTime"]').forEach(inp => {
    bindMilTimeInput(inp);
  });
}

document.getElementById('scanImportBtn').addEventListener('click', () => {
  if (scanParsedCases.length === 0) { showToast('No cases to import'); return; }

  const scanDate = document.getElementById('scanDate').value;
  if (!scanDate) { showToast('Please set the sheet date'); return; }

  const newCases = [];
  const existingKeys = new Set(data.cases.map(c => c.shiftDate + '|' + c.startTime));

  for (const sc of scanParsedCases) {
    if (!sc.startTime) continue; // skip cases with no start time
    const key = scanDate + '|' + sc.startTime;
    if (existingKeys.has(key)) continue; // skip duplicates

    newCases.push({
      id: genId(),
      caseType: sc.caseType || 'standard',
      procedure: sc.asaCode || '',
      baseUnits: sc.baseUnits || 0,
      physicalStatus: 'P2',
      startTime: sc.startTime || '',
      endTime: sc.endTime || '',
      shiftDate: scanDate,
      isEmergency: sc.isEmergency || false,
      isMedicalProc: false,
      medicalUnits: 0,
      isAcutePain: false,
      acutePainUnits: 0,
      isHighRiskPeds: false,
      isORCase: false,
      isSharedCase: sc.isShared || false,
      sharedStartupPct: 50,
      nerveBlock: sc.nerveBlock || 'none',
      hasCentralLine: sc.hasCentralLine || false,
      hasArterialLine: sc.hasArterialLine || false,
      hasPAC: false,
      hasTEEAddOn: sc.hasTEE || false,
      hasITMorphine: sc.hasITMorphine || false,
      notes: sc.notes || '',
      timestamp: new Date().toISOString()
    });
  }

  if (newCases.length === 0) {
    showToast('No new cases to import (all duplicates or missing start times)');
    return;
  }

  // Create placeholder shift if none exists
  if (!data.shifts[scanDate]) {
    let earliest = '23:59', latest = '00:00';
    newCases.forEach(c => {
      if (c.startTime && c.startTime < earliest) earliest = c.startTime;
      if (c.endTime && c.endTime > latest) latest = c.endTime;
    });
    const st = earliest || '07:00';
    const en = latest || '17:00';
    data.shifts[scanDate] = {
      date: scanDate, assignmentType: 'OR',
      startTime: st, endTime: en,
      timeEntries: [{ start: st, end: en }],
      isHoliday: false, forcedOff: false, subspecCoverage: false,
      teeCount: 0, supervisionStart: '', supervisionEnd: '', preCallStart: '', preCallEnd: '', tempCoverage: []
    };
    showToast(`Created placeholder OR shift for ${formatDateShort(scanDate)}`);
  }

  data.cases.push(...newCases);
  saveData(data);
  updateHeaderPoints();

  const skipped = scanParsedCases.length - newCases.length;
  let msg = `Imported ${newCases.length} case${newCases.length > 1 ? 's' : ''}`;
  if (skipped > 0) msg += ` (${skipped} skipped)`;
  showToast(msg);

  // Reset scan page
  scanParsedCases = [];
  document.getElementById('scanResultsArea').classList.add('hidden');
  document.getElementById('scanPreviewImg').classList.add('hidden');
  document.getElementById('scanActions').classList.add('hidden');
  document.getElementById('scanFileInput').value = '';
  setScanStatus('success', msg);
});

// ================================================================
// SERVICE WORKER REGISTRATION
// ================================================================
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('sw.js').catch(() => {});
}

// ================================================================
// AUTH — SIGN IN / SIGN OUT
// ================================================================
document.getElementById('googleSignInBtn').addEventListener('click', async () => {
  const errEl = document.getElementById('authError');
  const loadEl = document.getElementById('authLoading');
  errEl.classList.add('hidden');
  loadEl.classList.remove('hidden');
  try {
    const provider = new firebase.auth.GoogleAuthProvider();
    await auth.signInWithPopup(provider);
  } catch(err) {
    console.error('Sign-in error:', err);
    loadEl.classList.add('hidden');
    errEl.textContent = err.message || 'Sign-in failed';
    errEl.classList.remove('hidden');
  }
});

document.getElementById('signOutBtn').addEventListener('click', async () => {
  if (!confirm('Sign out? Your data is saved in the cloud.')) return;
  firestoreSyncEnabled = false;
  currentUser = null;
  await auth.signOut();
  document.getElementById('authOverlay').classList.remove('hidden');
});

function updateAccountUI(user) {
  if (!user) return;
  const photo = document.getElementById('accountPhoto');
  const name = document.getElementById('accountName');
  const email = document.getElementById('accountEmail');
  photo.src = user.photoURL || '';
  photo.style.display = user.photoURL ? '' : 'none';
  name.textContent = user.displayName || 'User';
  email.textContent = user.email || '';
}

// ================================================================
// AUTH STATE LISTENER
// ================================================================
auth.onAuthStateChanged(async (user) => {
  if (user) {
    currentUser = user;
    document.getElementById('authLoading').classList.add('hidden');

    // Load data from Firestore
    const result = await loadFromFirestore(user.uid);
    await loadSettingsFromFirestore(user.uid);

    firestoreSyncEnabled = true;
    updateAccountUI(user);
    document.getElementById('authOverlay').classList.add('hidden');

    // Re-run migration & init with cloud data
    migrateData(data);
    initApp();

    if (result === 'migrated') {
      showToast('Local data synced to cloud');
    } else if (result === 'loaded') {
      showToast('Data loaded from cloud');
    }
  } else {
    // Not signed in — show auth overlay
    currentUser = null;
    firestoreSyncEnabled = false;
    document.getElementById('authOverlay').classList.remove('hidden');
  }
});

// ================================================================
// INIT
// ================================================================
function initApp() {
  initMilTimeInputs();
  setWorkingDate(todayStr());
  renderTemplates();
  updateHeaderPoints();
  updateReconMonthLabels();
  updateCLMonthLabel();
  updateSupervisionOverlayVisibility();
  checkEndTimeNotification();
}

// Run init immediately with localStorage data (will re-run after auth)
initApp();
</script>

</body>
</html>
