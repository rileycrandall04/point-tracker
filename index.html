<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="theme-color" content="#0f172a">
<title>MWA Point Tracker</title>
<link rel="manifest" href="manifest.json">
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
<script src="https://accounts.google.com/gsi/client" async></script>
<script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore-compat.js"></script>
<style>
:root {
  --bg: #0f172a;
  --surface: #1e293b;
  --surface2: #334155;
  --border: #475569;
  --text: #f1f5f9;
  --text-dim: #94a3b8;
  --primary: #3b82f6;
  --primary-hover: #2563eb;
  --accent: #10b981;
  --accent2: #f59e0b;
  --danger: #ef4444;
  --purple: #8b5cf6;
  --radius: 10px;
  --bottom-nav: 64px;
  --header-h: 56px;
}

* { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

html, body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: var(--bg);
  color: var(--text);
  min-height: 100vh;
  min-height: 100dvh;
  overflow-x: hidden;
}

/* ===== HEADER ===== */
header {
  background: var(--surface);
  border-bottom: 1px solid var(--border);
  padding: 0 16px;
  height: var(--header-h);
  display: flex;
  align-items: center;
  justify-content: space-between;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  z-index: 100;
}
header > * { flex: 1; }
header > .header-date-btn, header > .header-nav-btn { flex: 0 0 auto; }

header h1 { font-size: 1.1rem; font-weight: 700; color: var(--primary); min-width: 0; }
.header-pts { text-align: right; line-height: 1.2; }
.header-pts .daily { font-size: 0.95rem; color: var(--accent); font-weight: 700; }
.header-pts .monthly { font-size: 0.7rem; color: var(--text-dim); font-weight: 500; }
.header-pts .pace { font-size: 0.62rem; font-weight: 600; }
.header-pts .pace.ahead { color: var(--accent); }
.header-pts .pace.behind { color: var(--accent2); }
.header-nav-btn {
  background: transparent;
  border: none;
  border-radius: 8px;
  color: #fff;
  width: 40px;
  height: 40px;
  font-size: 1rem;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
}
.header-date-btn {
  background: var(--surface2);
  border: 1px solid var(--border);
  border-radius: 8px;
  color: var(--text);
  padding: 8px 18px;
  font-size: 1.05rem;
  font-weight: 600;
  cursor: pointer;
  min-height: 44px;
  display: flex;
  align-items: center;
  justify-content: center;
}

/* ===== BOTTOM NAV ===== */
.bottom-nav {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  height: var(--bottom-nav);
  background: var(--surface);
  border-top: 1px solid var(--border);
  display: flex;
  z-index: 100;
  padding-bottom: env(safe-area-inset-bottom, 0);
}

.bottom-nav button {
  flex: 1;
  background: none;
  border: none;
  color: var(--text-dim);
  font-size: 0.65rem;
  font-weight: 500;
  cursor: pointer;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 3px;
  min-height: 44px;
  padding: 4px 2px;
  transition: color 0.2s;
}

.bottom-nav button .nav-icon {
  font-size: 1.3rem; line-height: 1;
  width: 36px; height: 28px; border-radius: 14px;
  display: flex; align-items: center; justify-content: center;
  transition: background 0.2s;
}
.bottom-nav button.active { color: var(--primary); }
.bottom-nav button.active .nav-icon { background: rgba(59,130,246,0.15); }
.bottom-nav button:active { color: var(--primary); }

/* ===== DRAWER ===== */
.drawer-backdrop {
  position: fixed; inset: 0; z-index: 200;
  background: rgba(0,0,0,0.5); opacity: 0;
  transition: opacity 0.3s; display: none;
}
.drawer-backdrop.visible { opacity: 1; pointer-events: auto; }
.drawer-panel {
  position: fixed; bottom: var(--bottom-nav); right: 8px; z-index: 201;
  background: var(--surface); border-radius: 12px;
  width: 200px; border: 1px solid var(--border);
  transform: translateY(10px); opacity: 0; transition: transform 0.2s ease, opacity 0.2s ease;
  padding: 8px 0; pointer-events: none;
  box-shadow: 0 -4px 20px rgba(0,0,0,0.3);
}
.drawer-panel.open { transform: translateY(0); opacity: 1; pointer-events: auto; }
.drawer-handle {
  display: none;
}
.drawer-item {
  display: flex; align-items: center; gap: 12px;
  padding: 12px 20px; min-height: 48px;
  cursor: pointer; transition: background 0.15s;
  color: var(--text); font-size: 0.95rem;
}
.drawer-item:hover { background: var(--surface2); }
.drawer-item .drawer-icon { font-size: 1.2rem; width: 28px; text-align: center; }

/* ===== PAGES ===== */
.page {
  display: none;
  padding: calc(var(--header-h) + 12px) 12px calc(var(--bottom-nav) + 16px);
  max-width: 600px;
  margin: 0 auto;
}
.page.active { display: block; }

/* ===== CARDS ===== */
.card {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 16px;
  margin-bottom: 12px;
}

.card h2 { font-size: 1rem; margin-bottom: 12px; color: var(--text); }
.card h3 { font-size: 0.9rem; margin-bottom: 8px; color: var(--text-dim); }

.card-collapse-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  cursor: pointer;
  min-height: 44px;
}

.card-collapse-header .arrow { transition: transform 0.2s; color: var(--text-dim); }
.card-collapse-header .arrow.open { transform: rotate(180deg); }
.card-collapse-body { overflow: hidden; transition: max-height 0.3s ease; }

/* ===== FORMS ===== */
.form-group { margin-bottom: 12px; }

.form-group label {
  display: block;
  font-size: 0.8rem;
  color: var(--text-dim);
  margin-bottom: 4px;
  font-weight: 500;
}

.form-row { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
.form-row-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px; }

input, select, textarea {
  width: 100%;
  padding: 10px 12px;
  background: var(--surface2);
  border: 1px solid var(--border);
  border-radius: 6px;
  color: var(--text);
  font-size: 16px; /* prevents iOS zoom */
  outline: none;
  transition: border-color 0.2s;
  min-height: 44px;
}

input:focus, select:focus, textarea:focus { border-color: var(--primary); }
textarea { resize: vertical; min-height: 60px; }

.checkbox-group {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 8px 0;
  min-height: 44px;
}

.checkbox-group input[type="checkbox"] {
  width: 22px;
  height: 22px;
  accent-color: var(--primary);
  cursor: pointer;
  flex-shrink: 0;
}

.checkbox-group label {
  font-size: 0.9rem;
  color: var(--text);
  cursor: pointer;
  margin-bottom: 0;
}

/* ===== BUTTONS ===== */
.btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: 12px 20px;
  border: none;
  border-radius: 6px;
  font-size: 0.95rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
  gap: 6px;
  min-height: 44px;
}

.btn-primary { background: var(--primary); color: white; width: 100%; }
.btn-primary:hover { background: var(--primary-hover); }
.btn-primary:active { transform: scale(0.98); }
.btn-accent { background: var(--accent); color: white; }
.btn-danger { background: var(--danger); color: white; padding: 8px 14px; font-size: 0.85rem; }
.btn-sm { padding: 8px 14px; font-size: 0.85rem; }
.btn-outline { background: transparent; border: 1px solid var(--border); color: var(--text-dim); }
.btn-outline:hover { border-color: var(--primary); color: var(--primary); }

/* ===== BADGES ===== */
.point-badge {
  display: inline-block;
  background: var(--primary);
  color: white;
  padding: 3px 10px;
  border-radius: 20px;
  font-size: 0.8rem;
  font-weight: 600;
}
.point-badge.large { font-size: 1.1rem; padding: 4px 14px; }
.point-badge.green { background: var(--accent); }
.point-badge.yellow { background: var(--accent2); color: #1e293b; }

/* ===== SUMMARY GRID ===== */
.summary-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 12px; }

.summary-item {
  background: var(--surface2);
  border-radius: 8px;
  padding: 12px;
  text-align: center;
}

.summary-item .label { font-size: 0.75rem; color: var(--text-dim); margin-bottom: 4px; }
.summary-item .value { font-size: 1.3rem; font-weight: 700; }
.summary-item .value.blue { color: var(--primary); }
.summary-item .value.green { color: var(--accent); }
.summary-item .value.yellow { color: var(--accent2); }
.summary-item .value.purple { color: var(--purple); }

/* (case type grids removed — now using select dropdowns) */

/* ===== LISTS ===== */
.case-list-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px 0;
  border-bottom: 1px solid var(--surface2);
  gap: 8px;
}
.case-list-item:last-child { border-bottom: none; }
.case-list-item .info { flex: 1; min-width: 0; }
.case-list-item .info h4 { font-size: 0.85rem; font-weight: 600; }
.case-list-item .info p { font-size: 0.75rem; color: var(--text-dim); }
.case-list-item .actions { display: flex; align-items: center; gap: 8px; flex-shrink: 0; }

.day-list-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 14px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 8px;
  margin-bottom: 8px;
  cursor: pointer;
  transition: border-color 0.2s;
  min-height: 44px;
}
.day-list-item:hover { border-color: var(--primary); }
.day-list-item:active { border-color: var(--primary); background: var(--surface2); }
.day-list-item .date { font-weight: 600; font-size: 0.9rem; }
.day-list-item .meta { font-size: 0.75rem; color: var(--text-dim); }

/* ===== POINT BREAKDOWN ===== */
.point-breakdown {
  background: var(--surface2);
  border-radius: 8px;
  padding: 12px;
  margin-top: 12px;
}

.point-breakdown .row { display: flex; justify-content: space-between; padding: 4px 0; font-size: 0.8rem; }

.point-breakdown .row.total {
  border-top: 1px solid var(--border);
  margin-top: 6px;
  padding-top: 8px;
  font-weight: 700;
  font-size: 0.9rem;
}

/* ===== MONTH NAV ===== */
.month-nav {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 16px;
  margin-bottom: 16px;
}

.month-nav button {
  background: var(--surface2);
  border: 1px solid var(--border);
  border-radius: 6px;
  color: var(--text);
  padding: 8px 14px;
  cursor: pointer;
  font-size: 1rem;
  min-height: 44px;
  min-width: 44px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.month-nav span { font-weight: 600; font-size: 1rem; min-width: 150px; text-align: center; }

/* ===== CHART ===== */
.chart-container { position: relative; height: 250px; margin: 12px 0; }

/* ===== RECONCILIATION ===== */
.recon-status { padding: 10px 14px; border-radius: 8px; margin-bottom: 8px; font-size: 0.85rem; }
.recon-match { background: rgba(16,185,129,0.15); border: 1px solid var(--accent); color: var(--accent); }
.recon-warn { background: rgba(245,158,11,0.15); border: 1px solid var(--accent2); color: var(--accent2); }
.recon-miss { background: rgba(239,68,68,0.15); border: 1px solid var(--danger); color: var(--danger); }

.recon-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.75rem;
  margin: 8px 0;
}

.recon-table th, .recon-table td {
  padding: 8px 6px;
  text-align: left;
  border-bottom: 1px solid var(--surface2);
}

.recon-table th { color: var(--text-dim); font-weight: 600; font-size: 0.7rem; text-transform: uppercase; }
.recon-table td { vertical-align: top; }
.recon-table tr.match { background: rgba(16,185,129,0.07); }
.recon-table tr.warn { background: rgba(245,158,11,0.07); }
.recon-table tr.miss { background: rgba(239,68,68,0.07); }

/* ===== RECON DASHBOARD ===== */
.recon-summary-bar { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-bottom: 12px; }
.recon-summary-bar .stat { text-align: center; padding: 10px 8px; border-radius: 8px; background: var(--surface2); }
.recon-summary-bar .stat .num { font-size: 1.4rem; font-weight: 700; }
.recon-summary-bar .stat .lbl { font-size: 0.7rem; color: var(--text-dim); text-transform: uppercase; margin-top: 2px; }
.recon-summary-bar .stat.green .num { color: var(--accent); }
.recon-summary-bar .stat.yellow .num { color: var(--accent2); }
.recon-summary-bar .stat.red .num { color: var(--danger); }
.recon-summary-bar .stat.purple .num { color: #a78bfa; }
.recon-pts-compare { display: flex; justify-content: center; gap: 24px; margin: 8px 0; font-size: 0.8rem; color: var(--text-dim); }
.recon-pts-compare span { font-weight: 600; }
.recon-batch-actions { display: flex; gap: 8px; margin: 12px 0; flex-wrap: wrap; }
.recon-batch-actions .btn { flex: 1; min-width: 120px; }

/* Expandable day rows */
.recon-day { border-radius: 8px; margin-bottom: 6px; overflow: hidden; border-left: 4px solid var(--border); background: var(--surface); }
.recon-day.status-match { border-left-color: var(--accent); }
.recon-day.status-close { border-left-color: var(--accent2); }
.recon-day.status-mismatch { border-left-color: var(--danger); }
.recon-day.status-missing { border-left-color: #a78bfa; }
.recon-day-header { display: flex; align-items: center; padding: 10px 14px; cursor: pointer; gap: 10px; user-select: none; }
.recon-day-header:hover { background: var(--surface2); }
.recon-day-header .day-date { font-weight: 600; font-size: 0.85rem; min-width: 60px; }
.recon-day-header .day-info { flex: 1; font-size: 0.75rem; color: var(--text-dim); }
.recon-day-header .day-status { font-size: 0.7rem; font-weight: 600; padding: 3px 8px; border-radius: 12px; text-transform: uppercase; }
.recon-day-header .day-status.s-match { background: rgba(16,185,129,0.15); color: var(--accent); }
.recon-day-header .day-status.s-close { background: rgba(245,158,11,0.15); color: var(--accent2); }
.recon-day-header .day-status.s-mismatch { background: rgba(239,68,68,0.15); color: var(--danger); }
.recon-day-header .day-status.s-missing { background: rgba(167,139,250,0.15); color: #a78bfa; }
.recon-day-header .day-chevron { font-size: 0.9rem; color: var(--text-dim); transition: transform 0.2s; }
.recon-day.expanded .day-chevron { transform: rotate(180deg); }
.recon-day-detail { display: none; padding: 0 14px 12px; }
.recon-day.expanded .recon-day-detail { display: block; }

/* Case row inside day detail */
.recon-case-table { width: 100%; border-collapse: collapse; font-size: 0.73rem; }
.recon-case-table th { color: var(--text-dim); font-weight: 600; font-size: 0.65rem; text-transform: uppercase; padding: 6px 4px; text-align: left; border-bottom: 1px solid var(--border); }
.recon-case-table td { padding: 6px 4px; vertical-align: middle; border-bottom: 1px solid var(--surface2); }
.recon-case-table tr.case-match td { }
.recon-case-table tr.case-close td { background: rgba(245,158,11,0.05); }
.recon-case-table tr.case-mismatch td { background: rgba(239,68,68,0.05); }
.recon-case-table tr.case-missing td { background: rgba(167,139,250,0.05); }
.recon-case-table .case-actions { display: flex; gap: 4px; flex-wrap: wrap; }
.recon-case-table .case-actions button { font-size: 0.65rem; padding: 3px 6px; border-radius: 4px; border: 1px solid var(--border); background: var(--surface2); color: var(--text); cursor: pointer; white-space: nowrap; }
.recon-case-table .case-actions button:hover { background: var(--primary); color: #fff; border-color: var(--primary); }
.recon-case-table .case-actions button.act-flag:hover { background: var(--accent2); color: #000; border-color: var(--accent2); }
.recon-case-table .case-resolved { font-size: 0.7rem; font-weight: 600; color: var(--accent); }

/* Inline action buttons */
.btn-accept-billing { background: var(--primary); color: #fff; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; }
.btn-accept-app { background: var(--accent); color: #fff; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; }
.btn-flag { background: var(--accent2); color: #000; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; }

/* Add-on tally */
.addon-tally-table { width: 100%; border-collapse: collapse; font-size: 0.75rem; margin: 8px 0; }
.addon-tally-table th, .addon-tally-table td { padding: 8px 6px; text-align: left; border-bottom: 1px solid var(--surface2); }
.addon-tally-table th { color: var(--text-dim); font-weight: 600; font-size: 0.7rem; text-transform: uppercase; }
.addon-tally-table tr.addon-match { background: rgba(16,185,129,0.07); }
.addon-tally-table tr.addon-warn { background: rgba(245,158,11,0.07); }
.addon-tally-table tr.addon-miss { background: rgba(239,68,68,0.07); }
.addon-action-btn { background: var(--surface2); border: 1px solid var(--border); border-radius: 6px; color: var(--text); font-size: 0.7rem; padding: 4px 8px; cursor: pointer; }
.addon-action-btn:hover { background: var(--primary); color: #fff; }
.addon-select { background: var(--surface2); border: 1px solid var(--border); border-radius: 6px; color: var(--text); font-size: 0.7rem; padding: 4px; max-width: 140px; }

/* Flagged issues */
.flagged-list { list-style: none; padding: 0; }
.flagged-list li { padding: 8px 0; border-bottom: 1px solid var(--surface2); font-size: 0.8rem; color: var(--text); }
.flagged-list li:last-child { border-bottom: none; }

/* Email preview */
.email-preview { background: var(--bg); border: 1px solid var(--border); border-radius: 8px; padding: 16px; font-size: 0.8rem; white-space: pre-wrap; font-family: monospace; max-height: 300px; overflow-y: auto; margin: 12px 0; }

/* Flag button */
.flag-btn { background:none; border:none; cursor:pointer; font-size:1rem; padding:2px 4px; color:transparent; -webkit-text-stroke:1.5px #fff; }
.flag-btn.flagged { color:#e74c3c; -webkit-text-stroke:0; }
.flagged-row { border-left: 3px solid #e74c3c !important; }

/* ===== UPLOAD AREA ===== */
.upload-area {
  border: 2px dashed var(--border);
  border-radius: 8px;
  padding: 24px;
  text-align: center;
  cursor: pointer;
  transition: border-color 0.2s;
  min-height: 44px;
}

.upload-area:hover { border-color: var(--primary); }
.upload-area p { color: var(--text-dim); font-size: 0.85rem; margin-top: 8px; }
.upload-area input { display: none; }

/* ===== SHIFT TEMPLATES ===== */
.template-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 12px; }

.template-btn {
  padding: 10px 8px;
  background: var(--surface2);
  border: 1px solid var(--border);
  border-radius: 8px;
  color: var(--text);
  font-size: 0.8rem;
  cursor: pointer;
  text-align: center;
  transition: all 0.2s;
  min-height: 44px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 2px;
}

.template-btn:hover { border-color: var(--primary); }
.template-btn:active { background: rgba(59,130,246,0.15); border-color: var(--primary); }
.template-btn .t-label { font-weight: 600; }
.template-btn .t-time { font-size: 0.7rem; color: var(--text-dim); }

/* ===== TOAST ===== */
.toast {
  position: fixed;
  bottom: calc(var(--bottom-nav) + 16px);
  left: 50%;
  transform: translateX(-50%);
  background: var(--accent);
  color: white;
  padding: 10px 24px;
  border-radius: 8px;
  font-size: 0.85rem;
  font-weight: 600;
  z-index: 200;
  opacity: 0;
  transition: opacity 0.3s;
  pointer-events: none;
  white-space: nowrap;
}
.toast.show { opacity: 1; }

/* ===== MODAL ===== */
.modal-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.6);
  z-index: 300;
  display: flex;
  align-items: flex-end;
  justify-content: center;
  padding: 0;
}

.modal {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 16px 16px 0 0;
  padding: 20px;
  max-width: 600px;
  width: 100%;
  max-height: 85vh;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
}

.modal h2 { margin-bottom: 16px; }

.modal-actions {
  display: flex;
  gap: 8px;
  margin-top: 16px;
  justify-content: flex-end;
}

/* ===== TAB SWITCHER ===== */
.tab-bar {
  display: flex;
  border-bottom: 1px solid var(--border);
  margin-bottom: 12px;
  overflow-x: auto;
}

.tab-btn {
  flex: 1;
  padding: 10px 8px;
  background: none;
  border: none;
  border-bottom: 3px solid transparent;
  color: var(--text-dim);
  font-size: 0.8rem;
  font-weight: 500;
  cursor: pointer;
  white-space: nowrap;
  min-height: 44px;
  transition: all 0.2s;
}

.tab-btn.active { color: var(--primary); border-bottom-color: var(--primary); }

/* ===== MISC ===== */
.empty-state { text-align: center; padding: 40px 20px; color: var(--text-dim); }
.empty-state p { margin-top: 8px; font-size: 0.85rem; }
.divider { height: 1px; background: var(--border); margin: 16px 0; }
.modifiers-section { border: 1px solid var(--border); border-radius: 8px; padding: 8px 12px; margin: 8px 0; }
.modifiers-section summary { cursor: pointer; font-weight: 600; font-size: 0.9rem; color: var(--text-dim); list-style: none; display: flex; align-items: center; gap: 8px; }
.modifiers-section summary::-webkit-details-marker { display: none; }
.modifiers-section summary::before { content: '\25B6'; font-size: 0.65rem; transition: transform 0.2s; }
.modifiers-section[open] summary::before { transform: rotate(90deg); }
.modifier-tags { display: inline-flex; gap: 4px; flex-wrap: wrap; }
.modifier-tags .mod-tag { background: var(--accent); color: #fff; font-size: 0.65rem; padding: 1px 6px; border-radius: 10px; font-weight: 500; }
.hidden { display: none !important; }

/* ===== END TIME WARNING ===== */
.end-time-warning {
  background: rgba(245,158,11,0.15);
  border: 1px solid var(--accent2);
  color: var(--accent2);
  padding: 10px 14px;
  border-radius: 8px;
  margin-bottom: 12px;
  font-size: 0.85rem;
  font-weight: 500;
}
input.warn-empty {
  border-color: var(--accent2) !important;
  box-shadow: 0 0 0 1px var(--accent2);
}

/* ===== MILITARY TIME INPUTS ===== */
input.mil-time {
  font-variant-numeric: tabular-nums;
  letter-spacing: 1px;
  text-align: center;
  font-family: 'SF Mono', 'Menlo', 'Consolas', monospace;
}
input.mil-time.invalid {
  border-color: var(--danger) !important;
}

.settings-field {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px 0;
  border-bottom: 1px solid var(--surface2);
}

.settings-field label { font-size: 0.85rem; color: var(--text-dim); white-space: nowrap; min-width: 60px; }

/* ===== DASHBOARD SUB-TABS ===== */
.dash-sticky-header {
  position: fixed;
  top: var(--header-h);
  left: 0;
  right: 0;
  z-index: 50;
  background: var(--bg);
  padding: 0 12px 4px;
  max-width: 600px;
  margin: 0 auto;
}
#dtab-caselogs .case-log-search { margin-bottom: 4px; }
.dash-tab-bar {
  display: flex;
  border-bottom: 1px solid var(--border);
  overflow-x: auto;
  gap: 0;
}
.dash-tab-btn {
  flex: 1;
  padding: 10px 6px;
  background: none;
  border: none;
  border-bottom: 3px solid transparent;
  color: var(--text-dim);
  font-size: 0.75rem;
  font-weight: 500;
  cursor: pointer;
  white-space: nowrap;
  min-height: 44px;
  transition: all 0.2s;
  text-align: center;
}
.dash-tab-btn.active { color: var(--primary); border-bottom-color: var(--primary); }

/* ===== DATA ENTRY PAGE ===== */
.de-sticky-header {
  position: fixed;
  top: var(--header-h);
  left: 0;
  right: 0;
  z-index: 50;
  background: var(--bg);
  padding: 8px 12px 4px;
  max-width: 600px;
  margin: 0 auto;
}

.daily-tally {
  display: flex;
  align-items: center;
  justify-content: space-between;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 10px 16px;
  margin-bottom: 8px;
}
.daily-tally .tally-label { font-size: 0.85rem; color: var(--text-dim); font-weight: 500; }
.daily-tally .tally-value { font-size: 1.1rem; color: var(--accent); font-weight: 700; }

.shift-summary-bar {
  display: flex;
  align-items: center;
  justify-content: space-between;
  background: var(--surface);
  border: 1px solid var(--primary);
  border-radius: var(--radius);
  padding: 12px 16px;
  margin-bottom: 0;
  cursor: pointer;
  transition: background 0.15s;
}
.shift-summary-bar:hover { background: rgba(59,130,246,0.1); }
.shift-summary-bar .ssb-info { display: flex; align-items: center; gap: 10px; flex: 1; min-width: 0; }
.shift-summary-bar .ssb-badge {
  background: var(--primary);
  color: #fff;
  font-size: 0.72rem;
  font-weight: 600;
  padding: 3px 8px;
  border-radius: 4px;
  white-space: nowrap;
}
.shift-summary-bar .ssb-badge.vacation { background: var(--purple); }
.shift-summary-bar .ssb-times { font-size: 0.82rem; color: var(--text-dim); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.shift-summary-bar .ssb-edit { color: var(--primary); font-size: 0.8rem; font-weight: 600; white-space: nowrap; margin-left: 8px; }

.de-case-list { margin-top: 8px; }
.de-case-list-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px 0;
  border-bottom: 1px solid var(--surface2);
  gap: 8px;
}
.de-case-list-item:last-child { border-bottom: none; }
.de-case-list-item:hover { background: rgba(59,130,246,0.06); }
.de-case-list-item:active { background: rgba(59,130,246,0.12); }
.de-case-list-item .de-info { flex: 1; min-width: 0; }
.de-case-list-item .de-name { font-size: 0.82rem; font-weight: 600; color: var(--text); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.de-case-list-item .de-detail { font-size: 0.72rem; color: var(--text-dim); }
.de-case-list-item .de-actions { display: flex; align-items: center; gap: 8px; }
.de-case-list-item .de-pts { font-size: 0.82rem; color: var(--accent); font-weight: 700; white-space: nowrap; }

/* ===== DAY DETAIL MODAL ===== */
.dd-shift-bar {
  display: flex;
  align-items: center;
  gap: 10px;
  background: var(--surface2);
  border-radius: 6px;
  padding: 10px 12px;
  margin-bottom: 12px;
}
.dd-shift-bar .dd-badge {
  background: var(--primary);
  color: #fff;
  font-size: 0.72rem;
  font-weight: 600;
  padding: 3px 8px;
  border-radius: 4px;
  white-space: nowrap;
}
.dd-shift-bar .dd-badge.vacation { background: var(--purple); }
.dd-shift-bar .dd-times { font-size: 0.82rem; color: var(--text-dim); flex: 1; }
.dd-summary {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
  margin-bottom: 12px;
}
.dd-summary-item {
  background: var(--surface);
  border-radius: 6px;
  padding: 8px 10px;
  text-align: center;
}
.dd-summary-item .dd-label { font-size: 0.68rem; color: var(--text-dim); margin-bottom: 2px; }
.dd-summary-item .dd-value { font-size: 1rem; font-weight: 700; }
.dd-summary-item .dd-value.blue { color: var(--primary); }
.dd-summary-item .dd-value.green { color: var(--accent); }
.dd-summary-item .dd-value.yellow { color: var(--accent2); }
.dd-case-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px 0;
  border-bottom: 1px solid var(--surface2);
  gap: 8px;
}
.dd-case-item:last-child { border-bottom: none; }
.dd-case-item .dd-case-info { flex: 1; min-width: 0; }
.dd-case-item .dd-case-name { font-size: 0.82rem; font-weight: 600; color: var(--text); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.dd-case-item .dd-case-detail { font-size: 0.72rem; color: var(--text-dim); }
.dd-case-item .dd-case-actions { display: flex; align-items: center; gap: 6px; }
.dd-case-item .dd-case-pts { font-size: 0.82rem; color: var(--accent); font-weight: 700; white-space: nowrap; }

/* ===== DAILY CALENDAR ===== */
.daily-cal { display: grid; grid-template-columns: repeat(7, 1fr); gap: 2px; width: 100%; box-sizing: border-box; }
.daily-cal-header { font-size: 0.6rem; color: var(--text-dim); text-align: center; padding: 2px 0; font-weight: 600; }
.daily-cal-cell { background: var(--surface); border-radius: 5px; padding: 4px 2px; text-align: center; min-height: 44px; position: relative; cursor: pointer; transition: background 0.15s; overflow: hidden; }
.daily-cal-cell:active:not(.empty) { background: rgba(59,130,246,0.15); }
.daily-cal-cell.empty { background: transparent; }
.daily-cal-cell.today { border: 2px solid var(--primary); }
.daily-cal-cell.vacation { background: rgba(139,92,246,0.15); }
.daily-cal-day { font-size: 0.6rem; color: var(--text-dim); margin-bottom: 1px; }
.daily-cal-pts { font-size: 0.75rem; font-weight: 700; color: var(--text); }
.daily-cal-pts.zero { color: var(--text-dim); font-weight: 400; }
.daily-cal-type { font-size: 0.5rem; color: var(--accent); margin-top: 1px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

/* ===== CASE LOG TABLE ===== */
.case-log-wrap { overflow-x: auto; -webkit-overflow-scrolling: touch; margin: 0 -12px; padding: 0 12px; }
.case-log-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.68rem;
}
.case-log-table thead { position: sticky; top: 0; z-index: 2; }
.case-log-table th {
  background: var(--surface);
  color: var(--text-dim);
  font-weight: 600;
  font-size: 0.62rem;
  text-transform: uppercase;
  padding: 3px 3px;
  text-align: left;
  border-bottom: 2px solid var(--border);
  white-space: nowrap;
}
.case-log-table td {
  padding: 3px 3px;
  border-bottom: 1px solid var(--surface2);
  vertical-align: middle;
}
.case-log-table .cl-del { color: var(--danger); cursor: pointer; font-size: 0.9rem; padding: 2px 4px; line-height: 1; }
.case-log-table tr { cursor: pointer; transition: background 0.15s; }
.case-log-table tbody tr:hover { background: rgba(59,130,246,0.08); }
.case-log-table tbody tr:active { background: rgba(59,130,246,0.15); }
.case-log-table .cl-cb { width: 16px; height: 16px; accent-color: var(--primary); cursor: pointer; margin: 0; }
.case-log-table th:first-child, .case-log-table td:first-child { width: 28px; text-align: center; }
#clDeleteSelectedBtn {
  background: var(--danger);
  color: white;
  border: none;
  border-radius: 6px;
  padding: 6px 14px;
  font-size: 0.75rem;
  font-weight: 600;
  cursor: pointer;
  margin-bottom: 6px;
}
#clDeleteSelectedBtn:hover { opacity: 0.9; }

.case-log-search {
  width: 100%;
  padding: 8px 12px;
  background: var(--surface2);
  border: 1px solid var(--border);
  border-radius: 6px;
  color: var(--text);
  font-size: 14px;
  margin-bottom: 12px;
  outline: none;
  min-height: 44px;
}
.case-log-search:focus { border-color: var(--primary); }

/* ===== SHIFT LOG TABLE ===== */
.shift-log-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.72rem;
  min-width: 900px;
}
.shift-log-table thead { position: sticky; top: 0; z-index: 2; }
.shift-log-table th {
  background: var(--surface);
  color: var(--text-dim);
  font-weight: 600;
  font-size: 0.68rem;
  text-transform: uppercase;
  padding: 8px 6px;
  text-align: left;
  border-bottom: 2px solid var(--border);
  white-space: nowrap;
}
.shift-log-table td {
  padding: 6px 6px;
  border-bottom: 1px solid var(--surface2);
  vertical-align: middle;
}
.shift-log-table tr { cursor: pointer; transition: background 0.15s; }
.shift-log-table tbody tr.sl-alt { background: rgba(148,163,184,0.06); }
.shift-log-table tbody tr:hover { background: rgba(59,130,246,0.08); }
.shift-log-table tbody tr:active { background: rgba(59,130,246,0.15); }
.sl-sub-row td { border-top: none; }
.sl-sub-row td:empty, .sl-sub-row td[data-blank] { color: transparent; }
.shift-log-table .sl-check { width: 28px; text-align: center; }
.shift-log-table .sl-check input[type="checkbox"] { width: 16px; height: 16px; cursor: pointer; accent-color: var(--primary); }
.shift-log-table .sl-del-cell { width: 28px; text-align: center; }
.shift-log-table .sl-del-btn { background: none; border: none; color: var(--danger); cursor: pointer; font-size: 1rem; padding: 2px 4px; line-height: 1; opacity: 0.7; transition: opacity 0.15s; }
.shift-log-table .sl-del-btn:hover { opacity: 1; }
.sl-delete-bar { display: flex; align-items: center; gap: 12px; padding: 8px 12px; margin-bottom: 8px; background: rgba(239,68,68,0.08); border: 1px solid var(--danger); border-radius: 8px; }
.sl-delete-bar .sl-del-count { font-size: 0.82rem; color: var(--text); font-weight: 600; }
.sl-delete-bar .sl-del-action { background: var(--danger); color: white; border: none; border-radius: 6px; padding: 6px 14px; font-size: 0.8rem; font-weight: 600; cursor: pointer; transition: opacity 0.15s; }
.sl-delete-bar .sl-del-action:hover { opacity: 0.9; }
.sl-badge {
  display: inline-block;
  padding: 2px 6px;
  border-radius: 4px;
  font-size: 0.65rem;
  font-weight: 600;
  white-space: nowrap;
}
.sl-badge-or { background: rgba(16,185,129,0.2); color: #34d399; }
.sl-badge-ob { background: rgba(59,130,246,0.2); color: #60a5fa; }
.sl-badge-call { background: rgba(245,158,11,0.2); color: #fbbf24; }
.sl-badge-endo { background: rgba(139,92,246,0.2); color: #a78bfa; }
.sl-badge-sf { background: rgba(236,72,153,0.2); color: #f472b6; }
.sl-badge-other { background: rgba(148,163,184,0.2); color: #94a3b8; }
.sl-badge-vac { background: rgba(100,116,139,0.15); color: #64748b; }
.sl-summary-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.78rem;
}
.sl-summary-table th {
  text-align: left;
  color: var(--text-dim);
  font-weight: 600;
  font-size: 0.7rem;
  padding: 4px 8px;
  border-bottom: 1px solid var(--border);
}
.sl-summary-table td {
  padding: 4px 8px;
  border-bottom: 1px solid var(--surface2);
}
.sl-summary-table tr:last-child td {
  font-weight: 700;
  border-top: 2px solid var(--border);
  border-bottom: none;
}
.sl-pager-row { background: rgba(245,158,11,0.06); }

/* ===== TOGGLE SWITCH ===== */
.toggle-row { display: flex; align-items: center; gap: 8px; font-size: 0.8rem; color: var(--text-dim); }
.toggle-switch { position: relative; width: 36px; height: 20px; flex-shrink: 0; }
.toggle-switch input { opacity: 0; width: 0; height: 0; }
.toggle-switch .slider { position: absolute; inset: 0; background: var(--surface2); border-radius: 10px; cursor: pointer; transition: 0.2s; border: 1px solid var(--border); }
.toggle-switch .slider::before { content: ''; position: absolute; width: 14px; height: 14px; left: 2px; top: 2px; background: var(--text-dim); border-radius: 50%; transition: 0.2s; }
.toggle-switch input:checked + .slider { background: var(--primary); border-color: var(--primary); }
.toggle-switch input:checked + .slider::before { transform: translateX(16px); background: #fff; }

/* ===== EFFICIENCY ITEMS ===== */
.efficiency-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 6px 0;
  border-bottom: 1px solid rgba(71,85,105,0.3);
  font-size: 0.82rem;
}
.efficiency-item:last-child { border-bottom: none; }
.efficiency-item .eff-label { flex: 1; min-width: 0; }
.efficiency-item .eff-value { font-weight: 700; margin-left: 8px; white-space: nowrap; }
.efficiency-item .eff-value.good { color: var(--accent); }
.efficiency-item .eff-value.bad { color: var(--danger); }

/* ===== TREND ARROWS ===== */
.trend-up { color: var(--accent); font-weight: 700; }
.trend-down { color: var(--danger); font-weight: 700; }
.trend-flat { color: var(--text-dim); font-weight: 700; }

/* ===== HEATMAP BARS ===== */
.heatmap-row {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 4px 0;
  font-size: 0.8rem;
}
.heatmap-row .hm-label { width: 36px; color: var(--text-dim); font-size: 0.75rem; flex-shrink: 0; }
.heatmap-bar {
  height: 20px;
  background: var(--primary);
  border-radius: 3px;
  min-width: 2px;
  transition: width 0.3s;
}
.heatmap-bar.green { background: var(--accent); }
.heatmap-row .hm-value { font-size: 0.75rem; color: var(--text-dim); min-width: 40px; text-align: right; }

/* ===== CASE MIX ITEMS ===== */
.case-mix-item {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 5px 0;
  font-size: 0.8rem;
}
.case-mix-item .cm-label { width: 110px; flex-shrink: 0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.case-mix-bar-wrap { flex: 1; height: 16px; background: var(--surface2); border-radius: 3px; overflow: hidden; }
.case-mix-bar { height: 100%; background: var(--primary); border-radius: 3px; transition: width 0.3s; }
.case-mix-item .cm-count { min-width: 32px; text-align: right; font-size: 0.75rem; color: var(--text-dim); }

/* ===== COLLAPSIBLE SECTIONS ===== */
.collapse-section { margin-bottom: 8px; }
.collapse-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  cursor: pointer;
  min-height: 44px;
  padding: 8px 0;
  border-bottom: 1px solid var(--surface2);
}
.collapse-header h3 { font-size: 0.88rem; margin: 0; }
.collapse-header .arrow { transition: transform 0.2s; color: var(--text-dim); }
.collapse-header .arrow.open { transform: rotate(180deg); }
.collapse-body { overflow: hidden; transition: max-height 0.3s ease; max-height: 0; }

/* ===== PROCEDURE AUTOCOMPLETE ===== */
.proc-autocomplete { position: relative; }
.proc-suggestions {
  position: absolute; top: 100%; left: 0; right: 0; z-index: 100;
  background: var(--surface); border: 1px solid var(--border); border-top: none;
  border-radius: 0 0 8px 8px; max-height: 180px; overflow-y: auto;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
}
.proc-suggestions .proc-item {
  padding: 10px 12px; cursor: pointer; font-size: 0.85rem;
  display: flex; justify-content: space-between; align-items: center;
}
.proc-suggestions .proc-item:hover, .proc-suggestions .proc-item.active {
  background: var(--primary); color: #fff;
}
.proc-suggestions .proc-item .proc-units {
  font-size: 0.75rem; color: var(--text-dim); margin-left: 8px;
}
.proc-suggestions .proc-item:hover .proc-units,
.proc-suggestions .proc-item.active .proc-units { color: rgba(255,255,255,0.7); }

/* ===== SURGEON / NOTES AUTOCOMPLETE ===== */
.notes-autocomplete { position: relative; }
.surgeon-suggestions {
  position: absolute; bottom: 100%; left: 0; right: 0; z-index: 110;
  background: var(--surface); border: 1px solid var(--border); border-bottom: none;
  border-radius: 8px 8px 0 0; max-height: 180px; overflow-y: auto;
  box-shadow: 0 -4px 12px rgba(0,0,0,0.3);
}
.surgeon-suggestions .surg-item {
  padding: 10px 12px; cursor: pointer; font-size: 0.85rem;
  display: flex; justify-content: space-between; align-items: center;
}
.surgeon-suggestions .surg-item:hover, .surgeon-suggestions .surg-item.active {
  background: var(--primary); color: #fff;
}
.surgeon-suggestions .surg-count {
  font-size: 0.75rem; color: var(--text-dim); margin-left: 8px;
}
.surgeon-suggestions .surg-item:hover .surg-count,
.surgeon-suggestions .surg-item.active .surg-count { color: rgba(255,255,255,0.7); }

/* ===== TIME ENTRY ROWS ===== */
.time-entry-row {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}
.time-entry-row input { flex: 1; }
.time-entry-row .te-label { font-size: 0.8rem; color: var(--text-dim); flex-shrink: 0; }
.remove-entry-btn {
  background: var(--danger);
  color: white;
  border: none;
  border-radius: 6px;
  width: 36px;
  height: 36px;
  font-size: 1.1rem;
  cursor: pointer;
  flex-shrink: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 36px;
}
.remove-entry-btn:disabled { opacity: 0.3; cursor: default; }
.add-entry-btn {
  background: transparent;
  border: 1px dashed var(--border);
  border-radius: 6px;
  color: var(--primary);
  padding: 8px;
  width: 100%;
  font-size: 0.85rem;
  cursor: pointer;
  margin-bottom: 12px;
  min-height: 38px;
  transition: border-color 0.2s;
}
.add-entry-btn:hover { border-color: var(--primary); }

/* ===== SCAN PAGE ===== */
.scan-capture-area {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 12px;
  padding: 16px;
  border: 2px dashed var(--border);
  border-radius: var(--radius);
  text-align: center;
  cursor: pointer;
  cursor: pointer;
  transition: border-color 0.2s;
}
.scan-capture-area:hover { border-color: var(--primary); }
.scan-capture-area .scan-icon { font-size: 2.5rem; }
.scan-capture-area p { margin: 0; font-size: 0.85rem; color: var(--text-dim); }
.scan-preview-img {
  max-width: 100%;
  max-height: 200px;
  border-radius: var(--radius);
  margin-top: 8px;
  object-fit: contain;
}
.scan-status {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 10px 14px;
  border-radius: var(--radius);
  font-size: 0.85rem;
  margin-top: 8px;
}
.scan-status.processing { background: rgba(59,130,246,0.12); color: var(--primary); }
.scan-status.success { background: rgba(16,185,129,0.12); color: var(--accent); }
.scan-status.error { background: rgba(239,68,68,0.12); color: var(--danger); }
.scan-status .spinner {
  width: 16px; height: 16px;
  border: 2px solid transparent;
  border-top-color: var(--primary);
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
}
@keyframes spin { to { transform: rotate(360deg); } }
.scan-case-card {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 12px;
  margin-bottom: 10px;
}
.scan-case-card .scc-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
}
.scan-case-card .scc-header h4 { margin: 0; font-size: 0.9rem; }
.scan-case-card .scc-remove {
  background: none; border: none; color: var(--danger);
  font-size: 1.1rem; cursor: pointer; padding: 4px;
}
.scan-case-card .scc-row {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
  margin-bottom: 6px;
}
.scan-case-card .scc-field { font-size: 0.8rem; }
.scan-case-card .scc-field label { display: block; color: var(--text-dim); font-size: 0.72rem; margin-bottom: 2px; }
.scan-case-card .scc-field input,
.scan-case-card .scc-field select {
  width: 100%;
  padding: 6px 8px;
  background: var(--bg);
  border: 1px solid var(--border);
  border-radius: 6px;
  color: var(--text);
  font-size: 0.82rem;
}
.scan-case-card .scc-tags {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  margin-top: 6px;
}
.scan-case-card .scc-tag {
  font-size: 0.72rem;
  padding: 2px 8px;
  border-radius: 10px;
  background: var(--surface2);
  color: var(--text-dim);
}
.scan-case-card .scc-tag.active { background: rgba(59,130,246,0.2); color: var(--primary); }
.scan-case-card .scc-tag.emergency { background: rgba(239,68,68,0.2); color: var(--danger); }
.scan-case-card .scc-tag.shared { background: rgba(139,92,246,0.2); color: var(--purple); }

/* ===== AUTH OVERLAY ===== */
.auth-overlay {
  position: fixed;
  inset: 0;
  z-index: 9999;
  background: var(--bg);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 24px;
  text-align: center;
}
.auth-overlay h1 { font-size: 1.6rem; margin-bottom: 8px; }
.auth-overlay p { color: var(--text-dim); font-size: 0.85rem; margin-bottom: 24px; max-width: 340px; }
.auth-overlay .auth-disclaimer {
  background: rgba(245,158,11,0.1);
  border: 1px solid rgba(245,158,11,0.3);
  border-radius: var(--radius);
  padding: 12px 16px;
  margin-bottom: 24px;
  max-width: 340px;
  font-size: 0.78rem;
  color: var(--accent2);
  text-align: left;
}
.google-sign-in-btn {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 10px 24px;
  background: #fff;
  color: #333;
  border: none;
  border-radius: 8px;
  font-size: 0.9rem;
  font-weight: 600;
  cursor: pointer;
  transition: box-shadow 0.2s;
}
.google-sign-in-btn:hover { box-shadow: 0 2px 8px rgba(0,0,0,0.3); }
.google-sign-in-btn svg { width: 20px; height: 20px; }
.auth-loading { color: var(--text-dim); font-size: 0.85rem; }
.sync-indicator {
  font-size: 0.7rem;
  color: var(--text-dim);
  padding: 2px 6px;
  border-radius: 4px;
  display: inline-block;
}
.sync-indicator.syncing { color: var(--primary); }
.sync-indicator.synced { color: var(--accent); }
.sync-indicator.error { color: var(--danger); }

/* ===== TUTORIAL OVERLAY ===== */
.tutorial-overlay {
  position: fixed; inset: 0; z-index: 500;
  background: rgba(0,0,0,0.75);
  display: flex; align-items: center; justify-content: center;
  padding: 16px;
}
.tutorial-overlay.hidden { display: none; }
.tutorial-card {
  background: var(--surface);
  border-radius: 16px;
  max-width: 360px;
  width: 100%;
  padding: 28px 24px 20px;
  position: relative;
  box-shadow: 0 8px 32px rgba(0,0,0,0.4);
  text-align: center;
}
.tutorial-skip {
  position: absolute; top: 10px; right: 14px;
  background: none; border: none; color: var(--text-dim);
  font-size: 0.8rem; cursor: pointer;
}
.tutorial-skip:hover { color: var(--text); }
.tutorial-step { display: none; }
.tutorial-step.active { display: block; }
.tutorial-step .tut-icon {
  font-size: 2.2rem; margin-bottom: 8px; display: block;
}
.tutorial-step h3 {
  font-size: 1.05rem; margin: 0 0 8px; color: var(--text);
}
.tutorial-step p {
  font-size: 0.82rem; color: var(--text-dim); line-height: 1.5;
  margin: 0 0 4px;
}
.tutorial-step .tut-instructions {
  text-align: left; font-size: 0.78rem; color: var(--text-dim);
  line-height: 1.6; margin: 10px 0 0;
}
.tutorial-step .tut-instructions strong {
  color: var(--text); font-weight: 600;
}
.tutorial-options {
  display: flex; flex-direction: column; gap: 8px; margin-top: 14px;
}
.tutorial-option {
  display: flex; align-items: center; gap: 10px;
  background: var(--surface2); border: 1px solid var(--border);
  border-radius: var(--radius); padding: 12px 14px;
  cursor: pointer; text-align: left; transition: border-color 0.15s;
}
.tutorial-option:hover { border-color: var(--primary); }
.tutorial-option .to-icon { font-size: 1.3rem; flex-shrink: 0; }
.tutorial-option .to-text { flex: 1; }
.tutorial-option .to-text strong { font-size: 0.82rem; display: block; color: var(--text); }
.tutorial-option .to-text span { font-size: 0.72rem; color: var(--text-dim); }
.tutorial-option .to-badge {
  font-size: 0.6rem; background: var(--accent);
  color: #000; padding: 2px 6px; border-radius: 8px;
  font-weight: 700; text-transform: uppercase; flex-shrink: 0;
}
.tutorial-dots {
  display: flex; justify-content: center; gap: 6px;
  margin: 18px 0 14px;
}
.tutorial-dots .dot {
  width: 8px; height: 8px; border-radius: 50%;
  background: var(--border); transition: background 0.2s;
}
.tutorial-dots .dot.active { background: var(--primary); }
.tutorial-nav {
  display: flex; gap: 8px; justify-content: center;
}
.tutorial-nav .btn { min-width: 90px; font-size: 0.82rem; }

.account-card {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  margin-bottom: 12px;
}
.account-card img {
  width: 36px; height: 36px;
  border-radius: 50%;
}
.account-card .ac-info { flex: 1; min-width: 0; }
.account-card .ac-name { font-size: 0.85rem; font-weight: 600; }
.account-card .ac-email { font-size: 0.72rem; color: var(--text-dim); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

/* ===== BOTTOM NAV — 5 items ===== */
.bottom-nav button { font-size: 0.6rem; }
.bottom-nav button .nav-icon { font-size: 1.15rem; }

@media (max-width: 480px) {
  .form-row { grid-template-columns: 1fr; }
  .form-row-3 { grid-template-columns: 1fr 1fr; }
  .template-grid { grid-template-columns: 1fr; }
}
</style>
</head>
<body>

<!-- ===== AUTH OVERLAY ===== -->
<div class="auth-overlay" id="authOverlay">
  <h1>MWA Point Tracker</h1>
  <p>Track anesthesia cases, shifts, and production points.</p>
  <div class="auth-disclaimer">
    <strong>Important:</strong> Do not store any patient-identifiable information (names, MRNs, account numbers, DOBs) in this app. Only record procedure types, times, and point data.
  </div>
  <button class="google-sign-in-btn" id="googleSignInBtn">
    <svg viewBox="0 0 24 24"><path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92a5.06 5.06 0 0 1-2.2 3.32v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.1z"/><path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/><path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/><path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/></svg>
    Sign in with Google
  </button>
  <p id="authError" style="color:var(--danger);font-size:0.8rem;margin-top:12px;" class="hidden"></p>
  <p class="auth-loading hidden" id="authLoading">Signing in...</p>
</div>

<!-- ===== TUTORIAL OVERLAY ===== -->
<div class="tutorial-overlay hidden" id="tutorialOverlay">
  <div class="tutorial-card">
    <button class="tutorial-skip" onclick="closeTutorial()">Skip</button>

    <!-- Step 1: Welcome -->
    <div class="tutorial-step active" data-step="0">
      <span class="tut-icon">&#128137;</span>
      <h3>Welcome to MWA Point Tracker</h3>
      <p>Track your anesthesia cases and production points — set up in 60 seconds.</p>
    </div>

    <!-- Step 2: Log Your Shift -->
    <div class="tutorial-step" data-step="1">
      <span class="tut-icon">&#128197;</span>
      <h3>Log Your Shift</h3>
      <div class="tut-instructions">
        <strong>1.</strong> Tap the <strong>Work</strong> tab below<br>
        <strong>2.</strong> Pick your assignment type (OR, OB, etc.)<br>
        <strong>3.</strong> Enter your start &amp; end times<br>
        <strong>4.</strong> Tap <strong>Save Shift</strong>
      </div>
    </div>

    <!-- Step 3: Log Your Cases -->
    <div class="tutorial-step" data-step="2">
      <span class="tut-icon">&#128203;</span>
      <h3>Log Your Cases</h3>
      <div class="tut-instructions">
        <strong>1.</strong> After saving a shift, the case form appears<br>
        <strong>2.</strong> Select the procedure type<br>
        <strong>3.</strong> Enter units and times<br>
        <strong>4.</strong> Tap <strong>Save Case</strong> — repeat for each case
      </div>
    </div>

    <!-- Step 4: Catch Up on Past Data -->
    <div class="tutorial-step" data-step="3">
      <span class="tut-icon">&#128202;</span>
      <h3>Catch Up on Past Data</h3>
      <p>How would you like to add your history?</p>
      <div class="tutorial-options">
        <div class="tutorial-option" onclick="tutorialHistoryChoice('fresh')">
          <span class="to-icon">&#10024;</span>
          <div class="to-text">
            <strong>Start Fresh</strong>
            <span>Begin tracking from today</span>
          </div>
        </div>
        <div class="tutorial-option" onclick="tutorialHistoryChoice('import')">
          <span class="to-icon">&#128229;</span>
          <div class="to-text">
            <strong>Import from File</strong>
            <span>Upload a JSON or spreadsheet</span>
          </div>
        </div>
        <div class="tutorial-option" onclick="tutorialHistoryChoice('override')">
          <span class="to-icon">&#128221;</span>
          <div class="to-text">
            <strong>Enter Total Points</strong>
            <span>Enter monthly point totals manually</span>
          </div>
          <span class="to-badge">Easiest</span>
        </div>
      </div>
    </div>

    <!-- Step 5: Revenue Projections -->
    <div class="tutorial-step" data-step="4">
      <span class="tut-icon">&#129689;</span>
      <h3>Revenue Projections</h3>
      <div class="tut-instructions">
        <strong>1.</strong> Go to the <strong>Comp</strong> tab<br>
        <strong>2.</strong> Enter your estimated <strong>$/point</strong> value<br>
        <strong>3.</strong> This unlocks revenue projections on the Dashboard
      </div>
    </div>

    <div class="tutorial-dots" id="tutorialDots">
      <span class="dot active"></span>
      <span class="dot"></span>
      <span class="dot"></span>
      <span class="dot"></span>
      <span class="dot"></span>
    </div>
    <div class="tutorial-nav">
      <button class="btn btn-outline btn-sm" id="tutBackBtn" onclick="tutorialPrev()" style="display:none;">Back</button>
      <button class="btn btn-primary btn-sm" id="tutNextBtn" onclick="tutorialNext()">Next</button>
    </div>
  </div>
</div>

<!-- ===== HEADER ===== -->
<header>
  <h1>MWA Points</h1>
  <button class="header-nav-btn" id="headerPrevDay">&#9664;</button>
  <button class="header-date-btn" id="headerDateBtn"></button>
  <button class="header-nav-btn" id="headerNextDay">&#9654;</button>
  <span class="header-pts" id="headerPoints"><span class="daily">0 pts</span><br><span class="monthly">0 mo</span></span>
</header>

<!-- ===== PAGES ===== -->

<!-- DATA ENTRY PAGE -->
<div class="page" id="page-dataentry">
  <!-- Sticky header: tally + summary bar -->
  <div class="de-sticky-header" id="deStickyHeader">
    <div class="daily-tally" id="deTallyBar">
      <span class="tally-label">Daily Points</span>
      <span class="tally-value" id="deTallyValue">0</span>
    </div>
    <div class="shift-summary-bar hidden" id="deShiftSummaryBar">
      <div class="ssb-info">
        <span class="ssb-badge" id="deSSBBadge">OR</span>
        <span class="ssb-times" id="deSSBTimes">07:00 - 17:00</span>
      </div>
      <span class="ssb-edit">Edit &#9998;</span>
    </div>
  </div>
  <div id="deStickyHeaderSpacer"></div>

  <!-- Shift section (all existing shift HTML, IDs preserved) -->
  <div id="deShiftSection">
    <button class="btn btn-sm btn-outline hidden" id="backToShiftLogsBtn" onclick="navigateToShiftLogs()" style="margin-bottom:10px;font-size:0.8rem;">&larr; Back to Shift Logs</button>
    <div class="hidden" id="editShiftBanner" style="background:rgba(59,130,246,0.15); border:1px solid var(--primary); border-radius:var(--radius); padding:10px 14px; margin-bottom:12px; font-size:0.82rem; color:var(--primary); font-weight:600;"></div>
    <div class="end-time-warning hidden" id="endTimeWarning">
      Shift end time is missing — AR points will be 0 until an end time is entered.
    </div>
    <div class="card">
      <div class="card-collapse-header" id="templateCollapseHeader">
        <h2>Quick Templates</h2>
        <span class="arrow" id="templateArrow">&#9660;</span>
      </div>
      <div class="card-collapse-body" id="templateCollapseBody" style="max-height:0;">
        <div class="template-grid" id="templateGrid" style="padding-top:12px;"></div>
      </div>
    </div>

    <div class="card">
      <h2>Shift Setup</h2>

      <div class="form-group" style="display:none;">
        <label>Date</label>
        <input type="date" id="shiftDate">
      </div>

      <div class="form-group">
        <label>Assignment Type</label>
        <select id="shiftAssignmentType">
          <option value="OR">OR / General</option>
          <option value="OB_restricted">UVH OB</option>
          <option value="cardiac_liver">Cardiac / Liver</option>
          <option value="mole">Mole</option>
          <option value="1st_call">1st Call</option>
          <option value="2nd_call">2nd Call</option>
          <option value="3rd_call">3rd Call</option>
          <option value="4th_call">4th Call</option>
          <option value="endo">Endo</option>
          <option value="SF1">SF 1</option>
          <option value="SF2">SF 2</option>
          <option value="ACS">ACS</option>
          <option value="NORA">NORA</option>
          <option value="pre_call">Pre-Call</option>
          <option value="CRNA_supervision">CRNA Supervision</option>
          <option value="forced_off">Forced Off</option>
          <option value="vacation">Vacation / Off</option>
        </select>
      </div>

      <div id="vacationRangeSection" class="hidden">
        <div class="form-group">
          <label>Vacation End Date <span style="font-size:0.75rem;color:var(--text-dim);">(optional — leave blank for single day)</span></label>
          <input type="date" id="vacationEndDate" class="settings-input">
        </div>
      </div>

      <div class="form-group" id="timeEntriesGroup">
        <label id="timeEntriesLabel">Time Entries</label>
        <div id="timeEntriesContainer">
          <div class="time-entry-row">
            <input type="text" inputmode="numeric" placeholder="HH:MM" maxlength="5" class="mil-time te-start" value="07:00">
            <span class="te-label">to</span>
            <input type="text" inputmode="numeric" placeholder="HH:MM" maxlength="5" class="mil-time te-end" value="17:00">
            <button type="button" class="remove-entry-btn" disabled>&times;</button>
          </div>
        </div>
        <button type="button" class="add-entry-btn" id="addTimeEntryBtn">+ Add Time Entry</button>
      </div>

      <div class="checkbox-group">
        <input type="checkbox" id="shiftHoliday">
        <label for="shiftHoliday">Holiday</label>
      </div>

      <div class="checkbox-group hidden" id="shiftForcedOffGroup">
        <input type="checkbox" id="shiftForcedOff">
        <label for="shiftForcedOff">Forced Off (no cases)</label>
      </div>

      <div id="cardiacLiverOptions" class="hidden">
        <div class="divider"></div>
        <h3>Subspecialty Options</h3>
        <div class="checkbox-group">
          <input type="checkbox" id="subspecCoverage">
          <label for="subspecCoverage">Subspecialty coverage (45 pts/day)</label>
        </div>
        <div class="form-group">
          <label>TEE Exams Performed</label>
          <input type="number" id="teeCount" value="0" min="0">
        </div>
      </div>

      <div id="supervisionOverlaySection" class="hidden">
        <div class="divider"></div>
        <h3>CRNA Supervision</h3>
        <div class="checkbox-group">
          <input type="checkbox" id="supervisionOverlayCheck">
          <label for="supervisionOverlayCheck">Add CRNA supervision period (7 pts/hr)</label>
        </div>
        <div class="form-row hidden" id="supervisionTimes">
          <div class="form-group">
            <label>Supervision Start</label>
            <input type="text" inputmode="numeric" placeholder="HH:MM" maxlength="5" class="mil-time" id="supervisionStart">
          </div>
          <div class="form-group">
            <label>Supervision End</label>
            <input type="text" inputmode="numeric" placeholder="HH:MM" maxlength="5" class="mil-time" id="supervisionEnd">
          </div>
        </div>
      </div>

      <div id="preCallOverlaySection" class="hidden">
        <div class="divider"></div>
        <h3>Pre-Call</h3>
        <div class="checkbox-group">
          <input type="checkbox" id="preCallOverlayCheck">
          <label for="preCallOverlayCheck">Add pre-call OR period</label>
        </div>
        <div class="form-row hidden" id="preCallTimes">
          <div class="form-group">
            <label>Pre-Call Start</label>
            <input type="text" inputmode="numeric" placeholder="HH:MM" maxlength="5" class="mil-time" id="preCallStartInput">
          </div>
          <div class="form-group">
            <label>Pre-Call End</label>
            <input type="text" inputmode="numeric" placeholder="HH:MM" maxlength="5" class="mil-time" id="preCallEndInput">
          </div>
        </div>
      </div>

      <div id="tempCoverageSection" class="hidden">
        <div class="divider"></div>
        <h3>Temporary Coverage</h3>
        <div class="checkbox-group">
          <input type="checkbox" id="tempCoverageCheck">
          <label for="tempCoverageCheck">Add temporary coverage period</label>
        </div>
        <div class="hidden" id="tempCoverageForm">
          <div class="form-group" style="margin-top:8px;">
            <label>Direction</label>
            <div style="display:flex;gap:16px;">
              <label style="display:flex;align-items:center;gap:4px;font-size:0.85rem;cursor:pointer;">
                <input type="radio" name="tcDirection" value="covered" checked> Someone covering for me
              </label>
              <label style="display:flex;align-items:center;gap:4px;font-size:0.85rem;cursor:pointer;">
                <input type="radio" name="tcDirection" value="covering"> I'm covering for someone
              </label>
            </div>
          </div>
          <div class="form-row" style="margin-top:8px;">
            <div class="form-group">
              <label>Coverage Start</label>
              <input type="text" inputmode="numeric" placeholder="HH:MM" maxlength="5" class="mil-time" id="tcStart">
            </div>
            <div class="form-group">
              <label>Coverage End</label>
              <input type="text" inputmode="numeric" placeholder="HH:MM" maxlength="5" class="mil-time" id="tcEnd">
            </div>
          </div>
          <div id="tcTimeEntriesSection" class="hidden">
            <div class="form-group" style="margin-top:8px;">
              <label>Work Time Entries <span style="font-size:0.75rem;color:var(--text-dim);">(clock-in during coverage)</span></label>
              <div id="tcTimeEntriesContainer"></div>
              <button type="button" class="add-entry-btn" id="addTCTimeEntryBtn">+ Add Coverage Entry</button>
            </div>
          </div>
        </div>
      </div>

      <div id="eveningAssignmentSection" class="hidden">
        <div class="divider"></div>
        <div class="form-group">
          <label>Evening Assignment</label>
          <select id="eveningAssignmentType">
            <option value="">None</option>
            <option value="mole">Mole</option>
            <option value="OB_restricted">UVH OB</option>
          </select>
        </div>
        <div id="eveningTimeSection" class="hidden">
          <div class="form-group">
            <label>Evening Time Entries <span style="font-size:0.75rem;color:var(--text-dim);">(leave blank if no clock-in)</span></label>
            <div id="eveningTimeEntriesContainer"></div>
            <button type="button" class="add-entry-btn" id="addEveningTimeEntryBtn">+ Add Evening Entry</button>
          </div>
        </div>
      </div>

      <div style="margin-top: 16px; display:flex; gap:10px; align-items:center;">
        <button class="btn btn-primary" id="saveShiftBtn">Save Shift</button>
        <button class="btn btn-outline btn-sm hidden" id="switchToCaseEntryBtn" style="font-size:0.8rem;">Add Cases &rarr;</button>
        <button class="btn btn-danger btn-sm hidden" id="deleteShiftDE" style="margin-left:auto;">Delete Shift</button>
      </div>
    </div>
  </div>

  <!-- Case section (hidden until shift is saved) -->
  <div id="deCaseSection" class="hidden">
    <button class="btn btn-outline btn-sm" id="switchToShiftEntryBtn" style="margin-bottom:10px;font-size:0.8rem;">&larr; Edit Shift</button>
    <div class="card">
      <div class="card-collapse-header" id="quickProcCollapseHeader">
        <h2>Quick Procedures</h2>
        <span class="arrow" id="quickProcArrow">&#9660;</span>
      </div>
      <div class="card-collapse-body" id="quickProcCollapseBody" style="max-height:0;">
        <div class="template-grid" style="padding-top:12px;">
          <button class="template-btn" data-qproc="colonoscopy">
            <span class="t-label">Colonoscopy</span>
            <span class="t-time">4 base units</span>
          </button>
          <button class="template-btn" data-qproc="egd">
            <span class="t-label">EGD</span>
            <span class="t-time">5 base units</span>
          </button>
          <button class="template-btn" data-qproc="double">
            <span class="t-label">Double / EGD+Colo</span>
            <span class="t-time">5 base units</span>
          </button>
          <button class="template-btn" data-qproc="tonsils">
            <span class="t-label">Tonsils</span>
            <span class="t-time">5 base units</span>
          </button>
        </div>
      </div>
    </div>

    <div class="card">
      <h2>Log a Case</h2>

      <div class="form-group">
        <label>Case Type</label>
        <select id="caseTypeSelect">
          <option value="standard" selected>Standard Case</option>
          <option value="labor_epidural">Labor Epidural</option>
          <option value="acute_pain_procedure">Acute Pain Procedure</option>
          <option value="epidural_blood_patch">Epidural Blood Patch</option>
          <option value="emergency_intubation">Emergency Intubation</option>
          <option value="01996">Epidural Rounding (01996)</option>
          <option value="99231">Pain Rounding (99231)</option>
          <option value="tee">TEE Exam</option>
          <option value="aps_rounding">APS Rounding</option>
        </select>
      </div>

      <div id="standardFields">
        <div class="form-group proc-autocomplete">
          <label>Procedure Name</label>
          <input type="text" id="caseProcedure" placeholder="e.g., Lap Chole, Total Knee" autocomplete="off">
          <div class="proc-suggestions hidden" id="procSuggestions"></div>
        </div>

        <div class="form-row">
          <div class="form-group">
            <label>ASA Base Units</label>
            <input type="number" id="caseBaseUnits" min="0" step="1" placeholder="Units">
          </div>
          <div class="form-group">
            <label>Physical Status</label>
            <select id="casePhysicalStatus">
              <option value="P1">P1</option>
              <option value="P2" selected>P2</option>
              <option value="P3">P3</option>
              <option value="P4">P4</option>
              <option value="P5">P5</option>
            </select>
          </div>
        </div>

        <div class="form-row">
          <div class="form-group">
            <label>Anesthesia Start</label>
            <input type="text" inputmode="numeric" placeholder="HH:MM" maxlength="5" class="mil-time" id="caseStart">
          </div>
          <div class="form-group">
            <label>Anesthesia End</label>
            <input type="text" inputmode="numeric" placeholder="HH:MM" maxlength="5" class="mil-time" id="caseEnd">
          </div>
        </div>

        <details class="modifiers-section" id="modifiersSection">
          <summary>Modifiers <span class="modifier-tags" id="modifierTags"></span></summary>
          <div style="padding:8px 0 4px;">
            <div class="checkbox-group">
              <input type="checkbox" id="caseEmergency">
              <label for="caseEmergency">Emergency Case (+1 pt)</label>
            </div>
            <div class="checkbox-group">
              <input type="checkbox" id="caseHighRiskPeds">
              <label for="caseHighRiskPeds">High Risk Pediatrics (1.33x time)</label>
            </div>
            <div class="checkbox-group hidden" id="orCaseRow">
              <input type="checkbox" id="caseORCase" checked>
              <label for="caseORCase">OR Case (use OR rates, no OB doubling)</label>
            </div>
            <div class="checkbox-group">
              <input type="checkbox" id="caseShared">
              <label for="caseShared">Shared/Split Case</label>
            </div>
            <div class="form-group hidden" id="sharedPctRow">
              <label>Startup Points Credit %</label>
              <input type="number" id="caseSharedPct" min="0" max="100" value="50" step="1">
            </div>
          </div>
        </details>

        <details class="modifiers-section">
          <summary>Additional Procedures</summary>
          <div style="padding:8px 0 4px;">
            <div class="form-group">
              <label>Nerve Block</label>
              <select id="caseNerveBlock">
                <option value="none">None</option>
                <option value="brachial_plexus">Brachial Plexus (3 pts)</option>
                <option value="other">Other (2.6 pts)</option>
                <option value="it_morphine">IT Morphine (3 pts)</option>
              </select>
            </div>
            <div class="form-row">
              <div class="checkbox-group">
                <input type="checkbox" id="caseCentralLine">
                <label for="caseCentralLine">Central Line (0.8 pts)</label>
              </div>
              <div class="checkbox-group">
                <input type="checkbox" id="caseArterialLine">
                <label for="caseArterialLine">Arterial Line (0.6 pts)</label>
              </div>
            </div>
            <div class="form-row">
              <div class="checkbox-group">
                <input type="checkbox" id="casePAC">
                <label for="casePAC">PAC (2 pts)</label>
              </div>
              <div class="checkbox-group">
                <input type="checkbox" id="caseTEEAddOn">
                <label for="caseTEEAddOn">TEE (0.4 pts)</label>
              </div>
            </div>
            <div class="checkbox-group">
              <input type="checkbox" id="caseITMorphine">
              <label for="caseITMorphine">IT Morphine (3 pts)</label>
            </div>
          </div>
        </details>
      </div>

      <div id="laborEpiduralFields" class="hidden">
        <div class="form-row">
          <div class="form-group">
            <label>Epidural Start</label>
            <input type="text" inputmode="numeric" placeholder="HH:MM" maxlength="5" class="mil-time" id="laborStart">
          </div>
          <div class="form-group">
            <label>Epidural End</label>
            <input type="text" inputmode="numeric" placeholder="HH:MM" maxlength="5" class="mil-time" id="laborEnd">
          </div>
        </div>
      </div>

      <div id="apsRoundingFields" class="hidden">
        <div class="form-row">
          <div class="form-group">
            <label>Epidural Rounds (3 pts each)</label>
            <input type="number" id="apsEpiduralCount" min="0" step="1" value="0">
          </div>
          <div class="form-group">
            <label>Pain Rounds (2 pts each)</label>
            <input type="number" id="apsPainCount" min="0" step="1" value="0">
          </div>
        </div>
      </div>

      <div id="simpleFields" class="hidden">
        <div class="form-group">
          <label>Procedure Notes (optional)</label>
          <input type="text" id="simpleNotes" placeholder="Optional notes">
        </div>
      </div>

      <div class="form-group notes-autocomplete">
        <label>Notes (optional)</label>
        <textarea id="caseNotes" placeholder="Surgeon, location, or other notes" autocomplete="off"></textarea>
        <div class="surgeon-suggestions hidden" id="surgeonSuggestions"></div>
      </div>

      <div id="casePointPreview" class="point-breakdown hidden">
        <div class="row"><span>Estimated Points</span><span id="previewPoints">--</span></div>
      </div>

      <div style="margin-top: 16px;">
        <button class="btn btn-primary" id="saveCaseBtn">Save Case</button>
      </div>
    </div>
  </div>

  <!-- Daily case list -->
  <div class="card" id="deCaseListCard">
    <h2>Cases Today <span id="deCaseCount" style="font-size:0.8rem;color:var(--text-dim);font-weight:400;"></span></h2>
    <div class="de-case-list" id="deCaseList">
      <p style="color:var(--text-dim);font-size:0.85rem;">No cases logged yet.</p>
    </div>
  </div>

  <!-- Scan Billing Sheet (collapsible) -->
  <div class="card collapse-section">
    <div class="collapse-header" onclick="toggleCollapse('deScan')">
      <h3>&#128247; Scan Billing Sheet</h3>
      <span class="arrow" id="deScanArrow">&#9660;</span>
    </div>
    <div class="collapse-body" id="deScanBody">
      <div style="padding-top:12px;">
        <div class="form-group">
          <label style="font-size:0.8rem;color:var(--text-dim);">Sheet Date</label>
          <input type="date" id="scanDate">
        </div>
        <label class="scan-capture-area" id="scanCaptureArea">
          <span class="scan-icon">&#128247;</span>
          <p>Tap to take a photo</p>
          <input type="file" id="scanFileInput" accept="image/*" capture="environment" style="display:none;">
        </label>
        <img id="scanPreviewImg" class="scan-preview-img hidden" alt="Preview">
        <div id="scanStatus" class="hidden"></div>
        <div style="margin-top:8px;display:flex;gap:8px;" id="scanActions" class="hidden">
          <button class="btn btn-outline btn-sm" id="scanRetakeBtn" style="flex:1;">Retake</button>
          <button class="btn btn-sm" id="scanProcessBtn" style="flex:1;background:var(--primary);color:#fff;">Process</button>
        </div>
      </div>
    </div>
  </div>

  <div id="scanResultsArea" class="hidden">
    <div class="card" style="background:var(--surface);border:1px solid var(--border);">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
        <h3 style="margin:0;font-size:0.95rem;">Parsed Cases</h3>
        <span id="scanCaseCount" style="font-size:0.8rem;color:var(--text-dim);"></span>
      </div>
      <p style="font-size:0.75rem;color:var(--text-dim);margin-bottom:12px;">Review and edit before importing. Remove any incorrect entries.</p>
      <div id="scanCaseCards"></div>
    </div>
    <div style="padding:0 16px 16px;">
      <button class="btn btn-sm" id="scanImportBtn" style="width:100%;background:var(--accent);color:#fff;font-size:0.95rem;padding:12px;">Import Cases</button>
    </div>
  </div>
</div>

<!-- TODAY PAGE -->
<div class="page active" id="page-today">
  <div class="card hidden" id="todayPVReminder" style="background:var(--accent2); color:#000; padding:10px 16px; display:flex; align-items:center; justify-content:space-between; margin-bottom:8px;">
    <span style="font-size:0.85rem; font-weight:600;"><span id="todayPVReminderText"></span> <a href="#" onclick="goToPVHistory(); return false;" style="color:#000; text-decoration:underline; font-weight:400;">Update now</a></span>
    <button onclick="dismissPVReminder()" style="background:none; border:none; color:#000; font-size:1.2rem; cursor:pointer; padding:0 4px;">&times;</button>
  </div>
  <div class="card hidden" id="openLaborReminder" style="background:var(--danger); color:#fff; padding:10px 16px; display:flex; align-items:center; justify-content:space-between; margin-bottom:8px;">
    <span style="font-size:0.85rem; font-weight:600;" id="openLaborReminderText"></span>
    <button onclick="document.getElementById('openLaborReminder').classList.add('hidden')" style="background:none; border:none; color:#fff; font-size:1.2rem; cursor:pointer; padding:0 4px;">&times;</button>
  </div>
  <div id="todayBackBar" class="hidden" style="display:none;align-items:center;gap:8px;margin-bottom:8px;">
    <button class="btn btn-outline btn-sm" id="todayBackBtn" style="padding:4px 12px;font-size:0.8rem;">&larr; Daily</button>
  </div>
  <div class="card" id="weeklyChartCard">
    <div style="display:flex;align-items:center;justify-content:space-between;">
      <h2 style="margin:0;">This Week</h2>
      <div style="display:flex;align-items:center;gap:6px;">
        <button class="btn btn-sm btn-outline" id="weeklyToggleBtn" style="padding:2px 8px;font-size:0.7rem;min-width:32px;">$</button>
      </div>
    </div>
    <div style="position:relative;height:200px;margin:8px 0;">
      <canvas id="weeklyBarCanvas"></canvas>
    </div>
    <div id="weeklySummary" style="text-align:center;font-size:0.8rem;color:var(--text-dim);"></div>
  </div>

  <div class="card" id="todayBreakdownCard" style="padding:12px 16px;">
    <div style="display:flex;align-items:center;justify-content:space-between;">
      <h2 id="todayTitle" style="margin:0;font-size:0.9rem;">Today</h2>
      <button class="btn btn-sm hidden" id="todayEditShiftBtn" style="padding:4px 10px;font-size:0.72rem;background:none;color:var(--primary);">Edit Shift</button>
    </div>
    <div id="todayBreakdown"></div>
  </div>

  <div class="card">
    <h2>Cases <span id="todayCaseCount"></span></h2>
    <div id="todayCaseList">
      <div class="empty-state">
        <p>No cases logged yet.</p>
      </div>
    </div>
    <button type="button" class="btn btn-primary" id="todayAddCasesBtn" style="margin-top:12px;">+ Add Cases</button>
  </div>
</div>

<!-- DASHBOARD PAGE -->
<div class="page" id="page-dashboard">
  <div class="dash-sticky-header" id="dashStickyHeader">
    <div class="dash-tab-bar">
      <button class="dash-tab-btn active" data-dtab="daily">Daily</button>
      <button class="dash-tab-btn" data-dtab="caselogs">Case Logs</button>
      <button class="dash-tab-btn" data-dtab="shiftlogs">Shift Logs</button>
      <button class="dash-tab-btn" data-dtab="time">Time</button>
      <button class="dash-tab-btn" data-dtab="analytics">Analytics</button>
      <button class="dash-tab-btn" data-dtab="reconcile">Reconcile</button>
    </div>
  </div>
  <div id="dashStickyHeaderSpacer"></div>

  <!-- Case Logs Tab -->
  <div id="dtab-caselogs" class="hidden">
    <div class="month-nav">
      <button id="clPrevMonth">&larr;</button>
      <span id="clMonthLabel">January 2026</span>
      <button id="clNextMonth">&rarr;</button>
    </div>
    <input type="text" class="case-log-search" id="caseLogSearch" placeholder="Search cases...">
    <button id="clDeleteSelectedBtn" class="hidden">Delete Selected (<span id="clDeleteSelectedCount">0</span>)</button>
    <div class="case-log-wrap">
      <div id="caseLogTableContainer">
        <div class="empty-state"><p>No cases for this month.</p></div>
      </div>
    </div>
  </div>

  <!-- Shift Logs Tab -->
  <div id="dtab-shiftlogs" class="hidden">
    <div class="month-nav">
      <button id="slPrevMonth">&larr;</button>
      <span id="slMonthLabel">January 2026</span>
      <button id="slNextMonth">&rarr;</button>
    </div>
    <div class="card" id="shiftLogSummary"></div>
    <input type="text" class="case-log-search" id="shiftLogSearch" placeholder="Search shifts...">
    <div id="slDeleteBar" class="sl-delete-bar hidden">
      <span class="sl-del-count" id="slDeleteCount">0 selected</span>
      <button class="sl-del-action" onclick="deleteSelectedShifts()">Delete Selected</button>
    </div>
    <div class="case-log-wrap">
      <div id="shiftLogTableContainer">
        <div class="empty-state"><p>No shifts for this month.</p></div>
      </div>
    </div>
  </div>

  <!-- Time Tab -->
  <div id="dtab-time" class="hidden">
    <!-- Time Summary (compact) -->
    <div class="card" style="padding:10px 14px;">
      <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:4px;">
        <span style="font-size:0.78rem;font-weight:600;">Time Summary</span>
        <span style="font-size:0.68rem;color:var(--text-dim);">Past 3 Months</span>
      </div>
      <div style="display:grid;grid-template-columns:1fr 1fr 1fr 1fr;gap:4px;text-align:center;">
        <div>
          <div style="font-size:0.62rem;color:var(--text-dim);text-transform:uppercase;">Hrs/Mo</div>
          <div style="font-size:0.9rem;font-weight:600;color:var(--primary);" id="timeAvgMonth">0</div>
        </div>
        <div>
          <div style="font-size:0.62rem;color:var(--text-dim);text-transform:uppercase;">Hrs/Wk</div>
          <div style="font-size:0.9rem;font-weight:600;color:var(--accent);" id="timeAvgWeek">0</div>
        </div>
        <div>
          <div style="font-size:0.62rem;color:var(--text-dim);text-transform:uppercase;">Avg Start</div>
          <div style="font-size:0.9rem;font-weight:600;color:#facc15;" id="timeAvgStart">--:--</div>
        </div>
        <div>
          <div style="font-size:0.62rem;color:var(--text-dim);text-transform:uppercase;">Avg End</div>
          <div style="font-size:0.9rem;font-weight:600;color:#a78bfa;" id="timeAvgEnd">--:--</div>
        </div>
      </div>
    </div>

    <!-- Hours Trend -->
    <div class="card">
      <h2>Monthly Hours Trend</h2>
      <p style="font-size:0.8rem;color:var(--text-dim);margin-bottom:8px;">Average workday length per month (clock-in to clock-out)</p>
      <div class="chart-container">
        <canvas id="productionTrendChart"></canvas>
      </div>
    </div>

    <!-- Assignment Data (combined) -->
    <div class="card">
      <h2>Assignment Data</h2>
      <div style="display:flex;gap:6px;margin-bottom:12px;flex-wrap:wrap;">
        <button class="tab-btn active" id="adTabTotals" onclick="switchAssignDataTab('totals')">Average Shift Totals</button>
        <button class="tab-btn" id="adTabDOW" onclick="switchAssignDataTab('dow')">Day of Week</button>
        <button class="tab-btn" id="adTabEfficiency" onclick="switchAssignDataTab('efficiency')">Shift Efficiency</button>
        <button class="tab-btn" id="adTabWorkerBee" onclick="switchAssignDataTab('workerBee')">Worker Bee Averages</button>
      </div>
      <div id="assignDataContent"></div>
    </div>

    <!-- Procedure Time Lookup -->
    <div class="card">
      <h2>Procedure Time Lookup</h2>
      <p style="font-size:0.78rem;color:var(--text-dim);margin-bottom:8px;">Search a procedure to see average case duration by surgeon</p>
      <input type="text" id="procLookupSearch" placeholder="Type procedure name..." oninput="renderProcLookup()" autocomplete="off" style="width:100%;margin-bottom:8px;">
      <div id="procLookupResults"></div>
    </div>

    <!-- Collapsible: Weekend vs Weekday -->
    <div class="card collapse-section">
      <div class="collapse-header" onclick="toggleCollapse('timeWknd')">
        <h3>Weekend vs Weekday</h3>
        <span class="arrow" id="timeWkndArrow">&#9660;</span>
      </div>
      <div class="collapse-body" id="timeWkndBody">
        <div id="wkndContent" style="padding-top:12px;"></div>
      </div>
    </div>

    <!-- Collapsible: Night & Call Frequency -->
    <div class="card collapse-section">
      <div class="collapse-header" onclick="toggleCollapse('timeNight')">
        <h3>Call Shift Tally (3 mo)</h3>
        <span class="arrow" id="timeNightArrow">&#9660;</span>
      </div>
      <div class="collapse-body" id="timeNightBody">
        <div id="nightContent" style="padding-top:12px;"></div>
      </div>
    </div>
  </div>

  <!-- Analytics Tab -->
  <div id="dtab-analytics" class="hidden">
    <!-- Top Producing Cases -->
    <div class="card">
      <h2>Top Producing Cases</h2>
      <div id="caseMixContent">
        <div class="empty-state"><p>No case data.</p></div>
      </div>
    </div>

    <!-- Procedure Efficiency -->
    <div class="card">
      <h2>Procedure Efficiency (pts/hr)</h2>
      <div style="display:flex;gap:6px;margin-bottom:12px;flex-wrap:wrap;">
        <button class="tab-btn active" id="peTabTop" onclick="switchProcTab('top')">Top Procedures</button>
        <button class="tab-btn" id="peTabGrow" onclick="switchProcTab('grow')">Room to Grow</button>
        <button class="tab-btn" id="peTabAll" onclick="switchProcTab('all')">All Procedures</button>
      </div>
      <div id="topProcContent"></div>
    </div>

    <!-- Surgeon Efficiency -->
    <div class="card">
      <h2>Surgeon Efficiency (pts/hr)</h2>
      <div style="display:flex;gap:6px;margin-bottom:12px;flex-wrap:wrap;">
        <button class="tab-btn active" id="seTabTop" onclick="switchSurgeonTab('top')">Top Surgeons</button>
        <button class="tab-btn" id="seTabGrow" onclick="switchSurgeonTab('grow')">Room to Grow</button>
        <button class="tab-btn" id="seTabAll" onclick="switchSurgeonTab('all')">All Surgeons</button>
      </div>
      <div id="surgeonEffContent"></div>
    </div>
  </div>

  <!-- Daily Totals Tab -->
  <div id="dtab-daily">
    <div class="month-nav">
      <button id="dailyPrevMonth">&larr;</button>
      <span id="dailyMonthLabel">January 2026</span>
      <button id="dailyNextMonth">&rarr;</button>
    </div>
    <div id="dailyCalendarContainer" style="margin-top:12px;"></div>
    <div id="dailyMonthSummary" style="margin-top:12px;font-size:0.85rem;color:var(--text-dim);text-align:center;"></div>
  </div>

  <!-- Reconcile Tab -->
  <div id="dtab-reconcile" class="hidden">
    <div class="tab-bar">
      <button class="tab-btn active" data-rtab="qgenda">QGenda Time</button>
      <button class="tab-btn" data-rtab="production">Production</button>
    </div>

    <!-- QGenda Tab -->
    <div id="rtab-qgenda">
      <div class="card">
        <h2>QGenda Time Reconciliation</h2>
        <p style="font-size:0.8rem;color:var(--text-dim);margin-bottom:12px;">
          Upload your QGenda time punch export (.xlsx or .csv) or screenshot to compare against your tracked shifts.
        </p>
        <div class="upload-area" id="qgendaUploadArea">
          <div style="font-size:2rem;">&#128196;</div>
          <p>Tap to upload QGenda .xlsx, .csv, or screenshot</p>
          <input type="file" id="qgendaFile" accept=".xlsx,.xls,.csv,.png,.jpg,.jpeg">
        </div>
      </div>

      <div class="month-nav" style="margin-top:12px;">
        <button id="qPrevMonth">&larr;</button>
        <span id="qMonthLabel">January 2026</span>
        <button id="qNextMonth">&rarr;</button>
      </div>

      <div id="qgendaResults"></div>
    </div>

    <!-- Production Tab -->
    <div id="rtab-production" class="hidden">
      <div class="card">
        <h2>Production Reconciliation</h2>
        <p style="font-size:0.8rem;color:var(--text-dim);margin-bottom:12px;">
          Upload your Charge Detail PDF or screenshot to compare billing production against your tracked cases.
        </p>
        <div class="upload-area" id="prodUploadArea">
          <div style="font-size:2rem;">&#128196;</div>
          <p>Tap to upload Charge Detail PDF or screenshot</p>
          <input type="file" id="prodFile" accept=".pdf,.png,.jpg,.jpeg">
        </div>
      </div>

      <div class="month-nav" style="margin-top:12px;">
        <button id="pPrevMonth">&larr;</button>
        <span id="pMonthLabel">January 2026</span>
        <button id="pNextMonth">&rarr;</button>
      </div>

      <div id="prodResults"></div>
    </div>
  </div>
</div>

<!-- COMPENSATION PAGE -->
<div class="page" id="page-compensation">
  <!-- PV Reminder Banner -->
  <div class="card hidden" id="pvReminderBanner" style="background:var(--accent2); color:#000; padding:10px 16px; display:flex; align-items:center; justify-content:space-between;">
    <span style="font-size:0.85rem; font-weight:600;"><span id="pvReminderText">Last month's $/point hasn't been confirmed yet.</span> <a href="#" onclick="togglePVHistory(); return false;" style="color:#000; text-decoration:underline; font-weight:400;">Update now</a></span>
    <button onclick="dismissPVReminder()" style="background:none; border:none; color:#000; font-size:1.2rem; cursor:pointer; padding:0 4px;">&times;</button>
  </div>

  <!-- 1. Monthly Pace (hero, compact) -->
  <div class="card" style="padding:12px 16px;">
    <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:6px;">
      <span style="font-size:0.82rem;font-weight:600;">Monthly Pace</span>
      <span style="font-size:0.82rem;"><span id="paceCurrentPts" style="color:var(--primary);font-weight:600;">0</span> <span style="color:var(--text-dim);font-size:0.75rem;">/ <span id="paceProjected">0</span> projected</span></span>
    </div>
    <div style="background:var(--surface2); border-radius:6px; height:8px; overflow:hidden;">
      <div id="paceBar" style="height:100%; background:var(--primary); border-radius:6px; transition:width 0.3s; width:0%;"></div>
    </div>
    <div id="paceLabel" style="font-size:0.72rem; color:var(--text-dim); margin-top:4px; text-align:center;"></div>
  </div>

  <!-- 2. Paycheck Projection (with $/point inline) -->
  <div class="card">
    <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px;">
      <h2 style="margin:0;">Paycheck Projection</h2>
      <div style="display:flex;align-items:center;gap:8px;">
        <label style="font-size:0.75rem;color:var(--text-dim);white-space:nowrap;">$/pt</label>
        <input type="number" id="dashPointValue" min="0" step="0.01" placeholder="55.00" style="max-width:90px;padding:4px 8px;font-size:0.8rem;">
        <button class="btn btn-outline btn-sm" id="pvHistoryToggle" onclick="togglePVHistory()" style="padding:3px 8px;font-size:0.7rem;white-space:nowrap;">History &#9660;</button>
      </div>
    </div>
    <div id="pvHistoryPanel" style="max-height:0;overflow:hidden;transition:max-height 0.3s ease;">
      <div style="padding-bottom:12px;border-bottom:1px solid var(--surface2);margin-bottom:12px;">
        <p style="font-size:0.8rem;color:var(--text-dim);margin-bottom:12px;">
          Enter confirmed $/point values for past months. Revenue calculations will use confirmed values instead of the global estimate.
        </p>
        <div id="pvHistoryRows"></div>
        <button class="btn btn-primary btn-sm" id="savePVHistoryBtn" style="margin-top:8px;">Save Point Values</button>
        <div id="pvHistoryStatus" style="font-size:0.75rem;color:var(--text-dim);margin-top:8px;"></div>
      </div>
    </div>
    <p style="font-size:0.8rem; color:var(--text-dim); margin-bottom:12px;">
      Your paycheck is based on a weighted blend of the last 5 months, not just this month alone.
    </p>
    <div id="stabPaycheckRow" style="text-align:center; margin-bottom:12px;">
      <div style="font-size:1.6rem; font-weight:700; color:var(--accent2);" id="stabPaycheck">&mdash;</div>
      <div style="font-size:0.75rem; color:var(--text-dim); margin-top:4px;" id="stabPaycheckLabel">Projected next month's paycheck</div>
      <div style="font-size:0.78rem; color:var(--text-dim); margin-top:6px;" id="stabCurrentPaycheck"></div>
    </div>
    <div class="summary-grid">
      <div class="summary-item">
        <div class="label">This Month (raw)</div>
        <div class="value blue" id="stabRaw">0</div>
      </div>
      <div class="summary-item">
        <div class="label">Blended Points</div>
        <div class="value green" id="stabWeighted">0</div>
      </div>
    </div>
    <div style="margin-top:12px;text-align:center;">
      <a href="#" id="stabBreakdownToggle" onclick="toggleStabBreakdown(); return false;" style="font-size:0.8rem;color:var(--primary);">Show breakdown &#9660;</a>
    </div>
    <div id="stabBreakdown" style="max-height:0;overflow:hidden;transition:max-height 0.3s ease;"></div>
  </div>

  <!-- 3. Income Pipeline -->
  <div class="card">
    <h2>Income Pipeline</h2>
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
      <p style="font-size:0.78rem; color:var(--text-dim); margin:0;">
        Estimated paychecks from recorded data
      </p>
      <label class="toggle-row">
        <span>Include projections</span>
        <span class="toggle-switch">
          <input type="checkbox" id="pipelineProjectToggle">
          <span class="slider"></span>
        </span>
      </label>
    </div>
    <div class="chart-container">
      <canvas id="pipelineChart"></canvas>
    </div>
    <div id="pipelineSummary" style="margin-top:8px; font-size:0.78rem; color:var(--text-dim); text-align:center;"></div>
    <div id="pipelineUnreceived" style="margin-top:8px; text-align:center;"></div>
  </div>

  <!-- 4. Monthly Trend (with annual income stats above chart) -->
  <div class="card">
    <div style="display:flex;align-items:center;justify-content:space-between;">
      <h2 style="margin:0;">Monthly Trend</h2>
      <button class="btn btn-sm btn-outline" id="monthlyTrendToggle" style="padding:2px 8px;font-size:0.7rem;min-width:32px;">$</button>
    </div>
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:6px 12px;margin:12px 0;padding:10px 12px;background:var(--surface2);border-radius:8px;">
      <div style="text-align:center;">
        <div style="font-size:0.65rem;color:var(--text-dim);text-transform:uppercase;letter-spacing:0.5px;">3-Mo Avg</div>
        <div style="font-size:0.95rem;font-weight:600;color:var(--primary);" id="projRollingAvg">0</div>
      </div>
      <div style="text-align:center;">
        <div style="font-size:0.65rem;color:var(--text-dim);text-transform:uppercase;letter-spacing:0.5px;">Annual Proj</div>
        <div style="font-size:0.95rem;font-weight:600;color:var(--accent2);" id="projAnnualIncome">&mdash;</div>
      </div>
      <div style="text-align:center;">
        <div style="font-size:0.65rem;color:var(--text-dim);text-transform:uppercase;letter-spacing:0.5px;">YTD Revenue</div>
        <div style="font-size:0.95rem;font-weight:600;color:#facc15;" id="projYTDRevenue">&mdash;</div>
      </div>
      <div style="text-align:center;">
        <div style="font-size:0.65rem;color:var(--text-dim);text-transform:uppercase;letter-spacing:0.5px;">Remaining</div>
        <div style="font-size:0.95rem;font-weight:600;color:#a78bfa;" id="projRemaining">&mdash;</div>
      </div>
    </div>
    <div id="projYTDDetail" style="font-size:0.72rem; color:var(--text-dim); text-align:center; margin-bottom:8px;"></div>
    <div class="chart-container">
      <canvas id="monthlyChart"></canvas>
    </div>
    <div id="monthlyChartSummary" style="margin-top:10px; font-size:0.82rem; color:var(--text-dim); text-align:center;"></div>
  </div>

  <!-- 5. Monthly Stipends (collapsible) -->
  <div class="card collapse-section">
    <div class="collapse-header" onclick="toggleCollapse('compStipends')">
      <h3>Monthly Stipends</h3>
      <span class="arrow" id="compStipendsArrow">&#9660;</span>
    </div>
    <div class="collapse-body" id="compStipendsBody">
      <div style="padding-top:12px;">
        <p style="font-size:0.8rem;color:var(--text-dim);margin-bottom:12px;">
          Add fixed dollar amounts per month (e.g., medical director stipend, teaching pay). These contribute to revenue totals but not point calculations.
        </p>
        <div class="month-nav">
          <button id="stipPrevMonth">&larr;</button>
          <span id="stipMonthLabel">January 2026</span>
          <button id="stipNextMonth">&rarr;</button>
        </div>
        <div id="stipendEntries" style="margin-top:12px;"></div>
        <button type="button" class="add-entry-btn" id="addStipendBtn">+ Add Stipend</button>
        <div style="margin-top:8px;display:flex;gap:8px;">
          <button class="btn btn-primary btn-sm" id="saveStipendBtn">Save Stipends</button>
          <button class="btn btn-outline btn-sm" id="clearStipendBtn">Clear All</button>
        </div>
        <div id="stipendStatus" style="font-size:0.75rem;color:var(--text-dim);margin-top:8px;"></div>
      </div>
    </div>
  </div>
</div>

<!-- SETTINGS PAGE -->
<div class="page" id="page-settings">
  <!-- Settings -->
  <div class="card">
    <h2>Settings</h2>
    <div class="settings-field">
      <label>Name</label>
      <input type="text" id="settingsName" placeholder="Your name (labels exports)">
    </div>
    <div class="settings-field" style="margin-top:12px;">
      <label>Point Value Estimate ($/pt)</label>
      <input type="number" id="settingsPointValue" min="0" step="0.01" style="max-width:140px;">
    </div>
    <label class="toggle-row" style="margin-top:12px;">
      <span>December advance paycheck</span>
      <span class="toggle-switch">
        <input type="checkbox" id="decAdvanceToggle" checked>
        <span class="slider"></span>
      </span>
    </label>
    <p style="font-size:0.72rem;color:var(--text-dim);margin-top:4px;">
      December includes January's paycheck advance; January shows $0.
    </p>
  </div>

  <!-- Scan Settings -->
  <div class="card" style="margin-top:12px;">
    <h2>Scan Settings</h2>
    <div style="margin-bottom:12px;">
      <label for="settingsVisionKey" style="display:block;font-size:0.85rem;color:var(--text-dim);margin-bottom:6px;">Google Cloud Vision API Key</label>
      <input type="password" id="settingsVisionKey" placeholder="Paste your API key" style="width:100%;padding:8px 10px;border-radius:6px;border:1px solid var(--border);background:var(--surface);color:var(--text);font-size:0.85rem;min-height:40px;">
    </div>
    <p style="font-size:0.72rem;color:var(--text-dim);margin-bottom:8px;">
      Required for billing sheet scanning. Free tier: 1,000 scans/month. Each user needs their own key.
    </p>
    <details style="margin-top:4px;">
      <summary style="cursor:pointer;font-size:0.8rem;color:var(--primary);">How to get an API key</summary>
      <ol style="font-size:0.75rem;color:var(--text-dim);margin:8px 0 0 0;padding-left:20px;line-height:1.6;">
        <li>Go to <a href="https://console.cloud.google.com" target="_blank" rel="noopener" style="color:var(--primary);">Google Cloud Console</a></li>
        <li>Create a project (or select an existing one)</li>
        <li>Go to <strong>APIs &amp; Services &rarr; Library</strong></li>
        <li>Search for <strong>Cloud Vision API</strong> and click <strong>Enable</strong></li>
        <li>Go to <strong>APIs &amp; Services &rarr; Credentials</strong></li>
        <li>Click <strong>Create Credentials &rarr; API Key</strong></li>
        <li>Copy the key and paste it above</li>
        <li><strong>Recommended:</strong> Click <strong>Edit API Key</strong> to restrict it:
          <ul style="margin-top:4px;padding-left:16px;list-style:disc;">
            <li>Application restrictions &rarr; <strong>HTTP referrers</strong> &rarr; add <code style="background:var(--surface2);padding:1px 4px;border-radius:3px;">rileycrandall04.github.io/*</code></li>
            <li>API restrictions &rarr; <strong>Restrict key</strong> &rarr; select <strong>Cloud Vision API</strong> only</li>
          </ul>
        </li>
      </ol>
    </details>
  </div>

  <!-- Account -->
  <div class="card" id="accountCard">
    <h2>Account</h2>
    <div class="account-card" id="accountInfo">
      <img id="accountPhoto" src="" alt="">
      <div class="ac-info">
        <div class="ac-name" id="accountName"></div>
        <div class="ac-email" id="accountEmail"></div>
      </div>
      <span class="sync-indicator synced" id="syncStatus">Synced</span>
    </div>
    <button class="btn btn-outline btn-sm" id="signOutBtn">Sign Out</button>
    <button class="btn btn-outline btn-sm" onclick="showTutorial()" style="margin-top:8px;">Run Tutorial</button>
  </div>

  <!-- Calendar Sync -->
  <div class="card" style="margin-top:12px;">
    <h2>Calendar Sync</h2>
    <p style="font-size:0.8rem;color:var(--text-dim);margin-bottom:10px;">
      Sync your Google Calendar assignments to auto-fill shift types and label the weekly chart.
    </p>
    <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
      <button class="btn btn-outline btn-sm" id="syncCalendarBtn">Sync Calendar</button>
      <span id="calendarLastSync" style="font-size:0.75rem;color:var(--text-dim);"></span>
    </div>
    <details style="margin-top:10px;">
      <summary style="cursor:pointer;font-size:0.8rem;color:var(--primary);">Setup instructions</summary>
      <ol style="font-size:0.75rem;color:var(--text-dim);margin:8px 0 0 0;padding-left:20px;line-height:1.6;">
        <li>Go to <a href="https://console.cloud.google.com/apis/library/calendar-json.googleapis.com" target="_blank" rel="noopener" style="color:var(--primary);">Google Cloud Console</a></li>
        <li>Select the <strong>mwa-point-tracker</strong> project</li>
        <li>Click <strong>Enable</strong> for the Google Calendar API</li>
        <li>Sign out and sign back in to grant calendar permission</li>
        <li>Your calendar named "Riley" will be synced automatically</li>
      </ol>
    </details>
  </div>

  <!-- Export / Import -->
  <div class="card">
    <h2>Data Management</h2>
    <div style="display:flex; gap:8px; flex-wrap:wrap;">
      <button class="btn btn-outline btn-sm" id="exportCSVBtn">Export CSV</button>
      <button class="btn btn-outline btn-sm" id="exportAllBtn">Export JSON</button>
      <label class="btn btn-outline btn-sm" style="cursor:pointer;">
        Import JSON
        <input type="file" id="importFile" accept=".json" style="display:none;">
      </label>
      <button class="btn btn-danger btn-sm" id="clearAllBtn">Clear All Data</button>
    </div>
    <div style="margin-top:12px;">
      <button class="btn btn-outline btn-sm" id="loadTestDataBtn" style="border-color:var(--accent2);color:var(--accent2);">Load Test Data (3 months)</button>
    </div>
  </div>
</div>

<!-- HISTORY PAGE -->
<div class="page" id="page-history">
  <!-- Monthly Point Override (collapsible) -->
  <div class="card collapse-section">
    <div class="collapse-header" onclick="toggleCollapse('histOverride')">
      <h3>Monthly Point Override</h3>
      <span class="arrow" id="histOverrideArrow">&#9660;</span>
    </div>
    <div class="collapse-body" id="histOverrideBody">
      <div style="padding-top:12px;">
        <p style="font-size:0.8rem;color:var(--text-dim);margin-bottom:12px;">
          Override calculated points for a month to match QGenda or billing records.
        </p>
        <div class="month-nav">
          <button id="ovPrevMonth">&larr;</button>
          <span id="ovMonthLabel">January 2026</span>
          <button id="ovNextMonth">&rarr;</button>
        </div>
        <div style="display:flex;gap:12px;margin-top:12px;">
          <div style="flex:1;">
            <label style="display:block;font-size:0.75rem;color:var(--text-dim);margin-bottom:4px;">Time Points</label>
            <input type="number" id="overrideTimePoints" min="0" step="0.01" placeholder="Calculated: —" style="width:100%;padding:8px 10px;border-radius:6px;border:1px solid var(--border);background:var(--surface);color:var(--text);font-size:0.85rem;min-height:40px;">
          </div>
          <div style="flex:1;">
            <label style="display:block;font-size:0.75rem;color:var(--text-dim);margin-bottom:4px;">Production Points</label>
            <input type="number" id="overrideProdPoints" min="0" step="0.01" placeholder="Calculated: —" style="width:100%;padding:8px 10px;border-radius:6px;border:1px solid var(--border);background:var(--surface);color:var(--text);font-size:0.85rem;min-height:40px;">
          </div>
        </div>
        <div style="margin-top:10px;display:flex;gap:8px;">
          <button class="btn btn-primary btn-sm" id="saveOverrideBtn">Save Override</button>
          <button class="btn btn-outline btn-sm" id="clearOverrideBtn">Clear</button>
        </div>
        <div id="overrideStatus" style="font-size:0.75rem;color:var(--text-dim);margin-top:8px;"></div>
      </div>
    </div>
  </div>

  <!-- Monthly History -->
  <div class="card">
    <h2>Monthly History</h2>
    <div class="month-nav">
      <button id="prevMonth">&larr;</button>
      <span id="historyMonth">January 2026</span>
      <button id="nextMonth">&rarr;</button>
    </div>
    <div class="summary-grid">
      <div class="summary-item">
        <div class="label">Monthly Total</div>
        <div class="value blue" id="monthTotal">0</div>
      </div>
      <div class="summary-item">
        <div class="label">Days Worked</div>
        <div class="value green" id="monthDays">0</div>
      </div>
    </div>
    <div id="historyList">
      <div class="empty-state"><p>No shifts recorded for this month.</p></div>
    </div>
  </div>
</div>

<!-- IMPORT PAGE -->
<div class="page" id="page-import">
  <!-- Import Shifts from QGenda -->
  <div class="card">
    <h2>Import Shifts from QGenda</h2>
    <p style="font-size:0.8rem;color:var(--text-dim);margin-bottom:12px;">
      Upload a QGenda time punch export (.xlsx, .csv, or screenshot) to import shifts into the tracker.
      Dates with existing shifts will be skipped.
    </p>
    <details style="font-size:0.75rem;color:var(--text-dim);margin-bottom:12px;">
      <summary style="cursor:pointer;color:var(--accent);font-weight:600;">Required CSV/Excel format</summary>
      <div style="margin-top:8px;padding:8px;background:var(--surface);border-radius:6px;line-height:1.6;">
        <strong>Required columns (exact header names):</strong><br>
        Schedule Date, Effective Clock In Date, Effective Clock In Time,
        Effective Clock Out Date, Effective Clock Out Time, Duration,
        Scheduled Task Abbreviation<br><br>
        <strong>Optional columns:</strong> Location Name, Notes<br><br>
        <strong>Example row:</strong><br>
        <code style="font-size:0.7rem;">1/5/2026 | 7:40 | 1/5/2026 | 17:03 | 9.38 | UVH 15</code><br><br>
        Times should be in 24-hour format (7:00, 17:03) or Excel time values.
        Dates should be M/D/YYYY or YYYY-MM-DD.
        Multiple entries per date are grouped into one shift with multiple time entries.
      </div>
    </details>
    <div class="upload-area" id="importTimeUploadArea">
      <div style="font-size:2rem;">&#128197;</div>
      <p>Tap to upload QGenda .xlsx, .csv, or screenshot</p>
      <input type="file" id="importTimeFile" accept=".xlsx,.xls,.csv,.png,.jpg,.jpeg">
    </div>
    <div id="importTimePreview"></div>
    <div id="importTimeAction" class="hidden" style="margin-top:12px;">
      <button class="btn btn-primary" id="importShiftsBtn" style="width:100%;">Import Shifts</button>
    </div>
  </div>

  <!-- Import Cases -->
  <div class="card">
    <h2>Import Cases</h2>
    <p style="font-size:0.8rem;color:var(--text-dim);margin-bottom:12px;">
      Upload cases from Excel (.xlsx), CSV (Google Sheet export), PDF (Charge Detail), or screenshot.
      Duplicate cases (same date + start time) will be skipped.
    </p>
    <details style="font-size:0.75rem;color:var(--text-dim);margin-bottom:12px;">
      <summary style="cursor:pointer;color:var(--accent);font-weight:600;">Required CSV format</summary>
      <div style="margin-top:8px;padding:8px;background:var(--surface);border-radius:6px;line-height:1.6;">
        <strong>Columns (in order, comma-separated):</strong><br>
        Date, Surgeon, Startup (base units), Start, End, Time (min),
        Modifiers, Block, Shared?, Points Earned<br><br>
        <strong>Example row:</strong><br>
        <code style="font-size:0.7rem;">1/5,A Hill,6,8:02:00 AM,11:08:00 AM,186.00,,,,21.6</code><br><br>
        <strong>Date:</strong> M/D or M/D/YYYY (year inferred from current date if omitted)<br>
        <strong>Start/End:</strong> H:MM AM/PM or H:MM:SS AM/PM or 24-hour HH:MM<br>
        <strong>Modifiers:</strong> "E" for emergency, or numeric modifier point value<br>
        <strong>Block:</strong> Nerve block point value (2.6 = other, 3.0 = brachial plexus)<br>
        <strong>Shared?:</strong> "Y" if shared/split case<br>
        Header row is optional and will be auto-skipped.
        Shifts are auto-created for dates without an existing shift.
      </div>
    </details>
    <div class="upload-area" id="csvUploadArea">
      <div style="font-size:2rem;">&#128203;</div>
      <p>Tap to upload .xlsx, .csv, .pdf, or screenshot</p>
      <input type="file" id="csvFile" accept=".xlsx,.xls,.csv,.pdf,.png,.jpg,.jpeg">
    </div>
    <div id="csvImportResults"></div>
  </div>

  <!-- Scan Billing Sheet -->
  <div class="card collapse-section">
    <div class="collapse-header" onclick="toggleCollapse('importScan')">
      <h3>Scan Billing Sheet</h3>
      <span class="arrow" id="importScanArrow">&#9660;</span>
    </div>
    <div class="collapse-body" id="importScanBody">
      <div style="padding-top:12px;">
        <p style="font-size:0.8rem;color:var(--text-dim);margin-bottom:12px;">
          Scan a paper billing sheet using your camera or a photo. This opens the Work page scanner.
        </p>
        <button class="btn btn-primary" onclick="navigateToWorkScan()" style="width:100%;">Open Scanner on Work Page</button>
      </div>
    </div>
  </div>
</div>

<!-- FLAGGED PAGE -->
<div class="page" id="page-flagged">
  <div class="card">
    <h2>Flagged Cases &amp; Shifts</h2>
    <p style="font-size:0.8rem;color:var(--text-dim);margin-bottom:12px;">
      Items flagged for missing time punches or follow-up. Tap the flag icon to unflag.
    </p>
    <div id="flaggedCount" style="font-size:0.85rem;font-weight:600;margin-bottom:12px;"></div>
    <div id="flaggedList"></div>
    <div style="margin-top:12px;display:flex;gap:8px;">
      <button class="btn btn-primary btn-sm" id="copyFlaggedEmailBtn">Copy to Clipboard</button>
      <button class="btn btn-outline btn-sm" id="clearAllFlagsBtn">Clear All Flags</button>
    </div>
    <div id="flaggedCopyStatus" style="font-size:0.75rem;color:var(--text-dim);margin-top:8px;"></div>
  </div>
</div>

<!-- Day detail modal -->
<div class="modal-overlay hidden" id="dayModal">
  <div class="modal">
    <h2 id="dayModalTitle">Day Details</h2>
    <div id="dayModalContent"></div>
    <div class="modal-actions">
      <button class="btn btn-outline btn-sm" id="closeDayModal">Close</button>
    </div>
  </div>
</div>

<!-- Date picker modal -->
<div class="modal-overlay hidden" id="datePickerModal">
  <div class="modal">
    <h2>Select Working Date</h2>
    <div class="form-group">
      <input type="date" id="globalDatePicker">
    </div>
    <div class="modal-actions">
      <button class="btn btn-outline btn-sm" id="cancelDatePicker">Cancel</button>
      <button class="btn btn-sm" id="todayDatePicker" style="width:auto;background:var(--accent2);color:#fff;">Today</button>
      <button class="btn btn-primary btn-sm" id="applyDatePicker" style="width:auto;">Apply</button>
    </div>
  </div>
</div>

<!-- Case edit modal -->
<div class="modal-overlay hidden" id="caseEditModal">
  <div class="modal">
    <h2>Edit Case</h2>
    <div class="form-group">
      <label>Case Type</label>
      <select id="editCaseTypeSelect">
        <option value="standard" selected>Standard Case</option>
        <option value="labor_epidural">Labor Epidural</option>
        <option value="acute_pain_procedure">Acute Pain Procedure</option>
        <option value="epidural_blood_patch">Epidural Blood Patch</option>
        <option value="emergency_intubation">Emergency Intubation</option>
        <option value="01996">Epidural Rounding (01996)</option>
        <option value="99231">Pain Rounding (99231)</option>
        <option value="tee">TEE Exam</option>
        <option value="aps_rounding">APS Rounding</option>
      </select>
    </div>
    <div id="editStandardFields">
      <div class="form-group">
        <label>Procedure Name</label>
        <input type="text" id="editCaseProcedure" placeholder="e.g., Lap Chole">
      </div>
      <div class="form-row">
        <div class="form-group">
          <label>ASA Base Units</label>
          <input type="number" id="editCaseBaseUnits" min="0" step="1" placeholder="Units">
        </div>
        <div class="form-group">
          <label>Physical Status</label>
          <select id="editCasePhysicalStatus">
            <option value="P1">P1</option>
            <option value="P2" selected>P2</option>
            <option value="P3">P3</option>
            <option value="P4">P4</option>
            <option value="P5">P5</option>
          </select>
        </div>
      </div>
      <div class="form-row">
        <div class="form-group">
          <label>Anesthesia Start</label>
          <input type="text" inputmode="numeric" placeholder="HH:MM" maxlength="5" class="mil-time" id="editCaseStart">
        </div>
        <div class="form-group">
          <label>Anesthesia End</label>
          <input type="text" inputmode="numeric" placeholder="HH:MM" maxlength="5" class="mil-time" id="editCaseEnd">
        </div>
      </div>
      <div class="checkbox-group">
        <input type="checkbox" id="editCaseEmergency">
        <label for="editCaseEmergency">Emergency Case (+1 pt)</label>
      </div>
      <div class="checkbox-group">
        <input type="checkbox" id="editCaseAcutePain">
        <label for="editCaseAcutePain">Acute Pain Procedure</label>
      </div>
      <div class="form-group hidden" id="editAcutePainUnitsRow">
        <label>MWA Acute Pain Unit Value</label>
        <input type="number" id="editCaseAcutePainUnits" min="0" step="0.1" value="0">
      </div>
      <div class="checkbox-group">
        <input type="checkbox" id="editCaseHighRiskPeds">
        <label for="editCaseHighRiskPeds">High Risk Pediatrics (1.33x time)</label>
      </div>
      <div class="checkbox-group hidden" id="editORCaseRow">
        <input type="checkbox" id="editCaseORCase">
        <label for="editCaseORCase">OR Case (use OR rates, no OB doubling)</label>
      </div>

      <div class="checkbox-group">
        <input type="checkbox" id="editCaseShared">
        <label for="editCaseShared">Shared/Split Case</label>
      </div>
      <div class="form-group hidden" id="editSharedPctRow">
        <label>Startup Points Credit %</label>
        <input type="number" id="editCaseSharedPct" min="0" max="100" value="50" step="1">
      </div>

      <div class="divider"></div>
      <h3>Additional Procedures</h3>
      <div class="form-group">
        <label>Nerve Block</label>
        <select id="editNerveBlock">
          <option value="none">None</option>
          <option value="brachial_plexus">Brachial Plexus (3 pts)</option>
          <option value="other">Other (2.6 pts)</option>
        </select>
      </div>
      <div class="form-row">
        <div class="checkbox-group">
          <input type="checkbox" id="editCentralLine">
          <label for="editCentralLine">Central Line (0.8 pts)</label>
        </div>
        <div class="checkbox-group">
          <input type="checkbox" id="editArterialLine">
          <label for="editArterialLine">Arterial Line (0.6 pts)</label>
        </div>
      </div>
      <div class="form-row">
        <div class="checkbox-group">
          <input type="checkbox" id="editPAC">
          <label for="editPAC">PAC (2 pts)</label>
        </div>
        <div class="checkbox-group">
          <input type="checkbox" id="editTEEAddOn">
          <label for="editTEEAddOn">TEE (0.4 pts)</label>
        </div>
      </div>
      <div class="checkbox-group">
        <input type="checkbox" id="editITMorphine">
        <label for="editITMorphine">IT Morphine (3 pts)</label>
      </div>
    </div>
    <div id="editLaborEpiduralFields" class="hidden">
      <div class="form-row">
        <div class="form-group">
          <label>Epidural Start</label>
          <input type="text" inputmode="numeric" placeholder="HH:MM" maxlength="5" class="mil-time" id="editLaborStart">
        </div>
        <div class="form-group">
          <label>Epidural End</label>
          <input type="text" inputmode="numeric" placeholder="HH:MM" maxlength="5" class="mil-time" id="editLaborEnd">
        </div>
      </div>
    </div>
    <div id="editApsRoundingFields" class="hidden">
      <div class="form-row">
        <div class="form-group">
          <label>Epidural Rounds (3 pts each)</label>
          <input type="number" id="editApsEpiduralCount" min="0" step="1" value="0">
        </div>
        <div class="form-group">
          <label>Pain Rounds (2 pts each)</label>
          <input type="number" id="editApsPainCount" min="0" step="1" value="0">
        </div>
      </div>
    </div>
    <div id="editSimpleFields" class="hidden">
      <div class="form-group">
        <label>Procedure Notes (optional)</label>
        <input type="text" id="editSimpleNotes" placeholder="Optional notes">
      </div>
    </div>
    <div class="form-group notes-autocomplete">
      <label>Notes (optional)</label>
      <textarea id="editCaseNotes" placeholder="Surgeon, location, or other notes" autocomplete="off"></textarea>
      <div class="surgeon-suggestions hidden" id="editSurgeonSuggestions"></div>
    </div>
    <div class="modal-actions" style="justify-content:space-between;">
      <button class="btn btn-danger btn-sm" id="deleteCaseEdit">Delete</button>
      <div style="display:flex;gap:8px;">
        <button class="btn btn-outline btn-sm" id="cancelCaseEdit">Cancel</button>
        <button class="btn btn-primary btn-sm" id="saveCaseEdit" style="width:auto;">Save</button>
      </div>
    </div>
  </div>
</div>

<!-- Shift edit modal -->
<div class="modal-overlay hidden" id="shiftEditModal">
  <div class="modal">
    <h2 id="shiftEditTitle">Edit Shift</h2>
    <div class="form-group">
      <label>Assignment Type</label>
      <select id="editShiftType">
        <option value="OR">OR / General</option>
        <option value="OB_restricted">UVH OB</option>
        <option value="cardiac_liver">Cardiac / Liver</option>
        <option value="mole">Mole</option>
        <option value="1st_call">1st Call</option>
        <option value="2nd_call">2nd Call</option>
        <option value="3rd_call">3rd Call</option>
        <option value="4th_call">4th Call</option>
        <option value="endo">Endo</option>
        <option value="SF1">SF 1</option>
        <option value="SF2">SF 2</option>
        <option value="ACS">ACS</option>
        <option value="NORA">NORA</option>
        <option value="pre_call">Pre-Call</option>
        <option value="CRNA_supervision">CRNA Supervision</option>
        <option value="forced_off">Forced Off</option>
        <option value="vacation">Vacation / Off</option>
      </select>
    </div>
    <div class="form-group">
      <label><input type="checkbox" id="editShiftHoliday"> Holiday</label>
    </div>
    <div id="editShiftTimeEntries"></div>
    <button class="btn btn-outline btn-sm" id="editShiftAddEntry" style="margin-top:8px;">+ Add Time Entry</button>
    <div class="modal-actions">
      <button class="btn btn-danger btn-sm" id="deleteShiftBtn">Delete</button>
      <button class="btn btn-outline btn-sm" id="cancelShiftEdit">Cancel</button>
      <button class="btn btn-primary btn-sm" id="saveShiftEdit">Save</button>
    </div>
  </div>
</div>

<!-- Day Detail Modal -->
<div class="modal-overlay hidden" id="dayDetailModal">
  <div class="modal" style="max-width:420px;">
    <h2 id="dayDetailTitle">Day Summary</h2>
    <div id="dayDetailBody"></div>
    <div class="modal-actions">
      <button class="btn btn-outline btn-sm" id="closeDayDetail">Close</button>
    </div>
  </div>
</div>

<!-- Import confirmation modal -->
<div class="modal-overlay hidden" id="importConfirmModal">
  <div class="modal">
    <h2 id="importConfirmTitle">Confirm Import</h2>
    <div id="importConfirmBody"></div>
    <div class="modal-actions">
      <button class="btn btn-outline btn-sm" id="cancelImport">Cancel</button>
      <button class="btn btn-primary btn-sm" id="confirmImport" style="width:auto;">Import</button>
    </div>
  </div>
</div>

<!-- Toast -->
<div class="toast" id="toast"></div>

<!-- BOTTOM NAV -->
<div class="bottom-nav">
  <button data-page="dataentry">
    <span class="nav-icon">&#128137;</span>
    <span>Work</span>
  </button>
  <button data-page="compensation">
    <span class="nav-icon">&#129689;</span>
    <span>Comp</span>
  </button>
  <button class="active" data-page="today">
    <span class="nav-icon">&#11088;</span>
    <span>Today</span>
  </button>
  <button data-page="dashboard">
    <span class="nav-icon">&#128202;</span>
    <span>Dashboard</span>
  </button>
  <button id="moreNavBtn">
    <span class="nav-icon">&middot;&middot;&middot;</span>
    <span>More</span>
  </button>
</div>

<!-- MORE DRAWER -->
<div class="drawer-backdrop" id="drawerBackdrop"></div>
<div class="drawer-panel" id="drawerPanel">
  <div class="drawer-handle"></div>
  <div class="drawer-item" data-page="history">
    <span class="drawer-icon">&#128197;</span>
    <span>History</span>
  </div>
  <div class="drawer-item" data-page="import">
    <span class="drawer-icon">&#128229;</span>
    <span>Import</span>
  </div>
  <div class="drawer-item" data-page="flagged">
    <span class="drawer-icon">&#9873;</span>
    <span>Flagged</span>
  </div>
  <div class="drawer-item" data-page="settings">
    <span class="drawer-icon">&#9881;</span>
    <span>Settings</span>
  </div>
</div>

<script>
// ================================================================
// FIREBASE INIT
// ================================================================
firebase.initializeApp({
  apiKey: "AIzaSyC_6NTHRa4lHUpbsms3RgN-REfr3tN4Uho",
  authDomain: "mwa-point-tracker.firebaseapp.com",
  projectId: "mwa-point-tracker",
  storageBucket: "mwa-point-tracker.firebasestorage.app",
  messagingSenderId: "523311146529",
  appId: "1:523311146529:web:1b8a66fd270ab1b58ba560"
});

const auth = firebase.auth();
const db = firebase.firestore();
// Enable offline persistence so Firestore works offline
db.enablePersistence({ synchronizeTabs: true }).catch(() => {});

let currentUser = null;
let firestoreSyncEnabled = false;
let syncDebounceTimer = null;
let googleAccessToken = null;

// ================================================================
// DATA STORE
// ================================================================
const STORAGE_KEY = 'mwa_point_tracker';
const SETTINGS_KEY = 'mwa_settings';
const QGENDA_KEY = 'mwa_qgenda';
const PROD_KEY = 'mwa_production';
const RECON_DECISIONS_KEY = 'mwa_recon_decisions';
const SHIFT_RECON_DECISIONS_KEY = 'mwa_shift_recon_decisions';

function loadData() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (raw) {
      const d = JSON.parse(raw);
      if (!d.overrides) d.overrides = {};
      if (!d.stipends) d.stipends = {};
      if (!d.calendarAssignments) d.calendarAssignments = {};
      return d;
    }
  } catch(e) {}
  return { shifts: {}, cases: [], overrides: {}, stipends: {}, calendarAssignments: {} };
}

function saveData(d) {
  localStorage.setItem(STORAGE_KEY, JSON.stringify(d));
  syncToFirestore('data', d);
}

function loadSettings() {
  try {
    const raw = localStorage.getItem(SETTINGS_KEY);
    if (raw) return JSON.parse(raw);
  } catch(e) {}
  return { name: '', templates: [] };
}

function saveSettings(s) {
  localStorage.setItem(SETTINGS_KEY, JSON.stringify(s));
  syncToFirestore('settings', s);
}

function syncToFirestore(docName, payload) {
  if (!firestoreSyncEnabled || !currentUser) return;
  updateSyncStatus('syncing');
  clearTimeout(syncDebounceTimer);
  syncDebounceTimer = setTimeout(() => {
    const docRef = db.collection('users').doc(currentUser.uid).collection('data').doc(docName);
    docRef.set(JSON.parse(JSON.stringify(payload))).then(() => {
      updateSyncStatus('synced');
    }).catch(err => {
      console.error('Firestore sync error:', err);
      updateSyncStatus('error');
    });
  }, 500);
}

function updateSyncStatus(status) {
  const el = document.getElementById('syncStatus');
  if (!el) return;
  el.className = 'sync-indicator ' + status;
  if (status === 'syncing') el.textContent = 'Syncing...';
  else if (status === 'synced') el.textContent = 'Synced';
  else if (status === 'error') el.textContent = 'Sync error';
}

async function loadFromFirestore(uid) {
  try {
    const dataDoc = await db.collection('users').doc(uid).collection('data').doc('data').get();
    const settingsDoc = await db.collection('users').doc(uid).collection('data').doc('settings').get();

    if (dataDoc.exists) {
      const d = dataDoc.data();
      if (!d.overrides) d.overrides = {};
      if (!d.stipends) d.stipends = {};
      if (!d.calendarAssignments) d.calendarAssignments = {};
      // Ensure cases is an array
      if (!Array.isArray(d.cases)) d.cases = [];
      data = d;
      localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
      return 'loaded';
    } else {
      // No cloud data — check if there's local data to migrate
      const localData = loadData();
      const hasLocalData = localData.cases.length > 0 || Object.keys(localData.shifts).length > 0;
      if (hasLocalData) {
        // Upload local data to cloud
        await db.collection('users').doc(uid).collection('data').doc('data').set(JSON.parse(JSON.stringify(localData)));
        data = localData;
        return 'migrated';
      }
      return 'empty';
    }
  } catch(err) {
    console.error('Firestore load error:', err);
    return 'error';
  }
}

async function loadSettingsFromFirestore(uid) {
  try {
    const doc = await db.collection('users').doc(uid).collection('data').doc('settings').get();
    if (doc.exists) {
      const s = doc.data();
      settings = s;
      localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
    } else {
      // Migrate local settings
      const localSettings = loadSettings();
      if (localSettings.name || localSettings.pointValue) {
        await db.collection('users').doc(uid).collection('data').doc('settings').set(JSON.parse(JSON.stringify(localSettings)));
      }
      settings = localSettings;
    }
  } catch(err) {
    console.error('Settings load error:', err);
  }
}

let data = loadData();
let settings = loadSettings();

// Returns confirmed $/point for a month, or the global estimate
function getPointValueForMonth(monthKey) {
  if (settings.pointValues && settings.pointValues[monthKey] != null)
    return settings.pointValues[monthKey];
  return settings.pointValue || 0;
}

// Keep only last 6 months of confirmed point values
function prunePointValues() {
  if (!settings.pointValues) return;
  const now = new Date();
  const cutoff = new Date(now.getFullYear(), now.getMonth() - 6, 1);
  const cutoffKey = cutoff.getFullYear() + '-' + String(cutoff.getMonth()+1).padStart(2,'0');
  Object.keys(settings.pointValues).forEach(k => {
    if (k < cutoffKey) delete settings.pointValues[k];
  });
}

// Data migration (idempotent)
function migrateData(d) {
  let changed = false;
  // Migrate eModifier → isEmergency on cases
  d.cases.forEach(c => {
    if (c.eModifier) {
      c.isEmergency = true;
      delete c.eModifier;
      changed = true;
    }
  });
  // Migrate OB_unrestricted → OR on shifts
  Object.values(d.shifts).forEach(s => {
    if (s.assignmentType === 'OB_unrestricted') {
      s.assignmentType = 'OR';
      changed = true;
    }
    // Ensure supervision overlay fields
    if (s.supervisionStart === undefined) { s.supervisionStart = ''; changed = true; }
    if (s.supervisionEnd === undefined) { s.supervisionEnd = ''; changed = true; }
    if (s.preCallStart === undefined) { s.preCallStart = ''; changed = true; }
    if (s.preCallEnd === undefined) { s.preCallEnd = ''; changed = true; }
    if (s.tempCoverage === undefined) { s.tempCoverage = []; changed = true; }
  });
  // Ensure isORCase on all cases
  d.cases.forEach(c => {
    if (c.isORCase === undefined) { c.isORCase = false; changed = true; }
  });
  // Migrate shifts to timeEntries array
  Object.values(d.shifts).forEach(s => {
    if (!s.timeEntries) {
      s.timeEntries = [];
      if (s.startTime) {
        s.timeEntries.push({ start: s.startTime, end: s.endTime || '' });
      }
      changed = true;
    }
  });
  // Ensure flagged field on shifts
  Object.values(d.shifts).forEach(s => {
    if (s.flagged === undefined) { s.flagged = false; changed = true; }
  });
  // Ensure flagged field on cases
  d.cases.forEach(c => {
    if (c.flagged === undefined) { c.flagged = false; changed = true; }
  });
  // Ensure overrides object exists
  if (!d.overrides) { d.overrides = {}; changed = true; }
  if (!d.calendarAssignments) { d.calendarAssignments = {}; changed = true; }
  if (changed) saveData(d);
}
migrateData(data);

// ================================================================
// GOOGLE CALENDAR INTEGRATION
// ================================================================

function parseCalendarEventTitle(title) {
  if (!title || !title.trim()) return null;
  const t = title.trim();

  // Pure number → OR workbench
  if (/^\d+$/.test(t)) return { type: 'OR', label: 'WB: ' + t };

  // SF variants
  if (/^SF\s*1$/i.test(t)) return { type: 'SF1', label: 'SF 1' };
  if (/^SF\s*2$/i.test(t)) return { type: 'SF2', label: 'SF 2' };

  // Mole / Endo
  if (/^mole$/i.test(t)) return { type: 'mole', label: 'Mole' };
  if (/^endo[\s/]*mole$/i.test(t)) return { type: 'mole', label: 'Mole' };
  if (/^endo$/i.test(t)) return { type: 'mole', label: 'Mole' };

  // Call assignments
  if (/^1st\s*call$/i.test(t)) return { type: '1st_call', label: '1st Call' };
  if (/^2nd\s*call$/i.test(t)) return { type: '2nd_call', label: '2nd Call' };
  if (/^3rd\s*call$/i.test(t)) return { type: '3rd_call', label: '3rd Call' };
  if (/^4th\s*call$/i.test(t)) return { type: '4th_call', label: '4th Call' };

  // Trauma → ACS
  if (/^trauma$/i.test(t)) return { type: 'ACS', label: 'Trauma' };

  // OB
  if (/^OB$/i.test(t)) return { type: 'OB_restricted', label: 'OB' };

  // NORA
  if (/^NORA$/i.test(t)) return { type: 'NORA', label: 'NORA' };

  // Cardiac / Liver
  if (/^cardiac$/i.test(t)) return { type: 'cardiac_liver', label: 'Cardiac' };
  if (/^liver$/i.test(t)) return { type: 'cardiac_liver', label: 'Liver' };

  // Post shifts (Post Call, Post 1-4, Post SF 1/2, etc.) → OR with specific label
  if (/^post\b/i.test(t)) return { type: 'OR', label: t };

  // Known skip words
  if (/^(off|vacation|vac|holiday|sick|conference|away)$/i.test(t)) return null;

  // Fallback: unrecognized
  return null;
}

async function fetchCalendarList(token) {
  const resp = await fetch('https://www.googleapis.com/calendar/v3/users/me/calendarList', {
    headers: { 'Authorization': 'Bearer ' + token }
  });
  if (resp.status === 401) throw new Error('TOKEN_EXPIRED');
  if (!resp.ok) {
    const body = await resp.text();
    throw new Error('Calendar list ' + resp.status + ': ' + body.substring(0, 200));
  }
  return resp.json();
}

async function fetchCalendarEvents(token, calId, timeMin, timeMax) {
  const params = new URLSearchParams({
    timeMin: timeMin,
    timeMax: timeMax,
    singleEvents: 'true',
    maxResults: '500',
    orderBy: 'startTime'
  });
  const resp = await fetch('https://www.googleapis.com/calendar/v3/calendars/' + encodeURIComponent(calId) + '/events?' + params, {
    headers: { 'Authorization': 'Bearer ' + token }
  });
  if (resp.status === 401) throw new Error('TOKEN_EXPIRED');
  if (!resp.ok) {
    const body = await resp.text();
    throw new Error('Calendar events ' + resp.status + ': ' + body.substring(0, 200));
  }
  return resp.json();
}

const GOOGLE_CLIENT_ID = '523311146529-2g67858jcplc0hr71e54kdneeh9crv7t.apps.googleusercontent.com';

function requestCalendarToken(silent) {
  return new Promise((resolve, reject) => {
    if (typeof google === 'undefined' || !google.accounts) {
      reject(new Error('Google Identity Services not loaded — try refreshing'));
      return;
    }
    const client = google.accounts.oauth2.initTokenClient({
      client_id: GOOGLE_CLIENT_ID,
      scope: 'https://www.googleapis.com/auth/calendar.readonly',
      callback: (resp) => {
        if (resp.error) {
          reject(new Error(resp.error_description || resp.error));
        } else {
          googleAccessToken = resp.access_token;
          resolve(resp.access_token);
        }
      },
      error_callback: (err) => {
        reject(new Error(err.message || 'Token request failed'));
      }
    });
    // silent: reuse prior consent (no popup); manual: force consent prompt
    client.requestAccessToken({ prompt: silent ? '' : 'consent' });
  });
}

async function syncCalendarEvents(silent) {
  try {
    // Get token — silent mode reuses prior consent, manual forces prompt
    await requestCalendarToken(silent);

    // Find the "Riley" calendar
    const calList = await fetchCalendarList(googleAccessToken);
    const rileyCal = calList.items.find(c => c.summary && c.summary.toLowerCase().includes('riley'));
    if (!rileyCal) {
      if (!silent) showToast('No "Riley" calendar found');
      return;
    }

    // 90-day window: past 30 + future 60
    const now = new Date();
    const start = new Date(now);
    start.setDate(start.getDate() - 30);
    const end = new Date(now);
    end.setDate(end.getDate() + 60);
    const timeMin = start.toISOString();
    const timeMax = end.toISOString();

    const eventsData = await fetchCalendarEvents(googleAccessToken, rileyCal.id, timeMin, timeMax);
    const events = eventsData.items || [];

    // Clear stale entries within sync window, preserve outside
    const startStr = start.toISOString().substring(0, 10);
    const endStr = end.toISOString().substring(0, 10);
    Object.keys(data.calendarAssignments).forEach(k => {
      if (k >= startStr && k <= endStr) delete data.calendarAssignments[k];
    });

    let count = 0;
    events.forEach(ev => {
      const dateStr = ev.start && (ev.start.date || (ev.start.dateTime && ev.start.dateTime.substring(0, 10)));
      if (!dateStr) return;
      const parsed = parseCalendarEventTitle(ev.summary);
      if (!parsed) return;
      data.calendarAssignments[dateStr] = parsed;
      count++;
    });

    data.calendarLastSync = new Date().toISOString();
    saveData(data);

    // Update UI
    const syncTimeEl = document.getElementById('calendarLastSync');
    if (syncTimeEl) syncTimeEl.textContent = 'Last synced: ' + new Date(data.calendarLastSync).toLocaleString();

    if (!silent) showToast('Calendar synced: ' + count + ' assignment' + (count !== 1 ? 's' : ''));

    // Refresh views if on relevant pages
    if (typeof renderWeeklyChart === 'function') renderWeeklyChart();
    if (typeof loadShiftForDate === 'function') loadShiftForDate();
  } catch (err) {
    if (silent) {
      console.log('Auto calendar sync skipped:', err.message);
      return;
    }
    if (err.message === 'TOKEN_EXPIRED') {
      googleAccessToken = null;
      showToast('Calendar token expired — use Sync Calendar in Settings');
    } else {
      console.error('Calendar sync error:', err);
      showToast('Calendar: ' + (err.message || 'sync failed'));
    }
  }
}

// ================================================================
// CONSTANTS & HELPERS
// ================================================================
const UNRESTRICTED_CALL_TYPES = new Set(['mole','1st_call','2nd_call','3rd_call','4th_call','endo','SF1','SF2']);

// Returns true if the given minute is eligible for unrestricted call pay (3.5 pts/hr)
// minuteOfDay: 0-1439, isWeekendOrHoliday: boolean
function isUnrestrictedCallEligible(assignmentType, minuteOfDay, isWeekendOrHoliday) {
  switch (assignmentType) {
    case 'SF1':
    case 'SF2':
    case '1st_call':
    case '2nd_call':
    case '3rd_call':
      return isWeekendOrHoliday ? true : (minuteOfDay >= 1020); // after 17:00
    case '4th_call':
      return isWeekendOrHoliday; // weekend only shift
    case 'mole':
      return isWeekendOrHoliday ? true : (minuteOfDay >= 1140); // after 19:00
    case 'endo':
      return !isWeekendOrHoliday && (minuteOfDay >= 1020); // weekday after 17:00 only
    default:
      return false; // OR, OB, Cardiac/Liver, NORA, ACS, CRNA Supervision
  }
}

// Returns the pager pay eligible window {start, end} in minutes for a shift type.
// end can be >1440 for cross-midnight windows. Returns null if not eligible.
function getPagerPayWindow(assignmentType, isWkndOrHol) {
  switch (assignmentType) {
    case 'SF1': case 'SF2':
    case '1st_call': case '2nd_call': case '3rd_call':
    case '4th_call':
      // Weekday: 17:00–07:00 next day (14 hrs); Weekend/Holiday: 07:00–07:00 next day (24 hrs)
      return isWkndOrHol ? { start: 420, end: 1860 } : { start: 1020, end: 1860 };
    case 'mole':
      // Weekday: 17:00–07:00 next day (14 hrs); Weekend/Holiday: 07:00–07:00 next day (24 hrs)
      return isWkndOrHol ? { start: 420, end: 1860 } : { start: 1020, end: 1860 };
    case 'endo':
      // Weekday: 17:00–07:00 next day (14 hrs); Weekend/Holiday: same as mole (07:00–07:00)
      return isWkndOrHol ? { start: 420, end: 1860 } : { start: 1020, end: 1860 };
    default:
      return null;
  }
}

function getAssignmentTypeName(type) {
  const names = {
    OR: 'OR / General', OB_restricted: 'UVH OB', cardiac_liver: 'Cardiac / Liver',
    mole: 'Mole', '1st_call': '1st Call', '2nd_call': '2nd Call', '3rd_call': '3rd Call', '4th_call': '4th Call',
    endo: 'Endo', SF1: 'SF 1', SF2: 'SF 2', ACS: 'ACS', NORA: 'NORA',
    pre_call: 'Pre-Call',
    CRNA_supervision: 'CRNA Supervision',
    forced_off: 'UVH Forced Off',
    vacation: 'Vacation / Off'
  };
  return names[type] || type;
}

// ================================================================
// UTILITY
// ================================================================
function genId() {
  return Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
}

function showToast(msg) {
  const t = document.getElementById('toast');
  t.textContent = msg;
  t.classList.add('show');
  setTimeout(() => t.classList.remove('show'), 2000);
}

function formatDate(dateStr) {
  const d = new Date(dateStr + 'T12:00:00');
  return d.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });
}

function formatDateShort(dateStr) {
  const d = new Date(dateStr + 'T12:00:00');
  return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
}

function todayStr() {
  const d = new Date();
  return d.getFullYear() + '-' + String(d.getMonth()+1).padStart(2,'0') + '-' + String(d.getDate()).padStart(2,'0');
}

function timeToMinutes(timeStr) {
  if (!timeStr) return 0;
  const [h, m] = timeStr.split(':').map(Number);
  return h * 60 + m;
}

function isWeekend(dateStr) {
  const d = new Date(dateStr + 'T12:00:00');
  const day = d.getDay();
  return day === 0 || day === 6;
}

function round2(n) {
  return Math.round(n * 100) / 100;
}

function getWeekDates(refDateStr) {
  const d = new Date(refDateStr + 'T12:00:00');
  const dow = d.getDay();
  const monday = new Date(d);
  monday.setDate(d.getDate() - ((dow + 6) % 7));
  const dates = [];
  for (let i = 0; i < 7; i++) {
    const dt = new Date(monday);
    dt.setDate(monday.getDate() + i);
    dates.push(dt.getFullYear() + '-' + String(dt.getMonth()+1).padStart(2,'0') + '-' + String(dt.getDate()).padStart(2,'0'));
  }
  return dates;
}

// ================================================================
// MILITARY TIME INPUT HANDLING
// ================================================================
function formatMilTimeInput(val) {
  const digits = val.replace(/[^0-9]/g, '');
  if (digits.length === 0) return '';
  if (digits.length <= 2) {
    const h = parseInt(digits);
    if (h > 23) return '';
    return digits;
  }
  let h, m;
  if (digits.length === 3) {
    h = parseInt(digits.substring(0, 1));
    m = parseInt(digits.substring(1, 3));
    if (h > 2 || m > 59) return digits.substring(0, 2) + ':' + digits.substring(2);
    return '0' + digits.substring(0, 1) + ':' + digits.substring(1, 3);
  }
  h = parseInt(digits.substring(0, 2));
  m = parseInt(digits.substring(2, 4));
  if (h > 23) h = 23;
  if (m > 59) m = 59;
  return String(h).padStart(2, '0') + ':' + String(m).padStart(2, '0');
}

function isValidMilTime(val) {
  if (!val) return true; // empty is allowed
  return /^([01]\d|2[0-3]):[0-5]\d$/.test(val);
}

function bindMilTimeInput(input) {
  input.addEventListener('input', function() {
    const digits = this.value.replace(/[^0-9]/g, '');
    // When 4+ digits entered (e.g. "1900"), format immediately to "19:00"
    if (digits.length >= 4 && !this.value.includes(':')) {
      this.value = formatMilTimeInput(this.value);
      this.setSelectionRange(this.value.length, this.value.length);
      return;
    }
    // Auto-insert colon after 2 digits while typing
    if (digits.length >= 2 && !this.value.includes(':')) {
      const pos = this.selectionStart;
      this.value = digits.substring(0, 2) + ':' + digits.substring(2, 4);
      this.setSelectionRange(pos + 1, pos + 1);
    }
  });

  input.addEventListener('blur', function() {
    if (this.value) {
      this.value = formatMilTimeInput(this.value);
    }
    this.classList.toggle('invalid', this.value && !isValidMilTime(this.value));
  });

  // Format and blur on Enter
  input.addEventListener('keydown', function(e) {
    if (e.key === 'Enter') {
      e.preventDefault();
      if (this.value) this.value = formatMilTimeInput(this.value);
      this.classList.toggle('invalid', this.value && !isValidMilTime(this.value));
      this.blur();
    }
  });

  // Allow typing only digits and colon
  input.addEventListener('keypress', function(e) {
    if (e.key.length === 1 && !/[0-9:]/.test(e.key)) {
      e.preventDefault();
    }
  });
}

function initMilTimeInputs() {
  document.querySelectorAll('input.mil-time').forEach(input => bindMilTimeInput(input));
}

// ================================================================
// DYNAMIC TIME ENTRIES
// ================================================================
function createTimeEntryRow(start, end) {
  const row = document.createElement('div');
  row.className = 'time-entry-row';
  row.innerHTML = `
    <input type="text" inputmode="numeric" placeholder="HH:MM" maxlength="5" class="mil-time te-start" value="${start || ''}">
    <span class="te-label">to</span>
    <input type="text" inputmode="numeric" placeholder="HH:MM" maxlength="5" class="mil-time te-end" value="${end || ''}">
    <span class="te-next-day" style="display:none;color:var(--accent2);font-size:0.7rem;font-weight:600;">+1d</span>
    <button type="button" class="remove-entry-btn">&times;</button>
  `;
  row.querySelectorAll('input.mil-time').forEach(input => bindMilTimeInput(input));
  // Show +1d indicator when end time < start time (cross-midnight)
  const startInput = row.querySelector('.te-start');
  const endInput = row.querySelector('.te-end');
  const nextDayBadge = row.querySelector('.te-next-day');
  function updateCrossMidnight() {
    const s = timeToMinutes(startInput.value);
    const e = timeToMinutes(endInput.value);
    nextDayBadge.style.display = (!isNaN(s) && !isNaN(e) && e <= s && endInput.value) ? 'inline' : 'none';
  }
  startInput.addEventListener('input', updateCrossMidnight);
  endInput.addEventListener('input', updateCrossMidnight);
  updateCrossMidnight();
  row.querySelector('.remove-entry-btn').addEventListener('click', function() {
    row.remove();
    updateRemoveButtons();
  });
  return row;
}

function addTimeEntry() {
  const container = document.getElementById('timeEntriesContainer');
  const row = createTimeEntryRow('', '');
  container.appendChild(row);
  updateRemoveButtons();
  // Focus the new start input
  row.querySelector('.te-start').focus();
}

function updateRemoveButtons() {
  const rows = document.querySelectorAll('#timeEntriesContainer .time-entry-row');
  rows.forEach(row => {
    const btn = row.querySelector('.remove-entry-btn');
    btn.disabled = rows.length <= 1;
  });
}

function collectTimeEntries() {
  const rows = document.querySelectorAll('#timeEntriesContainer .time-entry-row');
  const entries = [];
  rows.forEach(row => {
    const start = row.querySelector('.te-start').value.trim();
    const end = row.querySelector('.te-end').value.trim();
    if (start || end) entries.push({ start, end });
  });
  return entries;
}

function populateTimeEntries(entries) {
  const container = document.getElementById('timeEntriesContainer');
  container.innerHTML = '';
  if (!entries || entries.length === 0) entries = [{ start: '07:00', end: '' }];
  entries.forEach(e => {
    container.appendChild(createTimeEntryRow(e.start, e.end));
  });
  updateRemoveButtons();
}

document.getElementById('addTimeEntryBtn').addEventListener('click', addTimeEntry);

// ================================================================
// POINT CALCULATION ENGINE (preserved from v1)
// ================================================================
function getARRate(assignmentType, isHol, isWknd, timeMinutes) {
  const isDaytime = timeMinutes >= 420 && timeMinutes < 1020;
  let baseRate;
  if (assignmentType === 'SF1') {
    // SF1: 13/hr during 0700-1700 on non-holiday weekdays only; General rate otherwise
    baseRate = (!isHol && !isWknd && isDaytime) ? 13 : 20;
  } else {
    const isOB = assignmentType === 'OB_restricted';
    baseRate = isOB ? 13 : 20;
  }
  if (isHol || isWknd) {
    if (isDaytime) return baseRate * 1.10;
    else return baseRate * 1.25;
  } else {
    if (isDaytime) return baseRate;
    else if (timeMinutes >= 1020 && timeMinutes < 1380) return baseRate * 1.10;
    else return baseRate * 1.25;
  }
}

function calcARPoints(shift) {
  if (shift.assignmentType === 'vacation') return 0;
  if (shift.forcedOff || shift.assignmentType === 'forced_off') return 56;
  const isHol = shift.isHoliday;
  const isWknd = isWeekend(shift.date);
  const isWkndOrHol = isHol || isWknd;
  const pagerWindow = getPagerPayWindow(shift.assignmentType, isWkndOrHol);

  // Temp coverage (covering): pager + AR scoped entirely to coverage interval
  if (shift.tempCoverage && shift.tempCoverage.length > 0 && shift.tempCoverage[0].type === 'covering') {
    const tc = shift.tempCoverage[0];
    if (!tc.start || !tc.end) return 0;
    let tcStart = timeToMinutes(tc.start);
    let tcEnd = timeToMinutes(tc.end);
    if (tcEnd <= tcStart) tcEnd += 1440;
    const pagerPts = ((tcEnd - tcStart) / 60) * 3.5;
    let arPts = 0;
    (tc.timeEntries || []).forEach(e => {
      if (!e.start || !e.end) return;
      let es = timeToMinutes(e.start);
      let ee = timeToMinutes(e.end);
      if (ee <= es) ee += 1440;
      for (let m = es; m < ee; m++) {
        arPts += getARRate(shift.assignmentType, isHol, isWknd, m % 1440) / 60;
      }
    });
    return round2(pagerPts + arPts);
  }

  const entries = shift.timeEntries || [];
  const hasEntries = entries.length > 0 && (entries.length > 1 || entries[0].start);
  const lastEntry = hasEntries ? entries[entries.length - 1] : null;
  const hasEnd = hasEntries && (entries.length > 1 || (lastEntry && lastEntry.end));

  // No time entries: return pager pay only if eligible
  if (!hasEntries || !hasEnd) {
    if (pagerWindow) {
      const pagerMinutes = pagerWindow.end - pagerWindow.start;
      return round2((pagerMinutes / 60) * 3.5);
    }
    return 0;
  }

  const isSF = ['SF1','SF2'].includes(shift.assignmentType);

  // Build OR-case time ranges for SF1/SF2
  let orRanges = [];
  if (isSF) {
    const shiftCases = data.cases.filter(c => c.shiftDate === shift.date && c.isORCase);
    shiftCases.forEach(c => {
      let cs = timeToMinutes(c.startTime);
      let ce = timeToMinutes(c.endTime);
      if (ce <= cs) ce += 1440;
      orRanges.push({ start: cs, end: ce });
    });
  }

  // Build clocked-in ranges from timeEntries
  const clockedRanges = [];
  entries.forEach(e => {
    if (!e.start) return;
    const s = timeToMinutes(e.start);
    let en = e.end ? timeToMinutes(e.end) : s; // no end = zero duration
    if (en <= s && e.end) en += 1440;
    clockedRanges.push({ start: s, end: en });
  });
  // Fix cross-midnight ordering: if an entry starts before the previous entry, it's the next day
  for (let i = 1; i < clockedRanges.length; i++) {
    if (clockedRanges[i].start < clockedRanges[i-1].start) {
      clockedRanges[i].start += 1440;
      clockedRanges[i].end += 1440;
    }
  }

  if (clockedRanges.length === 0) {
    if (pagerWindow) {
      const pagerMinutes = pagerWindow.end - pagerWindow.start;
      return round2((pagerMinutes / 60) * 3.5);
    }
    return 0;
  }

  // Full span: first entry start → last entry end
  const spanStart = clockedRanges[0].start;
  const spanEnd = clockedRanges[clockedRanges.length - 1].end;
  if (spanEnd <= spanStart) {
    if (pagerWindow) {
      const pagerMinutes = pagerWindow.end - pagerWindow.start;
      return round2((pagerMinutes / 60) * 3.5);
    }
    return 0;
  }

  // Build pre-call range (OR rates during pre-call period)
  let preCallRange = null;
  if (shift.preCallStart && shift.preCallEnd) {
    let pcs = timeToMinutes(shift.preCallStart);
    let pce = timeToMinutes(shift.preCallEnd);
    if (pce <= pcs) pce += 1440;
    preCallRange = { start: pcs, end: pce };
  }

  // Pre-call split: treat pre-call and evening as independent sub-shifts
  if (preCallRange) {
    // Split clocked ranges into pre-call and evening portions
    let preCallAR = 0;
    let eveningAR = 0;
    for (let m = spanStart; m < spanEnd; m++) {
      const normalizedMin = m % 1440;
      let clockedIn = false;
      for (const r of clockedRanges) {
        if (m >= r.start && m < r.end) { clockedIn = true; break; }
      }
      if (clockedIn) {
        if (m >= preCallRange.start && m < preCallRange.end) {
          preCallAR += getARRate('OR', isHol, isWknd, normalizedMin) / 60;
        } else {
          let rateType = shift.assignmentType;
          if (isSF) {
            for (const r of orRanges) {
              if (m >= r.start && m < r.end) { rateType = 'OR'; break; }
            }
          }
          eveningAR += getARRate(rateType, isHol, isWknd, normalizedMin) / 60;
        }
      }
    }
    // Pre-call minimum: weekday non-holiday → 4hr × OR rate (20) = 80 pts
    if (!isHol && !isWknd) {
      preCallAR = Math.max(preCallAR, 20 * 4);
    }
    // Evening minimum: based on evening assignment type (mole: no minimum)
    if (!isHol && !isWknd && shift.assignmentType !== 'mole') {
      const isOBRate = ['OB_restricted','SF1'].includes(shift.assignmentType);
      const eveningMin = isOBRate ? 13 * 4 : 20 * 4;
      eveningAR = Math.max(eveningAR, eveningMin);
    }
    let arPoints = preCallAR + eveningAR;

    // Pager pay: guaranteed full window duration
    let callPoints = 0;
    if (pagerWindow) {
      const pagerMinutes = pagerWindow.end - pagerWindow.start;
      callPoints = (pagerMinutes / 60) * 3.5;
    }
    const tcPts = calcTempCoveragePoints(shift);
    callPoints += tcPts.pagerAdj;
    arPoints += tcPts.ar;
    return round2(arPoints + callPoints);
  }

  // Non-pre-call: single-shift logic
  let arPoints = 0;

  for (let m = spanStart; m < spanEnd; m++) {
    const normalizedMin = m % 1440;

    // Is this minute within a clocked-in range?
    let clockedIn = false;
    for (const r of clockedRanges) {
      if (m >= r.start && m < r.end) { clockedIn = true; break; }
    }

    if (clockedIn) {
      // Normal AR rate — override to OR during SF OR-case windows
      let rateType = shift.assignmentType;
      if (isSF) {
        for (const r of orRanges) {
          if (m >= r.start && m < r.end) { rateType = 'OR'; break; }
        }
      }
      arPoints += getARRate(rateType, isHol, isWknd, normalizedMin) / 60;
    }
  }

  // Pager pay: guaranteed full window duration (does not stop when clocked in)
  let callPoints = 0;
  if (pagerWindow) {
    const pagerMinutes = pagerWindow.end - pagerWindow.start;
    callPoints = (pagerMinutes / 60) * 3.5;
  }

  // Temp coverage adjustment
  const tcPts = calcTempCoveragePoints(shift);
  callPoints += tcPts.pagerAdj;
  arPoints += tcPts.ar;

  // Guaranteed minimums for clocked-in time (weekday, non-mole)
  if (!isHol && !isWknd && shift.assignmentType !== 'mole') {
    const isOBRate = ['OB_restricted','SF1'].includes(shift.assignmentType);
    const minPoints = isOBRate ? 13 * 4 : 20 * 4;
    arPoints = Math.max(arPoints, minPoints);
  }

  return round2(arPoints + callPoints);
}

// Separate getter for breakdown display purposes
function calcARBreakdown(shift) {
  if (shift.assignmentType === 'vacation') return { ar: 0, call: 0 };
  if (shift.forcedOff || shift.assignmentType === 'forced_off') return { ar: 56, call: 0 };
  const isHol = shift.isHoliday;
  const isWknd = isWeekend(shift.date);
  const isWkndOrHol = isHol || isWknd;
  const pagerWindow = getPagerPayWindow(shift.assignmentType, isWkndOrHol);

  // Temp coverage (covering): pager + AR scoped entirely to coverage interval
  if (shift.tempCoverage && shift.tempCoverage.length > 0 && shift.tempCoverage[0].type === 'covering') {
    const tc = shift.tempCoverage[0];
    if (!tc.start || !tc.end) return { ar: 0, call: 0 };
    let tcStart = timeToMinutes(tc.start);
    let tcEnd = timeToMinutes(tc.end);
    if (tcEnd <= tcStart) tcEnd += 1440;
    const pagerPts = ((tcEnd - tcStart) / 60) * 3.5;
    let arPts = 0;
    (tc.timeEntries || []).forEach(e => {
      if (!e.start || !e.end) return;
      let es = timeToMinutes(e.start);
      let ee = timeToMinutes(e.end);
      if (ee <= es) ee += 1440;
      for (let m = es; m < ee; m++) {
        arPts += getARRate(shift.assignmentType, isHol, isWknd, m % 1440) / 60;
      }
    });
    return { ar: round2(arPts), call: round2(pagerPts) };
  }

  const entries = shift.timeEntries || [];
  const hasEntries = entries.length > 0 && (entries.length > 1 || entries[0].start);
  const lastEntry = hasEntries ? entries[entries.length - 1] : null;
  const hasEnd = hasEntries && (entries.length > 1 || (lastEntry && lastEntry.end));

  // No time entries: return pager pay only if eligible
  if (!hasEntries || !hasEnd) {
    if (pagerWindow) {
      const pagerMinutes = pagerWindow.end - pagerWindow.start;
      let callPts = (pagerMinutes / 60) * 3.5;
      const tcAdj = calcTempCoveragePoints(shift);
      callPts += tcAdj.pagerAdj;
      return { ar: round2(tcAdj.ar), call: round2(callPts) };
    }
    return { ar: 0, call: 0 };
  }

  const isSF = ['SF1','SF2'].includes(shift.assignmentType);

  let orRanges = [];
  if (isSF) {
    const shiftCases = data.cases.filter(c => c.shiftDate === shift.date && c.isORCase);
    shiftCases.forEach(c => {
      let cs = timeToMinutes(c.startTime);
      let ce = timeToMinutes(c.endTime);
      if (ce <= cs) ce += 1440;
      orRanges.push({ start: cs, end: ce });
    });
  }

  const clockedRanges = [];
  entries.forEach(e => {
    if (!e.start) return;
    const s = timeToMinutes(e.start);
    let en = e.end ? timeToMinutes(e.end) : s;
    if (en <= s && e.end) en += 1440;
    clockedRanges.push({ start: s, end: en });
  });
  // Fix cross-midnight ordering: if an entry starts before the previous entry, it's the next day
  for (let i = 1; i < clockedRanges.length; i++) {
    if (clockedRanges[i].start < clockedRanges[i-1].start) {
      clockedRanges[i].start += 1440;
      clockedRanges[i].end += 1440;
    }
  }

  if (clockedRanges.length === 0) {
    if (pagerWindow) {
      const pagerMinutes = pagerWindow.end - pagerWindow.start;
      let callPts = (pagerMinutes / 60) * 3.5;
      const tcAdj = calcTempCoveragePoints(shift);
      callPts += tcAdj.pagerAdj;
      return { ar: round2(tcAdj.ar), call: round2(callPts) };
    }
    return { ar: 0, call: 0 };
  }

  const spanStart = clockedRanges[0].start;
  const spanEnd = clockedRanges[clockedRanges.length - 1].end;
  if (spanEnd <= spanStart) {
    if (pagerWindow) {
      const pagerMinutes = pagerWindow.end - pagerWindow.start;
      let callPts = (pagerMinutes / 60) * 3.5;
      const tcAdj = calcTempCoveragePoints(shift);
      callPts += tcAdj.pagerAdj;
      return { ar: round2(tcAdj.ar), call: round2(callPts) };
    }
    return { ar: 0, call: 0 };
  }

  // Build pre-call range (OR rates during pre-call period)
  let preCallRange = null;
  if (shift.preCallStart && shift.preCallEnd) {
    let pcs = timeToMinutes(shift.preCallStart);
    let pce = timeToMinutes(shift.preCallEnd);
    if (pce <= pcs) pce += 1440;
    preCallRange = { start: pcs, end: pce };
  }

  // Pre-call split: treat pre-call and evening as independent sub-shifts
  if (preCallRange) {
    let preCallAR = 0;
    let eveningAR = 0;
    for (let m = spanStart; m < spanEnd; m++) {
      const normalizedMin = m % 1440;
      let clockedIn = false;
      for (const r of clockedRanges) {
        if (m >= r.start && m < r.end) { clockedIn = true; break; }
      }
      if (clockedIn) {
        if (m >= preCallRange.start && m < preCallRange.end) {
          preCallAR += getARRate('OR', isHol, isWknd, normalizedMin) / 60;
        } else {
          let rateType = shift.assignmentType;
          if (isSF) {
            for (const r of orRanges) {
              if (m >= r.start && m < r.end) { rateType = 'OR'; break; }
            }
          }
          eveningAR += getARRate(rateType, isHol, isWknd, normalizedMin) / 60;
        }
      }
    }
    // Pre-call minimum: weekday non-holiday → 4hr × OR rate (20) = 80 pts
    if (!isHol && !isWknd) {
      preCallAR = Math.max(preCallAR, 20 * 4);
    }
    // Evening minimum: based on evening assignment type (mole: no minimum)
    if (!isHol && !isWknd && shift.assignmentType !== 'mole') {
      const isOBRate = ['OB_restricted','SF1'].includes(shift.assignmentType);
      const eveningMin = isOBRate ? 13 * 4 : 20 * 4;
      eveningAR = Math.max(eveningAR, eveningMin);
    }
    let arPoints = preCallAR + eveningAR;

    let callPoints = 0;
    if (pagerWindow) {
      const pagerMinutes = pagerWindow.end - pagerWindow.start;
      callPoints = (pagerMinutes / 60) * 3.5;
    }
    const tcPtsBd = calcTempCoveragePoints(shift);
    callPoints += tcPtsBd.pagerAdj;
    arPoints += tcPtsBd.ar;
    return { ar: round2(arPoints), call: round2(callPoints), preCallAR: round2(preCallAR), eveningAR: round2(eveningAR) };
  }

  // Non-pre-call: single-shift logic
  let arPoints = 0;

  for (let m = spanStart; m < spanEnd; m++) {
    const normalizedMin = m % 1440;
    let clockedIn = false;
    for (const r of clockedRanges) {
      if (m >= r.start && m < r.end) { clockedIn = true; break; }
    }
    if (clockedIn) {
      let rateType = shift.assignmentType;
      if (isSF) {
        for (const r of orRanges) {
          if (m >= r.start && m < r.end) { rateType = 'OR'; break; }
        }
      }
      arPoints += getARRate(rateType, isHol, isWknd, normalizedMin) / 60;
    }
  }

  // Pager pay: guaranteed full window duration (does not stop when clocked in)
  let callPoints = 0;
  if (pagerWindow) {
    const pagerMinutes = pagerWindow.end - pagerWindow.start;
    callPoints = (pagerMinutes / 60) * 3.5;
  }

  // Temp coverage adjustment
  const tcPtsBd = calcTempCoveragePoints(shift);
  callPoints += tcPtsBd.pagerAdj;
  arPoints += tcPtsBd.ar;

  if (!isHol && !isWknd && shift.assignmentType !== 'mole') {
    const isOBRate = ['OB_restricted','SF1'].includes(shift.assignmentType);
    const minPoints = isOBRate ? 13 * 4 : 20 * 4;
    arPoints = Math.max(arPoints, minPoints);
  }

  return { ar: round2(arPoints), call: round2(callPoints) };
}

function getTimeMultiplier(physicalStatus, isHol, isWknd, caseStartMin, isHighRiskPeds) {
  const isWeekdayDay = !isHol && !isWknd && caseStartMin >= 420 && caseStartMin < 1020;
  const isWeekdayEve = !isHol && !isWknd && caseStartMin >= 1020 && caseStartMin < 1380;
  const isWeekendDay = (isHol || isWknd) && caseStartMin >= 420 && caseStartMin < 1020;
  let multiplier = 1.0;
  if (physicalStatus === 'P4') {
    if (isWeekdayDay) multiplier = 1.33;
  } else if (physicalStatus === 'P5') {
    if (isWeekdayDay) multiplier = 1.83;
    else if (isWeekdayEve || isWeekendDay) multiplier = 1.5;
  }
  if (isHighRiskPeds && isWeekdayDay && multiplier < 1.33) multiplier = 1.33;
  return multiplier;
}

function calcAddOnPoints(caseData) {
  let pts = 0;
  if (caseData.nerveBlock === 'brachial_plexus') pts += 3;
  else if (caseData.nerveBlock === 'other') pts += 2.6;
  else if (caseData.nerveBlock === 'it_morphine') pts += 3;
  if (caseData.hasCentralLine) pts += 0.8;
  if (caseData.hasArterialLine) pts += 0.6;
  if (caseData.hasPAC) pts += 2;
  if (caseData.hasTEEAddOn) pts += 0.4;
  if (caseData.hasITMorphine) pts += 3;
  return pts;
}

function calcCasePoints(caseData, shift) {
  const ct = caseData.caseType;
  if (ct === 'epidural_blood_patch') return 5;
  if (ct === 'emergency_intubation') return 4;
  if (ct === '01996') return 3;
  if (ct === '99231') return 2;
  if (ct === 'tee') return 22;

  if (ct === 'acute_pain_procedure') {
    return round2(calcAddOnPoints(caseData));
  }

  if (ct === 'aps_rounding') {
    const epi = (parseInt(caseData.epiduralRounds) || 0) * 3;
    const pain = (parseInt(caseData.painRounds) || 0) * 2;
    return round2(epi + pain);
  }

  if (ct === 'labor_epidural') {
    let cs = timeToMinutes(caseData.startTime);
    if (!cs && !caseData.startTime) return 0;
    let ce;
    if (caseData.endTime) {
      ce = timeToMinutes(caseData.endTime);
    } else {
      // No end time: estimate with current time if case is today
      const caseDate = caseData.shiftDate || (shift && shift.date);
      if (caseDate === todayStr()) {
        const now = new Date();
        ce = now.getHours() * 60 + now.getMinutes();
      } else {
        return 0; // past date with no end time — can't estimate
      }
    }
    if (ce <= cs) ce += 1440;
    const durationHrs = Math.min((ce - cs) / 60, 24);
    let pts = 0;
    if (cs === 420) { // 0700 start: flat hourly rate
      pts = durationHrs * 1.25;
    } else {
      if (durationHrs > 0) pts += Math.min(durationHrs, 1) * 7.5;
      if (durationHrs > 1) pts += Math.min(durationHrs - 1, 1) * 2.5;
      if (durationHrs > 2) pts += (durationHrs - 2) * 1.25;
    }
    return round2(pts * 2); // always OB doubled
  }

  const addOnPts = calcAddOnPoints(caseData);
  const baseUnits = parseFloat(caseData.baseUnits) || 0;
  let basePoints = 0.5 * baseUnits;
  if (caseData.isSharedCase) {
    basePoints *= (parseFloat(caseData.sharedStartupPct) || 50) / 100;
  }
  let caseStartMin = timeToMinutes(caseData.startTime);
  let caseHours = 0;
  if (caseData.endTime) {
    let caseEndMin = timeToMinutes(caseData.endTime);
    if (caseEndMin <= caseStartMin) caseEndMin += 1440;
    caseHours = (caseEndMin - caseStartMin) / 60;
  }
  const isHol = shift ? shift.isHoliday : false;
  const isWknd = shift ? isWeekend(shift.date) : false;
  const timeMultiplier = getTimeMultiplier(caseData.physicalStatus, isHol, isWknd, caseStartMin, caseData.isHighRiskPeds);
  const adjustedHours = caseHours * timeMultiplier;
  const timePoints = adjustedHours * 6;
  const medicalPoints = caseData.isMedicalProc ? 0.20 * (parseFloat(caseData.medicalUnits) || 0) : 0;
  const acutePainPoints = caseData.isAcutePain ? 0.375 * (parseFloat(caseData.acutePainUnits) || 0) : 0;
  const emergencyPoints = caseData.isEmergency ? 1 : 0;
  let total = basePoints + timePoints + medicalPoints + acutePainPoints + emergencyPoints + addOnPts;
  const isOBShift = shift && ['OB_restricted','SF1','SF2'].includes(shift.assignmentType);
  if (isOBShift && !caseData.isORCase) total *= 2;
  return round2(total);
}

function getCaseBreakdown(caseData, shift) {
  const ct = caseData.caseType;
  const bd = [];
  if (ct === 'epidural_blood_patch') { bd.push({label:'Epidural Blood Patch', pts:5}); return bd; }
  if (ct === 'emergency_intubation') { bd.push({label:'Emergency Intubation', pts:4}); return bd; }
  if (ct === '01996') { bd.push({label:'Epidural Rounding (01996)', pts:3}); return bd; }
  if (ct === '99231') { bd.push({label:'Pain Rounding (99231)', pts:2}); return bd; }
  if (ct === 'tee') { bd.push({label:'TEE Exam', pts:22}); return bd; }

  if (ct === 'aps_rounding') {
    const epiN = parseInt(caseData.epiduralRounds) || 0;
    const painN = parseInt(caseData.painRounds) || 0;
    if (epiN > 0) bd.push({label: `Epidural Rounds (${epiN} x 3)`, pts: round2(epiN * 3)});
    if (painN > 0) bd.push({label: `Pain Rounds (${painN} x 2)`, pts: round2(painN * 2)});
    return bd;
  }

  if (ct === 'labor_epidural') {
    let cs = timeToMinutes(caseData.startTime);
    if (!cs && !caseData.startTime) return bd;
    let ce;
    let isEst = false;
    if (caseData.endTime) {
      ce = timeToMinutes(caseData.endTime);
    } else {
      const caseDate = caseData.shiftDate || (shift && shift.date);
      if (caseDate === todayStr()) {
        const now = new Date();
        ce = now.getHours() * 60 + now.getMinutes();
        isEst = true;
      } else {
        return bd;
      }
    }
    if (ce <= cs) ce += 1440;
    const durationHrs = Math.min((ce - cs) / 60, 24);
    const estLabel = isEst ? ' (est.)' : '';
    let subtotal = 0;
    if (cs === 420) { // 0700 start: flat hourly rate
      const p = round2(durationHrs * 1.25);
      bd.push({label: `Hourly (${round2(durationHrs)}h x 1.25, 0700 start)${estLabel}`, pts: p});
      subtotal += p;
    } else {
      if (durationHrs > 0) {
        const p = round2(Math.min(durationHrs, 1) * 7.5);
        bd.push({label: `1st Hour (${round2(Math.min(durationHrs, 1))}h x 7.5)`, pts: p});
        subtotal += p;
      }
      if (durationHrs > 1) {
        const p = round2(Math.min(durationHrs - 1, 1) * 2.5);
        bd.push({label: `2nd Hour (${round2(Math.min(durationHrs - 1, 1))}h x 2.5)`, pts: p});
        subtotal += p;
      }
      if (durationHrs > 2) {
        const hrs = round2(durationHrs - 2);
        const p = round2(hrs * 1.25);
        bd.push({label: `Additional (${hrs}h x 1.25)${estLabel}`, pts: p});
        subtotal += p;
      }
    }
    bd.push({label: 'OB Doubled (x2)', pts: round2(subtotal)});
    return bd;
  }

  const baseUnits = parseFloat(caseData.baseUnits) || 0;
  let halfBase = 0.5 * baseUnits;
  if (caseData.isSharedCase) {
    const pct = parseFloat(caseData.sharedStartupPct) || 50;
    halfBase *= pct / 100;
    bd.push({label: `Base (shared ${pct}%) (${baseUnits} x 0.5 x ${pct}%)`, pts: round2(halfBase)});
  } else {
    bd.push({label: `Half Base Units (${baseUnits} x 0.5)`, pts: round2(halfBase)});
  }
  let caseStartMin = timeToMinutes(caseData.startTime);
  let caseHours = 0;
  if (caseData.endTime) {
    let caseEndMin = timeToMinutes(caseData.endTime);
    if (caseEndMin <= caseStartMin) caseEndMin += 1440;
    caseHours = round2((caseEndMin - caseStartMin) / 60);
  }
  const isHol = shift ? shift.isHoliday : false;
  const isWknd = shift ? isWeekend(shift.date) : false;
  const tm = getTimeMultiplier(caseData.physicalStatus, isHol, isWknd, caseStartMin, caseData.isHighRiskPeds);
  const adjustedHours = round2(caseHours * tm);
  const timePoints = round2(adjustedHours * 6);
  let tl = `Time (${caseHours}h x 6 pts/hr`;
  if (tm > 1) tl += ` x ${tm}`;
  tl += ')';
  if (caseHours > 0) bd.push({label: tl, pts: timePoints});
  if (caseData.isMedicalProc) {
    const mu = parseFloat(caseData.medicalUnits) || 0;
    bd.push({label: `Medical Proc (20% x ${mu})`, pts: round2(0.20 * mu)});
  }
  if (caseData.isAcutePain) {
    const au = parseFloat(caseData.acutePainUnits) || 0;
    bd.push({label: `Acute Pain (37.5% x ${au})`, pts: round2(0.375 * au)});
  }
  if (caseData.isEmergency) bd.push({label: 'Emergency', pts: 1});
  if (caseData.nerveBlock === 'brachial_plexus') bd.push({label: 'Nerve Block (Brachial Plexus)', pts: 3});
  else if (caseData.nerveBlock === 'other') bd.push({label: 'Nerve Block (Other)', pts: 2.6});
  if (caseData.hasCentralLine) bd.push({label: 'Central Line', pts: 0.8});
  if (caseData.hasArterialLine) bd.push({label: 'Arterial Line', pts: 0.6});
  if (caseData.hasPAC) bd.push({label: 'PAC', pts: 2});
  if (caseData.hasTEEAddOn) bd.push({label: 'TEE', pts: 0.4});
  if (caseData.hasITMorphine) bd.push({label: 'IT Morphine', pts: 3});
  const isOBShift = shift && ['OB_restricted','SF1','SF2'].includes(shift.assignmentType);
  if (isOBShift && !caseData.isORCase) {
    const subtotal = bd.reduce((s,r) => s + r.pts, 0);
    bd.push({label: 'OB Doubled (x2)', pts: round2(subtotal)});
  }
  return bd;
}

function calcSupervisionPoints(shift) {
  const isHol = shift.isHoliday;
  const isWknd = isWeekend(shift.date);
  // Standalone CRNA_supervision type: AR rate + 7 per hour, minute-by-minute
  if (shift.assignmentType === 'CRNA_supervision') {
    const entries = shift.timeEntries || [];
    let clockedRanges = [];
    entries.forEach(e => {
      if (!e.start || !e.end) return;
      let s = timeToMinutes(e.start);
      let en = timeToMinutes(e.end);
      if (en <= s) en += 1440;
      clockedRanges.push({ start: s, end: en });
    });
    if (clockedRanges.length === 0 && shift.startTime && shift.endTime) {
      let startMin = timeToMinutes(shift.startTime);
      let endMin = timeToMinutes(shift.endTime);
      if (endMin <= startMin) endMin += 1440;
      clockedRanges.push({ start: startMin, end: endMin });
    }
    let pts = 0;
    clockedRanges.forEach(r => {
      for (let m = r.start; m < r.end; m++) {
        pts += (getARRate('OR', isHol, isWknd, m % 1440) + 7) / 60;
      }
    });
    return round2(pts);
  }
  // Overlay on OR/SF1/SF2: +7/hr only (base AR already counted in calcARPoints)
  if (shift.supervisionStart && shift.supervisionEnd) {
    let startMin = timeToMinutes(shift.supervisionStart);
    let endMin = timeToMinutes(shift.supervisionEnd);
    if (endMin <= startMin) endMin += 1440;
    return round2((endMin - startMin) / 60 * 7);
  }
  return 0;
}

function calcCallPoints(shift) {
  // Unrestricted call is now automatically calculated inside calcARPoints via gap detection
  return 0;
}

function calcSubspecPoints(shift) {
  let pts = 0;
  if (shift.subspecCoverage) pts += 45;
  pts += (parseInt(shift.teeCount) || 0) * 22;
  return pts;
}

function calcTempCoveragePoints(shift) {
  if (!shift.tempCoverage || shift.tempCoverage.length === 0) return { pagerAdj: 0, ar: 0 };
  const isHol = shift.isHoliday;
  const isWknd = isWeekend(shift.date);
  let pagerAdj = 0;
  let ar = 0;
  shift.tempCoverage.forEach(tc => {
    if (!tc.start || !tc.end) return;
    let tcStart = timeToMinutes(tc.start);
    let tcEnd = timeToMinutes(tc.end);
    if (tcEnd <= tcStart) tcEnd += 1440;
    const tcMinutes = tcEnd - tcStart;
    if (tc.type === 'covered') {
      pagerAdj -= (tcMinutes / 60) * 3.5;
    } else if (tc.type === 'covering') {
      pagerAdj += (tcMinutes / 60) * 3.5;
      // AR for work time entries during coverage
      const tcEntries = tc.timeEntries || [];
      tcEntries.forEach(e => {
        if (!e.start || !e.end) return;
        let es = timeToMinutes(e.start);
        let ee = timeToMinutes(e.end);
        if (ee <= es) ee += 1440;
        for (let m = es; m < ee; m++) {
          ar += getARRate(shift.assignmentType, isHol, isWknd, m % 1440) / 60;
        }
      });
    }
  });
  return { pagerAdj: round2(pagerAdj), ar: round2(ar) };
}

function calcShiftTotal(shift) {
  const shiftCases = data.cases.filter(c => c.shiftDate === shift.date);
  const breakdown = calcARBreakdown(shift);
  const arPts = breakdown.ar;
  const callPts = breakdown.call;
  let prodPts = 0;
  shiftCases.forEach(c => { prodPts += calcCasePoints(c, shift); });
  const subspecPts = (shift.assignmentType === 'cardiac_liver') ? calcSubspecPoints(shift) : 0;
  const supervisionPts = calcSupervisionPoints(shift);
  return { ar: arPts, prod: round2(prodPts), call: callPts, subspec: subspecPts, supervision: supervisionPts, total: round2(arPts + prodPts + callPts + subspecPts + supervisionPts) };
}

function getShiftPointsForDate(dateStr, estimate) {
  const shift = data.shifts[dateStr];
  if (!shift) return { total: 0, isInProgress: false, ar: 0, prod: 0, call: 0, subspec: 0, supervision: 0 };
  const entries = shift.timeEntries || [];
  const lastEntry = entries.length > 0 ? entries[entries.length - 1] : null;
  const hasNoEnd = lastEntry && lastEntry.start && !lastEntry.end;
  const isInProgress = hasNoEnd && dateStr === todayStr();
  if (estimate && isInProgress) {
    const clone = JSON.parse(JSON.stringify(shift));
    const cloneEntries = clone.timeEntries || [];
    const now = new Date();
    const nowStr = String(now.getHours()).padStart(2,'0') + ':' + String(now.getMinutes()).padStart(2,'0');
    if (cloneEntries.length > 0) {
      cloneEntries[cloneEntries.length - 1].end = nowStr;
    }
    clone.timeEntries = cloneEntries;
    const totals = calcShiftTotal(clone);
    return { total: totals.total, isInProgress: true, ar: totals.ar, prod: totals.prod, call: totals.call, subspec: totals.subspec, supervision: totals.supervision };
  }
  const totals = calcShiftTotal(shift);
  return { total: totals.total, isInProgress: isInProgress, ar: totals.ar, prod: totals.prod, call: totals.call, subspec: totals.subspec, supervision: totals.supervision };
}

function getCaseTypeName(type) {
  const names = {
    standard: 'Standard Case', labor_epidural: 'Labor Epidural',
    acute_pain_procedure: 'Acute Pain Procedure',
    aps_rounding: 'APS Rounding', epidural_blood_patch: 'Epidural Blood Patch',
    emergency_intubation: 'Emergency Intubation', '01996': 'Epidural Rounding (01996)',
    '99231': 'Pain Rounding (99231)', tee: 'TEE Exam'
  };
  return names[type] || type;
}

// ================================================================
// WORKING DATE
// ================================================================
let workingDate = todayStr();
let deShiftEditing = false;
let returnToShiftLogs = false;

function setWorkingDate(d) {
  workingDate = d;
  document.getElementById('shiftDate').value = d;
  document.getElementById('headerDateBtn').textContent = formatDateShort(d);
  loadShiftForDate();
  updateHeaderPoints();
  updateEndTimeWarning();
  updateORCaseVisibility();
  deShiftEditing = false;
  updateDataEntryState();
  renderDECaseList();
  updateDETally();
  // Re-render Today page if it's currently visible
  if (document.getElementById('page-today').classList.contains('active')) {
    renderToday();
  }
}

// Header prev/next day navigation
document.getElementById('headerPrevDay').addEventListener('click', () => {
  const d = new Date(workingDate + 'T12:00:00');
  d.setDate(d.getDate() - 1);
  setWorkingDate(d.getFullYear() + '-' + String(d.getMonth()+1).padStart(2,'0') + '-' + String(d.getDate()).padStart(2,'0'));
});

document.getElementById('headerNextDay').addEventListener('click', () => {
  const d = new Date(workingDate + 'T12:00:00');
  d.setDate(d.getDate() + 1);
  setWorkingDate(d.getFullYear() + '-' + String(d.getMonth()+1).padStart(2,'0') + '-' + String(d.getDate()).padStart(2,'0'));
});

// Header date picker
document.getElementById('headerDateBtn').addEventListener('click', () => {
  document.getElementById('globalDatePicker').value = workingDate;
  document.getElementById('datePickerModal').classList.remove('hidden');
});

document.getElementById('cancelDatePicker').addEventListener('click', () => {
  document.getElementById('datePickerModal').classList.add('hidden');
});

document.getElementById('todayDatePicker').addEventListener('click', () => {
  setWorkingDate(todayStr());
  document.getElementById('datePickerModal').classList.add('hidden');
});

document.getElementById('applyDatePicker').addEventListener('click', () => {
  const v = document.getElementById('globalDatePicker').value;
  if (v) setWorkingDate(v);
  document.getElementById('datePickerModal').classList.add('hidden');
});

document.getElementById('datePickerModal').addEventListener('click', (e) => {
  if (e.target.id === 'datePickerModal') document.getElementById('datePickerModal').classList.add('hidden');
});

// ================================================================
// NAVIGATION (bottom nav)
// ================================================================
document.querySelectorAll('.bottom-nav button[data-page]').forEach(btn => {
  btn.addEventListener('click', () => {
    closeDrawer();
    exitHistoryTutorialMode();
    document.querySelectorAll('.bottom-nav button[data-page]').forEach(b => b.classList.remove('active'));
    document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
    btn.classList.add('active');
    document.getElementById('page-' + btn.dataset.page).classList.add('active');
    returnToShiftLogs = false;
    if (btn.dataset.page === 'dataentry') loadDataEntryPage();
    if (btn.dataset.page === 'today') { returnToDailyTab = false; renderToday(); }
    if (btn.dataset.page === 'dashboard') { switchDashboardTab(activeDashTab); }
    if (btn.dataset.page === 'compensation') renderProjections();
  });
});

// ================================================================
// MORE DRAWER
// ================================================================
function openDrawer() {
  const backdrop = document.getElementById('drawerBackdrop');
  const panel = document.getElementById('drawerPanel');
  backdrop.style.display = 'block';
  requestAnimationFrame(() => {
    backdrop.classList.add('visible');
    panel.classList.add('open');
  });
}

function closeDrawer() {
  const backdrop = document.getElementById('drawerBackdrop');
  const panel = document.getElementById('drawerPanel');
  backdrop.classList.remove('visible');
  panel.classList.remove('open');
  setTimeout(() => { backdrop.style.display = 'none'; }, 300);
}

function toggleDrawer() {
  const panel = document.getElementById('drawerPanel');
  if (panel.classList.contains('open')) closeDrawer();
  else openDrawer();
}

document.getElementById('moreNavBtn').addEventListener('click', toggleDrawer);
document.getElementById('drawerBackdrop').addEventListener('click', closeDrawer);

document.querySelectorAll('.drawer-item[data-page]').forEach(item => {
  item.addEventListener('click', () => {
    const page = item.dataset.page;
    closeDrawer();
    exitHistoryTutorialMode();
    document.querySelectorAll('.bottom-nav button[data-page]').forEach(b => b.classList.remove('active'));
    document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
    document.getElementById('page-' + page).classList.add('active');
    returnToShiftLogs = false;
    if (page === 'settings') { /* no special init needed */ }
    if (page === 'history') { renderHistory(); loadOverrideUI(); }
    if (page === 'import') { /* no special init needed */ }
    if (page === 'flagged') { renderFlaggedPage(); }
  });
});

// ================================================================
// SHIFT TEMPLATES
// ================================================================
const defaultTemplates = [
  { name: 'OR Day', type: 'OR', start: '07:10', end: '17:00' },
  { name: 'UVH OB Day', type: 'OB_restricted', start: '07:00', end: '19:00' },
  { name: 'UVH OB Night', type: 'OB_restricted', start: '19:00', end: '07:00' },
  { name: 'UVH OB Weekend', type: 'OB_restricted', start: '07:00', end: '07:00' },
  { name: 'NORA', type: 'NORA', start: '07:00', end: '14:00' },
  { name: 'ACS', type: 'ACS', start: '07:00', end: '17:00' },
];

function renderTemplates() {
  const grid = document.getElementById('templateGrid');
  const templates = defaultTemplates;
  grid.innerHTML = templates.map((t, i) => `
    <button class="template-btn" data-tidx="${i}">
      <span class="t-label">${t.name}</span>
      <span class="t-time">${t.start} - ${t.end}</span>
    </button>
  `).join('');

  grid.querySelectorAll('.template-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const t = templates[parseInt(btn.dataset.tidx)];
      document.getElementById('shiftAssignmentType').value = t.type;
      populateTimeEntries([{ start: t.start, end: t.end }]);
      document.getElementById('cardiacLiverOptions').classList.toggle('hidden', t.type !== 'cardiac_liver');
      updateSupervisionOverlayVisibility();
      showToast('Template applied');
    });
  });
}

// Template collapse toggle
document.getElementById('templateCollapseHeader').addEventListener('click', () => {
  const body = document.getElementById('templateCollapseBody');
  const arrow = document.getElementById('templateArrow');
  if (body.style.maxHeight && body.style.maxHeight !== '0px') {
    body.style.maxHeight = '0';
    arrow.classList.remove('open');
  } else {
    body.style.maxHeight = body.scrollHeight + 'px';
    arrow.classList.add('open');
  }
});

// Quick Procedures collapse toggle
document.getElementById('quickProcCollapseHeader').addEventListener('click', () => {
  const body = document.getElementById('quickProcCollapseBody');
  const arrow = document.getElementById('quickProcArrow');
  if (body.style.maxHeight && body.style.maxHeight !== '0px') {
    body.style.maxHeight = '0';
    arrow.classList.remove('open');
  } else {
    body.style.maxHeight = body.scrollHeight + 'px';
    arrow.classList.add('open');
  }
});

// Quick Procedure button clicks
const quickProcs = {
  colonoscopy: { name: 'Colonoscopy', units: 4 },
  egd: { name: 'EGD', units: 5 },
  double: { name: 'EGD + Colonoscopy', units: 5 },
  tonsils: { name: 'Tonsillectomy', units: 5 }
};

document.querySelectorAll('[data-qproc]').forEach(btn => {
  btn.addEventListener('click', () => {
    const proc = quickProcs[btn.dataset.qproc];
    if (!proc) return;
    selectedCaseType = 'standard';
    document.getElementById('caseTypeSelect').value = 'standard';
    applyCaseTypeVisibility('standard');
    document.getElementById('caseProcedure').value = proc.name;
    document.getElementById('caseBaseUnits').value = proc.units;
    updatePointPreview();
    showToast(proc.name + ' pre-filled');
  });
});

// ================================================================
// SHIFT PAGE
// ================================================================
const shiftDateInput = document.getElementById('shiftDate');

function updateUnrestrictedCallVisibility() {
  // Unrestricted call is now automatic based on shift type + gaps — no manual UI needed
}

function updateEndTimeWarning() {
  const shift = data.shifts[workingDate];
  const banner = document.getElementById('endTimeWarning');
  const hasNoEnd = shift && !shift.forcedOff && shift.assignmentType !== 'forced_off' && shift.timeEntries &&
    shift.timeEntries.length > 0 && !shift.timeEntries[shift.timeEntries.length - 1].end;
  if (hasNoEnd) {
    banner.classList.remove('hidden');
  } else {
    banner.classList.add('hidden');
  }
}

function updateORCaseVisibility() {
  const shift = data.shifts[workingDate];
  const isSF = shift && ['SF1','SF2'].includes(shift.assignmentType);
  document.getElementById('orCaseRow').classList.toggle('hidden', !isSF);
  if (!isSF) document.getElementById('caseORCase').checked = false;
}

function updateSupervisionOverlayVisibility() {
  const type = getSelectedAssignmentType();
  const eligible = ['OR','SF1','SF2'].includes(type);
  document.getElementById('supervisionOverlaySection').classList.toggle('hidden', !eligible);
  if (!eligible) {
    document.getElementById('supervisionOverlayCheck').checked = false;
    document.getElementById('supervisionTimes').classList.add('hidden');
  }
}

function updatePreCallOverlayVisibility() {
  const type = getSelectedAssignmentType();
  const eligible = ['mole','OB_restricted'].includes(type);
  document.getElementById('preCallOverlaySection').classList.toggle('hidden', !eligible);
  if (!eligible) {
    document.getElementById('preCallOverlayCheck').checked = false;
    document.getElementById('preCallTimes').classList.add('hidden');
  }
}

function updateTempCoverageVisibility() {
  const type = getSelectedAssignmentType();
  const isWkndOrHol = document.getElementById('shiftHoliday').checked || isWeekend(workingDate);
  const eligible = getPagerPayWindow(type, isWkndOrHol) !== null;
  document.getElementById('tempCoverageSection').classList.toggle('hidden', !eligible);
  if (!eligible) {
    document.getElementById('tempCoverageCheck').checked = false;
    document.getElementById('tempCoverageForm').classList.add('hidden');
    document.getElementById('tcTimeEntriesSection').classList.add('hidden');
    document.getElementById('tcTimeEntriesContainer').innerHTML = '';
  }
}

function addTCTimeEntryRow(startVal, endVal) {
  const container = document.getElementById('tcTimeEntriesContainer');
  const row = document.createElement('div');
  row.className = 'time-entry-row';
  row.innerHTML = `
    <input type="text" inputmode="numeric" placeholder="HH:MM" maxlength="5" class="mil-time tc-start" value="${startVal}">
    <span class="te-label">to</span>
    <input type="text" inputmode="numeric" placeholder="HH:MM" maxlength="5" class="mil-time tc-end" value="${endVal}">
    <button type="button" class="remove-entry-btn">&times;</button>
  `;
  row.querySelector('.remove-entry-btn').addEventListener('click', () => { row.remove(); });
  row.querySelectorAll('input.mil-time').forEach(input => bindMilTimeInput(input));
  container.appendChild(row);
}

function collectTCTimeEntries() {
  const rows = document.querySelectorAll('#tcTimeEntriesContainer .time-entry-row');
  const entries = [];
  rows.forEach(row => {
    const start = row.querySelector('.tc-start')?.value || '';
    const end = row.querySelector('.tc-end')?.value || '';
    if (start) entries.push({ start, end });
  });
  return entries;
}

function populateTCTimeEntries(entries) {
  const container = document.getElementById('tcTimeEntriesContainer');
  container.innerHTML = '';
  entries.forEach(e => addTCTimeEntryRow(e.start || '', e.end || ''));
}

function checkEndTimeNotification() {
  const now = new Date();
  if (now.getHours() < 7) return;
  const twoDaysAgo = new Date(now.getTime() - 48 * 60 * 60 * 1000);
  const missing = Object.values(data.shifts).filter(s => {
    if (s.forcedOff || s.assignmentType === 'forced_off') return false;
    // Check if last entry has an end time
    const entries = s.timeEntries || [];
    const lastEnd = entries.length > 0 ? entries[entries.length - 1].end : s.endTime;
    if (lastEnd) return false;
    const sd = new Date(s.date + 'T12:00:00');
    return sd >= twoDaysAgo && sd <= now;
  });
  if (missing.length === 0) return;
  if ('Notification' in window && Notification.permission === 'default') {
    Notification.requestPermission();
  }
  if ('Notification' in window && Notification.permission === 'granted') {
    const dates = missing.map(s => formatDateShort(s.date)).join(', ');
    new Notification('MWA Point Tracker', {
      body: `Missing end time for: ${dates}`,
      icon: 'icons/icon-192.png'
    });
  }
}

document.getElementById('shiftAssignmentType').addEventListener('change', function() {
  const type = this.value;
  document.getElementById('cardiacLiverOptions').classList.toggle('hidden', type !== 'cardiac_liver');
  document.getElementById('vacationRangeSection').classList.toggle('hidden', type !== 'vacation');
  document.getElementById('eveningAssignmentSection').classList.toggle('hidden', type !== 'pre_call');
  document.getElementById('timeEntriesLabel').textContent = type === 'pre_call' ? 'Pre-Call Times' : 'Time Entries';
  if (type !== 'pre_call') {
    document.getElementById('eveningAssignmentType').value = '';
    document.getElementById('eveningTimeSection').classList.add('hidden');
    document.getElementById('eveningTimeEntriesContainer').innerHTML = '';
  }
  if (type === 'forced_off') {
    populateTimeEntries([{ start: '07:00', end: '20:00' }]);
  }
  updateUnrestrictedCallVisibility();
  updateSupervisionOverlayVisibility();
  updatePreCallOverlayVisibility();
  updateTempCoverageVisibility();
  updateORCaseVisibility();
});

document.getElementById('supervisionOverlayCheck').addEventListener('change', function() {
  document.getElementById('supervisionTimes').classList.toggle('hidden', !this.checked);
});

document.getElementById('preCallOverlayCheck').addEventListener('change', function() {
  document.getElementById('preCallTimes').classList.toggle('hidden', !this.checked);
});

document.getElementById('eveningAssignmentType').addEventListener('change', function() {
  const hasEvening = !!this.value;
  document.getElementById('eveningTimeSection').classList.toggle('hidden', !hasEvening);
  if (!hasEvening) {
    document.getElementById('eveningTimeEntriesContainer').innerHTML = '';
  }
});

document.getElementById('addEveningTimeEntryBtn').addEventListener('click', () => {
  addEveningTimeEntryRow('', '');
});

document.getElementById('tempCoverageCheck').addEventListener('change', function() {
  document.getElementById('tempCoverageForm').classList.toggle('hidden', !this.checked);
  if (!this.checked) {
    document.getElementById('tcTimeEntriesSection').classList.add('hidden');
    document.getElementById('tcTimeEntriesContainer').innerHTML = '';
    // Restore regular time entries when coverage unchecked
    document.getElementById('timeEntriesGroup').classList.remove('hidden');
  } else {
    // Check if covering is selected and hide time entries
    const isCovering = document.querySelector('input[name="tcDirection"]:checked')?.value === 'covering';
    if (isCovering) {
      document.getElementById('timeEntriesGroup').classList.add('hidden');
    }
  }
});

document.querySelectorAll('input[name="tcDirection"]').forEach(r => {
  r.addEventListener('change', function() {
    const isCovering = this.value === 'covering';
    document.getElementById('tcTimeEntriesSection').classList.toggle('hidden', !isCovering);
    if (!isCovering) {
      document.getElementById('tcTimeEntriesContainer').innerHTML = '';
      document.getElementById('timeEntriesGroup').classList.remove('hidden');
    } else {
      // Hide regular time entries — coverage entries replace them
      document.getElementById('timeEntriesGroup').classList.add('hidden');
    }
  });
});

document.getElementById('addTCTimeEntryBtn').addEventListener('click', () => {
  addTCTimeEntryRow('', '');
});

function addEveningTimeEntryRow(startVal, endVal) {
  const container = document.getElementById('eveningTimeEntriesContainer');
  const row = document.createElement('div');
  row.className = 'time-entry-row';
  row.innerHTML = `
    <input type="text" inputmode="numeric" placeholder="HH:MM" maxlength="5" class="mil-time eve-start" value="${startVal}">
    <span class="te-label">to</span>
    <input type="text" inputmode="numeric" placeholder="HH:MM" maxlength="5" class="mil-time eve-end" value="${endVal}">
    <button type="button" class="remove-entry-btn">&times;</button>
  `;
  row.querySelector('.remove-entry-btn').addEventListener('click', () => { row.remove(); });
  row.querySelectorAll('input.mil-time').forEach(input => bindMilTimeInput(input));
  container.appendChild(row);
}

function collectEveningTimeEntries() {
  const rows = document.querySelectorAll('#eveningTimeEntriesContainer .time-entry-row');
  const entries = [];
  rows.forEach(row => {
    const start = row.querySelector('.eve-start')?.value || '';
    const end = row.querySelector('.eve-end')?.value || '';
    if (start) entries.push({ start, end });
  });
  return entries;
}

function populateEveningTimeEntries(entries) {
  const container = document.getElementById('eveningTimeEntriesContainer');
  container.innerHTML = '';
  entries.forEach(e => addEveningTimeEntryRow(e.start || '', e.end || ''));
}

shiftDateInput.addEventListener('change', function() {
  workingDate = this.value;
  document.getElementById('headerDateBtn').textContent = formatDateShort(workingDate);
  loadShiftForDate();
  deShiftEditing = false;
  updateDataEntryState();
  renderDECaseList();
  updateDETally();
});

function getSelectedAssignmentType() {
  return document.getElementById('shiftAssignmentType').value || 'OR';
}

function loadShiftForDate() {
  const date = workingDate;
  const shift = data.shifts[date];
  const banner = document.getElementById('editShiftBanner');
  if (shift) {
    banner.textContent = 'Editing shift for ' + formatDate(date);
    banner.classList.remove('hidden');
    // Backward compat: migrate old forcedOff flag to assignment type
    const effectiveType = shift.forcedOff ? 'forced_off' : shift.assignmentType;
    // If shift has pre-call overlay on mole/OB, show as pre_call with evening assignment
    const hasPreCallOverlay = (shift.preCallStart || shift.preCallEnd) && ['mole','OB_restricted'].includes(effectiveType);
    if (hasPreCallOverlay) {
      document.getElementById('shiftAssignmentType').value = 'pre_call';
      document.getElementById('timeEntriesLabel').textContent = 'Pre-Call Times';
      document.getElementById('eveningAssignmentSection').classList.remove('hidden');
      document.getElementById('eveningAssignmentType').value = effectiveType;
      document.getElementById('eveningTimeSection').classList.remove('hidden');
      // Split time entries: pre-call entries vs evening entries
      const pcEnd = timeToMinutes(shift.preCallEnd || '');
      const allEntries = shift.timeEntries || [];
      const preCallEntries = [];
      const eveningEntries = [];
      allEntries.forEach(e => {
        if (!e.start) return;
        const startMin = timeToMinutes(e.start);
        if (pcEnd > 0 && startMin < pcEnd) {
          preCallEntries.push(e);
        } else {
          eveningEntries.push(e);
        }
      });
      populateTimeEntries(preCallEntries.length > 0 ? preCallEntries : [{ start: shift.preCallStart || '07:00', end: shift.preCallEnd || '' }]);
      populateEveningTimeEntries(eveningEntries);
    } else {
      document.getElementById('shiftAssignmentType').value = effectiveType;
      const isPreCall = effectiveType === 'pre_call';
      document.getElementById('timeEntriesLabel').textContent = isPreCall ? 'Pre-Call Times' : 'Time Entries';
      document.getElementById('eveningAssignmentSection').classList.toggle('hidden', !isPreCall);
      if (!isPreCall) {
        document.getElementById('eveningAssignmentType').value = '';
        document.getElementById('eveningTimeSection').classList.add('hidden');
        document.getElementById('eveningTimeEntriesContainer').innerHTML = '';
      }
      populateTimeEntries(shift.timeEntries || [{ start: shift.startTime || '07:00', end: shift.endTime || '' }]);
    }
    document.getElementById('shiftHoliday').checked = shift.isHoliday || false;
    document.getElementById('cardiacLiverOptions').classList.toggle('hidden', shift.assignmentType !== 'cardiac_liver');
    document.getElementById('vacationRangeSection').classList.toggle('hidden', shift.assignmentType !== 'vacation');
    document.getElementById('vacationEndDate').value = '';
    document.getElementById('subspecCoverage').checked = shift.subspecCoverage || false;
    document.getElementById('teeCount').value = shift.teeCount || 0;
    if (shift.supervisionStart || shift.supervisionEnd) {
      document.getElementById('supervisionOverlayCheck').checked = true;
      document.getElementById('supervisionStart').value = shift.supervisionStart || '';
      document.getElementById('supervisionEnd').value = shift.supervisionEnd || '';
      document.getElementById('supervisionTimes').classList.remove('hidden');
    } else {
      document.getElementById('supervisionOverlayCheck').checked = false;
      document.getElementById('supervisionStart').value = '';
      document.getElementById('supervisionEnd').value = '';
      document.getElementById('supervisionTimes').classList.add('hidden');
    }
    if (shift.preCallStart || shift.preCallEnd) {
      document.getElementById('preCallOverlayCheck').checked = true;
      document.getElementById('preCallStartInput').value = shift.preCallStart || '';
      document.getElementById('preCallEndInput').value = shift.preCallEnd || '';
      document.getElementById('preCallTimes').classList.remove('hidden');
    } else {
      document.getElementById('preCallOverlayCheck').checked = false;
      document.getElementById('preCallStartInput').value = '';
      document.getElementById('preCallEndInput').value = '';
      document.getElementById('preCallTimes').classList.add('hidden');
    }
    // Temp coverage
    if (shift.tempCoverage && shift.tempCoverage.length > 0) {
      const tc = shift.tempCoverage[0];
      document.getElementById('tempCoverageCheck').checked = true;
      document.getElementById('tempCoverageForm').classList.remove('hidden');
      document.querySelector(`input[name="tcDirection"][value="${tc.type}"]`).checked = true;
      document.getElementById('tcStart').value = tc.start || '';
      document.getElementById('tcEnd').value = tc.end || '';
      if (tc.type === 'covering') {
        document.getElementById('tcTimeEntriesSection').classList.remove('hidden');
        populateTCTimeEntries(tc.timeEntries || []);
        // Hide regular time entries — coverage entries replace them
        document.getElementById('timeEntriesGroup').classList.add('hidden');
      } else {
        document.getElementById('tcTimeEntriesSection').classList.add('hidden');
        document.getElementById('tcTimeEntriesContainer').innerHTML = '';
        document.getElementById('timeEntriesGroup').classList.remove('hidden');
      }
    } else {
      document.getElementById('tempCoverageCheck').checked = false;
      document.getElementById('tempCoverageForm').classList.add('hidden');
      document.getElementById('tcStart').value = '';
      document.getElementById('tcEnd').value = '';
      document.getElementById('tcTimeEntriesSection').classList.add('hidden');
      document.getElementById('tcTimeEntriesContainer').innerHTML = '';
      document.getElementById('timeEntriesGroup').classList.remove('hidden');
    }
  } else {
    // Check for calendar assignment auto-fill
    const calAssignment = data.calendarAssignments[date];
    if (calAssignment) {
      banner.textContent = 'Calendar: ' + calAssignment.label;
      banner.style.borderColor = 'var(--accent2)';
      banner.style.background = 'rgba(52,211,153,0.12)';
      banner.style.color = 'var(--accent2)';
      banner.classList.remove('hidden');
      document.getElementById('shiftAssignmentType').value = calAssignment.type;
      document.getElementById('shiftAssignmentType').dispatchEvent(new Event('change'));
    } else {
      banner.classList.add('hidden');
      document.getElementById('shiftAssignmentType').value = 'OR';
    }
    populateTimeEntries([{ start: '07:00', end: '' }]);
    document.getElementById('shiftHoliday').checked = false;
    document.getElementById('cardiacLiverOptions').classList.add('hidden');
    document.getElementById('vacationRangeSection').classList.add('hidden');
    document.getElementById('vacationEndDate').value = '';
    document.getElementById('subspecCoverage').checked = false;
    document.getElementById('teeCount').value = 0;
    document.getElementById('supervisionOverlayCheck').checked = false;
    document.getElementById('supervisionStart').value = '';
    document.getElementById('supervisionEnd').value = '';
    document.getElementById('supervisionTimes').classList.add('hidden');
    document.getElementById('preCallOverlayCheck').checked = false;
    document.getElementById('preCallStartInput').value = '';
    document.getElementById('preCallEndInput').value = '';
    document.getElementById('eveningAssignmentSection').classList.add('hidden');
    document.getElementById('eveningAssignmentType').value = '';
    document.getElementById('eveningTimeSection').classList.add('hidden');
    document.getElementById('eveningTimeEntriesContainer').innerHTML = '';
    document.getElementById('preCallTimes').classList.add('hidden');
    document.getElementById('tempCoverageCheck').checked = false;
    document.getElementById('tempCoverageForm').classList.add('hidden');
    document.getElementById('tcStart').value = '';
    document.getElementById('tcEnd').value = '';
    document.getElementById('tcTimeEntriesSection').classList.add('hidden');
    document.getElementById('tcTimeEntriesContainer').innerHTML = '';
    document.getElementById('timeEntriesGroup').classList.remove('hidden');
  }
  updateUnrestrictedCallVisibility();
  updateSupervisionOverlayVisibility();
  updatePreCallOverlayVisibility();
  updateTempCoverageVisibility();
  updateEndTimeWarning();
}

// ================================================================
// DATA ENTRY PAGE FUNCTIONS
// ================================================================
function updateDEStickyHeaderSpacer() {
  requestAnimationFrame(() => {
    const h = document.getElementById('deStickyHeader').offsetHeight;
    document.getElementById('deStickyHeaderSpacer').style.height = h + 'px';
  });
}

function loadDataEntryPage() {
  loadShiftForDate();
  updateORCaseVisibility();
  updateDataEntryState();
  renderDECaseList();
  updateDETally();
  initScanPage();
  // Show/hide back button based on whether we came from Shift Logs
  document.getElementById('backToShiftLogsBtn').classList.toggle('hidden', !returnToShiftLogs);
}

function updateDataEntryState() {
  const shift = data.shifts[workingDate];
  const summaryBar = document.getElementById('deShiftSummaryBar');
  const shiftSection = document.getElementById('deShiftSection');
  const caseSection = document.getElementById('deCaseSection');
  const caseListCard = document.getElementById('deCaseListCard');

  if (shift && !deShiftEditing) {
    // Shift exists and not editing — show summary bar, hide shift form, show case section
    summaryBar.classList.remove('hidden');
    shiftSection.style.display = 'none';
    const isVacation = shift.assignmentType === 'vacation';
    const isForcedOff = shift.assignmentType === 'forced_off' || shift.forcedOff;
    const badge = document.getElementById('deSSBBadge');
    const hasPreCallOverlay = (shift.preCallStart || shift.preCallEnd) && ['mole','OB_restricted'].includes(shift.assignmentType);
    badge.textContent = hasPreCallOverlay
      ? 'Pre-Call + ' + getAssignmentTypeName(shift.assignmentType)
      : getAssignmentTypeName(isForcedOff ? 'forced_off' : shift.assignmentType);
    badge.classList.toggle('vacation', isVacation);
    const entries = shift.timeEntries || [{ start: shift.startTime, end: shift.endTime }];
    if (isVacation) {
      document.getElementById('deSSBTimes').textContent = 'Vacation Day';
    } else if (isForcedOff) {
      document.getElementById('deSSBTimes').textContent = '56 pts — Forced Off';
    } else if (entries.length === 1) {
      document.getElementById('deSSBTimes').textContent = (entries[0].start || '?') + ' - ' + (entries[0].end || '?');
    } else {
      document.getElementById('deSSBTimes').textContent = entries.length + ' time entries';
    }
    // Show case section only if not vacation/forced off
    if (isVacation || isForcedOff) {
      caseSection.classList.add('hidden');
    } else {
      caseSection.classList.remove('hidden');
    }
    caseListCard.classList.remove('hidden');
  } else {
    // No shift or editing — show shift form, hide summary bar and case section
    summaryBar.classList.add('hidden');
    shiftSection.style.display = '';
    caseSection.classList.add('hidden');
    caseListCard.classList.toggle('hidden', !shift);
  }
  // Show "Add Cases" button only when editing an existing shift (so user can switch back to case view)
  const switchToCaseBtn = document.getElementById('switchToCaseEntryBtn');
  const isVacOrForcedForBtn = shift && (shift.assignmentType === 'vacation' || shift.assignmentType === 'forced_off' || shift.forcedOff);
  switchToCaseBtn.classList.toggle('hidden', !(shift && deShiftEditing && !isVacOrForcedForBtn));
  // Show delete button only when editing an existing shift
  document.getElementById('deleteShiftDE').classList.toggle('hidden', !shift);
  updateDEStickyHeaderSpacer();
}

function renderDECaseList() {
  const listEl = document.getElementById('deCaseList');
  const countEl = document.getElementById('deCaseCount');
  const shift = data.shifts[workingDate];
  const shiftCases = data.cases.filter(c => c.shiftDate === workingDate);
  countEl.textContent = shiftCases.length > 0 ? `(${shiftCases.length})` : '';

  if (shiftCases.length === 0) {
    listEl.innerHTML = '<p style="color:var(--text-dim);font-size:0.85rem;">No cases logged yet.</p>';
    return;
  }

  let html = '';
  shiftCases.forEach(c => {
    const pts = shift ? calcCasePoints(c, shift) : 0;
    const name = c.caseType === 'standard' ? (c.procedure || 'Standard Case') : getCaseTypeName(c.caseType);
    const isOpenLabor = c.caseType === 'labor_epidural' && c.startTime && !c.endTime;
    const timeStr = c.startTime && c.endTime ? `${c.startTime} - ${c.endTime}` :
                    (isOpenLabor ? `${c.startTime} - now` : '');
    const estTag = isOpenLabor ? ' <span style="font-size:0.65rem;color:var(--accent2);">(est.)</span>' : '';
    html += `<div class="de-case-list-item" onclick="openCaseEdit('${c.id}')" style="cursor:pointer;">
      <div class="de-info">
        <div class="de-name">${escHtml(name)}${estTag}</div>
        ${timeStr ? `<div class="de-detail">${escHtml(timeStr)}</div>` : ''}
      </div>
      <div class="de-actions">
        <span class="de-pts">${pts.toFixed(1)}</span>
        <span onclick="event.stopPropagation();deleteCaseDE('${c.id}')" style="color:var(--danger);cursor:pointer;font-size:1rem;padding:4px;line-height:1;">&times;</span>
      </div>
    </div>`;
  });
  listEl.innerHTML = html;
}

function updateDETally() {
  const shift = data.shifts[workingDate];
  const tallyEl = document.getElementById('deTallyValue');
  if (!shift) {
    tallyEl.textContent = '0';
    return;
  }
  const totals = calcShiftTotal(shift);
  tallyEl.textContent = totals.total.toFixed(1);
}

function deleteCaseDE(id) {
  if (!confirm('Delete this case?')) return;
  data.cases = data.cases.filter(c => c.id !== id);
  saveData(data);
  updateHeaderPoints();
  renderDECaseList();
  updateDETally();
  renderToday();
  showToast('Case deleted');
}

// Summary bar click — re-expand shift form for editing
document.getElementById('deShiftSummaryBar').addEventListener('click', () => {
  deShiftEditing = true;
  loadShiftForDate();
  updateDataEntryState();
});

// "Edit Shift" button in case section — switch to shift entry view
document.getElementById('switchToShiftEntryBtn').addEventListener('click', () => {
  deShiftEditing = true;
  loadShiftForDate();
  updateDataEntryState();
});

// "Add Cases" button in shift section — switch back to case entry view (without saving)
document.getElementById('switchToCaseEntryBtn').addEventListener('click', () => {
  deShiftEditing = false;
  updateDataEntryState();
});

document.getElementById('deleteShiftDE').addEventListener('click', () => {
  const shift = data.shifts[workingDate];
  if (!shift) return;
  if (!confirm('Delete this shift? This cannot be undone.')) return;
  delete data.shifts[workingDate];
  saveData(data);
  deShiftEditing = false;
  updateHeaderPoints();
  loadShiftForDate();
  updateDataEntryState();
  renderDECaseList();
  updateDETally();
  renderShiftLogTable();
  renderToday();
  if (returnToShiftLogs) {
    navigateToShiftLogs();
  } else {
    showToast('Shift deleted');
  }
});

document.getElementById('saveShiftBtn').addEventListener('click', () => {
  const date = workingDate;
  if (!date) { showToast('Please select a date'); return; }
  let assignmentType = getSelectedAssignmentType();
  const supervisionEnabled = document.getElementById('supervisionOverlayCheck')?.checked || false;
  const preCallEnabled = document.getElementById('preCallOverlayCheck')?.checked || false;
  // Pre-Call with evening assignment: save as evening type with pre-call overlay
  const eveningAssignment = assignmentType === 'pre_call' ? (document.getElementById('eveningAssignmentType').value || '') : '';
  const isVacation = assignmentType === 'vacation';
  const isForcedOff = assignmentType === 'forced_off';
  const timeEntries = isVacation ? [{ start: '', end: '' }] : isForcedOff ? [{ start: '07:00', end: '20:00' }] : collectTimeEntries();
  const effectiveType = eveningAssignment || assignmentType;
  const hasPagerWindow = getPagerPayWindow(effectiveType, isWeekend(date) || document.getElementById('holidayCheck')?.checked) !== null;
  if (!isVacation && !isForcedOff && (timeEntries.length === 0 || !timeEntries[0].start) && !hasPagerWindow) {
    showToast('Please enter at least one start time');
    return;
  }
  // Validate: entries should be in chronological order, no overlaps (cross-midnight aware)
  if (!isVacation) {
    for (let i = 1; i < timeEntries.length; i++) {
      const prevEnd = timeToMinutes(timeEntries[i-1].end);
      let currStart = timeToMinutes(timeEntries[i].start);
      // If current start is before previous end, assume cross-midnight
      if (currStart < timeToMinutes(timeEntries[0].start)) currStart += 1440;
      let adjPrevEnd = prevEnd;
      if (adjPrevEnd < timeToMinutes(timeEntries[0].start)) adjPrevEnd += 1440;
      if (timeEntries[i-1].end && currStart <= adjPrevEnd) {
        showToast('Time entries must be in chronological order with no overlaps');
        return;
      }
    }
  }
  // Build list of dates to save (range for vacation, single otherwise)
  const datesToSave = [date];
  if (isVacation) {
    const vacEnd = document.getElementById('vacationEndDate').value;
    if (vacEnd && vacEnd > date) {
      const startD = new Date(date + 'T00:00:00');
      const endD = new Date(vacEnd + 'T00:00:00');
      datesToSave.length = 0;
      for (let d = new Date(startD); d <= endD; d.setDate(d.getDate() + 1)) {
        datesToSave.push(d.toISOString().split('T')[0]);
      }
    }
  }
  let skipped = 0;
  datesToSave.forEach(dt => {
    if (isVacation && datesToSave.length > 1 && data.shifts[dt] && data.shifts[dt].assignmentType !== 'vacation') {
      skipped++;
      return; // don't overwrite existing non-vacation shifts
    }
    // When pre_call with evening assignment, merge pre-call + evening time entries
    let savePreCallStart = preCallEnabled ? document.getElementById('preCallStartInput').value : '';
    let savePreCallEnd = preCallEnabled ? document.getElementById('preCallEndInput').value : '';
    let allTimeEntries = timeEntries;
    if (eveningAssignment && assignmentType === 'pre_call') {
      // Pre-call window from the main time entries
      const firstStart = timeEntries[0]?.start || '';
      const lastEnd = timeEntries[timeEntries.length - 1]?.end || '';
      savePreCallStart = firstStart;
      savePreCallEnd = lastEnd;
      // Merge evening time entries
      const eveningEntries = collectEveningTimeEntries();
      allTimeEntries = [...timeEntries, ...eveningEntries];
    }
    data.shifts[dt] = {
      date: dt, assignmentType: effectiveType,
      startTime: allTimeEntries[0]?.start || '',
      endTime: allTimeEntries[allTimeEntries.length - 1]?.end || '',
      timeEntries: allTimeEntries,
      isHoliday: document.getElementById('shiftHoliday').checked,
      forcedOff: false,
      subspecCoverage: document.getElementById('subspecCoverage').checked,
      teeCount: parseInt(document.getElementById('teeCount').value) || 0,
      supervisionStart: supervisionEnabled ? document.getElementById('supervisionStart').value : '',
      supervisionEnd: supervisionEnabled ? document.getElementById('supervisionEnd').value : '',
      preCallStart: savePreCallStart,
      preCallEnd: savePreCallEnd,
      tempCoverage: (() => {
        const tcCheck = document.getElementById('tempCoverageCheck');
        if (!tcCheck || !tcCheck.checked) return [];
        const dir = document.querySelector('input[name="tcDirection"]:checked')?.value || 'covered';
        const tcStartVal = document.getElementById('tcStart').value;
        const tcEndVal = document.getElementById('tcEnd').value;
        if (!tcStartVal || !tcEndVal) return [];
        const entry = { type: dir, start: tcStartVal, end: tcEndVal };
        if (dir === 'covering') entry.timeEntries = collectTCTimeEntries();
        else entry.timeEntries = [];
        return [entry];
      })()
    };
  });
  saveData(data);
  updateHeaderPoints();
  updateEndTimeWarning();
  updateORCaseVisibility();
  renderShiftLogTable();
  if (datesToSave.length > 1) {
    const msg = `${datesToSave.length - skipped} vacation day${datesToSave.length - skipped !== 1 ? 's' : ''} saved!` + (skipped ? ` (${skipped} existing shift${skipped !== 1 ? 's' : ''} skipped)` : '');
    showToast(msg);
  } else {
    showToast('Shift saved!');
  }
  deShiftEditing = false;
  if (returnToShiftLogs) {
    navigateToShiftLogs();
  } else {
    updateDataEntryState();
    renderDECaseList();
    updateDETally();
  }
});

// ================================================================
// CASE PAGE
// ================================================================
let selectedCaseType = 'standard';

document.getElementById('caseTypeSelect').addEventListener('change', function() {
  selectedCaseType = this.value;
  applyCaseTypeVisibility(selectedCaseType);
  updatePointPreview();
});

function applyCaseTypeVisibility(ct) {
  const isStd = ct === 'standard';
  const isLabor = ct === 'labor_epidural';
  const isAPS = ct === 'aps_rounding';
  const isAcutePain = ct === 'acute_pain_procedure';
  document.getElementById('standardFields').classList.toggle('hidden', !isStd);
  document.getElementById('laborEpiduralFields').classList.toggle('hidden', !isLabor);
  document.getElementById('apsRoundingFields').classList.toggle('hidden', !isAPS);
  document.getElementById('simpleFields').classList.toggle('hidden', isStd || isLabor || isAPS || isAcutePain);
}

document.getElementById('caseShared').addEventListener('change', function() {
  document.getElementById('sharedPctRow').classList.toggle('hidden', !this.checked);
  updatePointPreview();
});

// Procedure autocomplete
(function() {
  const procInput = document.getElementById('caseProcedure');
  const sugBox = document.getElementById('procSuggestions');
  const baseUnitsInput = document.getElementById('caseBaseUnits');
  let activeIdx = -1;
  let baseUnitsAutoFilled = false;

  function getProcHistory() {
    const map = {};
    data.cases.forEach(c => {
      if (c.caseType !== 'standard' || !c.procedure) return;
      const name = c.procedure.trim();
      if (!name) return;
      if (!map[name]) map[name] = { count: 0, lastUnits: '' };
      map[name].count++;
      if (c.baseUnits) map[name].lastUnits = c.baseUnits;
    });
    return map;
  }

  function showSuggestions() {
    const query = procInput.value.trim().toLowerCase();
    if (!query) { hideSuggestions(); return; }
    const history = getProcHistory();
    const matches = Object.entries(history)
      .filter(([name]) => name.toLowerCase().includes(query))
      .sort((a, b) => b[1].count - a[1].count)
      .slice(0, 8);
    if (matches.length === 0) { hideSuggestions(); return; }
    activeIdx = -1;
    sugBox.innerHTML = matches.map(([name, d], i) =>
      `<div class="proc-item" data-idx="${i}" data-name="${escHtml(name)}" data-units="${escHtml(d.lastUnits)}">${escHtml(name)}<span class="proc-units">${d.lastUnits ? d.lastUnits + 'u' : ''} (${d.count})</span></div>`
    ).join('');
    sugBox.classList.remove('hidden');
  }

  function hideSuggestions() { sugBox.classList.add('hidden'); sugBox.innerHTML = ''; activeIdx = -1; }

  function selectItem(el) {
    procInput.value = el.dataset.name;
    const units = el.dataset.units;
    if (units) { baseUnitsInput.value = units; baseUnitsAutoFilled = true; }
    hideSuggestions();
    updatePointPreview();
  }

  procInput.addEventListener('input', showSuggestions);
  procInput.addEventListener('focus', () => { if (procInput.value.trim()) showSuggestions(); });

  procInput.addEventListener('keydown', function(e) {
    const items = sugBox.querySelectorAll('.proc-item');
    if (items.length === 0) return;
    if (e.key === 'ArrowDown') {
      e.preventDefault();
      activeIdx = Math.min(activeIdx + 1, items.length - 1);
      items.forEach((el, i) => el.classList.toggle('active', i === activeIdx));
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      activeIdx = Math.max(activeIdx - 1, 0);
      items.forEach((el, i) => el.classList.toggle('active', i === activeIdx));
    } else if (e.key === 'Enter' && activeIdx >= 0) {
      e.preventDefault();
      selectItem(items[activeIdx]);
    } else if (e.key === 'Escape') {
      hideSuggestions();
    }
  });

  sugBox.addEventListener('click', function(e) {
    const item = e.target.closest('.proc-item');
    if (item) selectItem(item);
  });

  // Allow editing base units after auto-fill
  baseUnitsInput.addEventListener('focus', function() { baseUnitsAutoFilled = false; });

  document.addEventListener('click', function(e) {
    if (!e.target.closest('.proc-autocomplete')) hideSuggestions();
  });
})();

// Surgeon name autocomplete for Notes fields
(function() {
  function getSurgeonHistory() {
    const map = {};
    data.cases.forEach(c => {
      const name = (c.notes || '').trim();
      if (!name) return;
      if (!map[name]) map[name] = 0;
      map[name]++;
    });
    return map;
  }

  function initSurgeonAutocomplete(textareaId, sugBoxId) {
    const textarea = document.getElementById(textareaId);
    const sugBox = document.getElementById(sugBoxId);
    if (!textarea || !sugBox) return;
    let activeIdx = -1;

    function showSurgSuggestions() {
      const query = textarea.value.trim().toLowerCase();
      if (!query) { hideSurgSuggestions(); return; }
      const history = getSurgeonHistory();
      const matches = Object.entries(history)
        .filter(([name]) => name.toLowerCase().includes(query))
        .sort((a, b) => b[1] - a[1])
        .slice(0, 8);
      if (matches.length === 0) { hideSurgSuggestions(); return; }
      activeIdx = -1;
      sugBox.innerHTML = matches.map(([name, count], i) =>
        `<div class="surg-item" data-idx="${i}" data-name="${escHtml(name)}">${escHtml(name)}<span class="surg-count">(${count})</span></div>`
      ).join('');
      sugBox.classList.remove('hidden');
    }

    function hideSurgSuggestions() { sugBox.classList.add('hidden'); sugBox.innerHTML = ''; activeIdx = -1; }

    function selectSurgItem(el) {
      textarea.value = el.dataset.name;
      hideSurgSuggestions();
      textarea.focus();
    }

    textarea.addEventListener('input', showSurgSuggestions);
    textarea.addEventListener('focus', () => { if (textarea.value.trim()) showSurgSuggestions(); });

    textarea.addEventListener('keydown', function(e) {
      const items = sugBox.querySelectorAll('.surg-item');
      if (items.length === 0) return;
      if (e.key === 'ArrowDown') {
        e.preventDefault();
        activeIdx = Math.min(activeIdx + 1, items.length - 1);
        items.forEach((el, i) => el.classList.toggle('active', i === activeIdx));
        items[activeIdx].scrollIntoView({ block: 'nearest' });
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        activeIdx = Math.max(activeIdx - 1, 0);
        items.forEach((el, i) => el.classList.toggle('active', i === activeIdx));
        items[activeIdx].scrollIntoView({ block: 'nearest' });
      } else if (e.key === 'Enter' && activeIdx >= 0) {
        e.preventDefault();
        selectSurgItem(items[activeIdx]);
      } else if (e.key === 'Escape') {
        hideSurgSuggestions();
      }
    });

    sugBox.addEventListener('click', function(e) {
      const item = e.target.closest('.surg-item');
      if (item) selectSurgItem(item);
    });

    document.addEventListener('click', function(e) {
      if (!e.target.closest('.notes-autocomplete')) hideSurgSuggestions();
    });
  }

  initSurgeonAutocomplete('caseNotes', 'surgeonSuggestions');
  initSurgeonAutocomplete('editCaseNotes', 'editSurgeonSuggestions');
})();

['caseBaseUnits','caseStart','caseEnd','casePhysicalStatus','laborStart','laborEnd','caseNerveBlock','apsEpiduralCount','apsPainCount','caseSharedPct'].forEach(id => {
  const el = document.getElementById(id);
  if (el) { el.addEventListener('input', updatePointPreview); el.addEventListener('change', updatePointPreview); }
});

['caseEmergency','caseHighRiskPeds','caseORCase','caseCentralLine','caseArterialLine','casePAC','caseTEEAddOn','caseITMorphine','caseShared'].forEach(id => {
  const el = document.getElementById(id);
  if (el) el.addEventListener('change', updatePointPreview);
});

// Auto-check OR Case for SF1 — all cases on SF1 default to OR rates
document.getElementById('caseStart').addEventListener('change', function() {
  const shift = data.shifts[workingDate];
  if (!shift || shift.assignmentType !== 'SF1') return;
  const startMin = timeToMinutes(this.value);
  if (isNaN(startMin)) return;
  document.getElementById('caseORCase').checked = true;
  updatePointPreview();
});

function updateModifierTags() {
  const tags = [];
  if (document.getElementById('caseEmergency').checked) tags.push('Emergency');
  if (document.getElementById('caseHighRiskPeds').checked) tags.push('High Risk Peds');
  if (document.getElementById('caseORCase').checked) tags.push('OR Case');
  if (document.getElementById('caseShared').checked) tags.push('Shared');
  document.getElementById('modifierTags').innerHTML = tags.map(t => `<span class="mod-tag">${t}</span>`).join('');
}

function updatePointPreview() {
  updateModifierTags();
  const previewEl = document.getElementById('casePointPreview');
  const previewPts = document.getElementById('previewPoints');
  const tempCase = buildCaseFromForm();
  const shift = data.shifts[workingDate] || { date: workingDate, assignmentType: 'OR', isHoliday: false };
  const pts = calcCasePoints(tempCase, shift);
  previewEl.classList.remove('hidden');
  previewPts.textContent = pts.toFixed(2) + ' pts';
}

function buildCaseFromForm() {
  const isLabor = selectedCaseType === 'labor_epidural';
  const isAPS = selectedCaseType === 'aps_rounding';
  return {
    caseType: selectedCaseType,
    procedure: isLabor ? 'Labor Epidural' : (isAPS ? 'APS Rounding' : (document.getElementById('caseProcedure')?.value || selectedCaseType)),
    baseUnits: document.getElementById('caseBaseUnits')?.value || '',
    physicalStatus: document.getElementById('casePhysicalStatus')?.value || 'P2',
    startTime: isLabor ? (document.getElementById('laborStart')?.value || '') : (document.getElementById('caseStart')?.value || ''),
    endTime: isLabor ? (document.getElementById('laborEnd')?.value || '') : (document.getElementById('caseEnd')?.value || ''),
    isEmergency: document.getElementById('caseEmergency')?.checked || false,
    isMedicalProc: false,
    medicalUnits: 0,
    isAcutePain: false,
    acutePainUnits: 0,
    isHighRiskPeds: document.getElementById('caseHighRiskPeds')?.checked || false,
    isORCase: document.getElementById('caseORCase')?.checked || false,
    isSharedCase: document.getElementById('caseShared')?.checked || false,
    sharedStartupPct: document.getElementById('caseSharedPct')?.value || 50,
    nerveBlock: document.getElementById('caseNerveBlock')?.value || 'none',
    hasCentralLine: document.getElementById('caseCentralLine')?.checked || false,
    hasArterialLine: document.getElementById('caseArterialLine')?.checked || false,
    hasPAC: document.getElementById('casePAC')?.checked || false,
    hasTEEAddOn: document.getElementById('caseTEEAddOn')?.checked || false,
    hasITMorphine: document.getElementById('caseITMorphine')?.checked || false,
    epiduralRounds: document.getElementById('apsEpiduralCount')?.value || 0,
    painRounds: document.getElementById('apsPainCount')?.value || 0,
    notes: document.getElementById('caseNotes')?.value || ''
  };
}

document.getElementById('saveCaseBtn').addEventListener('click', () => {
  const date = workingDate;
  if (!date) { showToast('Set shift date first'); return; }
  if (!data.shifts[date]) { showToast('Please save a shift for this date first'); return; }
  if (data.shifts[date].assignmentType === 'vacation') { showToast('Vacation days do not have cases'); return; }
  const caseData = buildCaseFromForm();
  caseData.id = genId();
  caseData.shiftDate = date;
  caseData.timestamp = new Date().toISOString();
  if (caseData.caseType === 'labor_epidural') {
    if (!caseData.startTime) { showToast('Please enter a start time'); return; }
  }
  if (caseData.caseType === 'standard') {
    if (!caseData.startTime) { showToast('Please enter a start time'); return; }
  }
  if (caseData.caseType === 'aps_rounding') {
    if (!(parseInt(caseData.epiduralRounds) > 0) && !(parseInt(caseData.painRounds) > 0)) { showToast('Enter at least one round count'); return; }
  }
  data.cases.push(caseData);
  saveData(data);
  updateHeaderPoints();
  showToast('Case saved! (' + calcCasePoints(caseData, data.shifts[date]).toFixed(2) + ' pts)');
  resetCaseForm();
  renderDECaseList();
  updateDETally();
});

function resetCaseForm() {
  selectedCaseType = 'standard';
  document.getElementById('caseTypeSelect').value = 'standard';
  applyCaseTypeVisibility('standard');
  document.getElementById('caseProcedure').value = '';
  document.getElementById('caseBaseUnits').value = '';
  document.getElementById('casePhysicalStatus').value = 'P2';
  document.getElementById('caseStart').value = '';
  document.getElementById('caseEnd').value = '';
  document.getElementById('caseEmergency').checked = false;
  document.getElementById('caseHighRiskPeds').checked = false;
  document.getElementById('caseORCase').checked = true;
  document.getElementById('caseShared').checked = false;
  document.getElementById('caseSharedPct').value = '50';
  document.getElementById('sharedPctRow').classList.add('hidden');
  document.getElementById('caseNerveBlock').value = 'none';
  document.getElementById('caseCentralLine').checked = false;
  document.getElementById('caseArterialLine').checked = false;
  document.getElementById('casePAC').checked = false;
  document.getElementById('caseTEEAddOn').checked = false;
  document.getElementById('caseITMorphine').checked = false;
  document.getElementById('laborStart').value = '';
  document.getElementById('laborEnd').value = '';
  document.getElementById('apsEpiduralCount').value = '0';
  document.getElementById('apsPainCount').value = '0';
  document.getElementById('caseNotes').value = '';
  document.getElementById('simpleNotes').value = '';
  document.getElementById('casePointPreview').classList.add('hidden');
  document.getElementById('modifiersSection').removeAttribute('open');
  updateModifierTags();
}

// ================================================================
// TODAY PAGE
// ================================================================
function renderToday() {
  checkPVReminder();
  checkOpenLaborReminder();
  renderWeeklyChart();
  const date = workingDate;
  const shift = data.shifts[date];
  const shiftCases = data.cases.filter(c => c.shiftDate === date);
  document.getElementById('todayTitle').textContent = date === todayStr() ? "Today" : formatDate(date);

  // Back bar and edit shift button
  const backBar = document.getElementById('todayBackBar');
  const editShiftBtn = document.getElementById('todayEditShiftBtn');
  if (returnToDailyTab) {
    backBar.style.display = 'flex';
    backBar.classList.remove('hidden');
  } else {
    backBar.style.display = 'none';
  }
  if (shift) {
    editShiftBtn.classList.remove('hidden');
    editShiftBtn.onclick = () => openShiftEdit(date);
  } else {
    editShiftBtn.classList.add('hidden');
  }

  if (!shift) {
    document.getElementById('todayBreakdown').innerHTML = '<p style="color:var(--text-dim);font-size:0.85rem;">No shift saved for this date.</p>';
    document.getElementById('todayCaseList').innerHTML = '<div class="empty-state"><p>No cases logged yet.</p></div>';
    document.getElementById('todayCaseCount').textContent = '';
    return;
  }

  // Compact breakdown using getShiftPointsForDate
  const result = getShiftPointsForDate(date, true);
  const estTag = result.isInProgress ? ' <span style="font-size:0.7rem;color:var(--accent2);font-weight:500;">EST</span>' : '';
  const shiftHrs = calcShiftHours(shift);
  const monthKey = date.substring(0, 7);
  const pv = getPointValueForMonth(monthKey);
  const dollarTotal = round2(result.total * pv);
  const typeName = getAssignmentTypeName(shift.assignmentType);

  let bdHtml = '<div style="margin-top:6px;">';

  // Assignment type + dollar total row
  bdHtml += `<div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:6px;">`;
  bdHtml += `<span style="font-size:0.7rem;font-weight:600;color:var(--primary);background:rgba(66,133,244,0.12);padding:2px 8px;border-radius:10px;letter-spacing:0.3px;">${escHtml(typeName)}</span>`;
  if (shiftHrs > 0) {
    bdHtml += `<span style="font-size:0.72rem;color:var(--text-dim);">${shiftHrs.toFixed(1)} hrs</span>`;
  }
  bdHtml += `</div>`;

  // Big point total + dollar equivalent
  bdHtml += `<div style="display:flex;align-items:baseline;gap:8px;">`;
  bdHtml += `<span style="font-size:1.9rem;font-weight:700;line-height:1;">${result.total.toFixed(2)}</span>`;
  bdHtml += `<span style="font-size:0.85rem;color:var(--text-dim);">pts</span>`;
  bdHtml += estTag;
  bdHtml += `<span style="font-size:1.1rem;font-weight:600;color:var(--text-dim);margin-left:auto;">$${dollarTotal.toFixed(2)}</span>`;
  bdHtml += `</div>`;

  // Component breakdown chips
  const comps = [];
  if (result.ar > 0) comps.push({ label: 'AR', val: result.ar });
  if (result.prod > 0) comps.push({ label: 'Prod', val: result.prod });
  if (result.call > 0) comps.push({ label: 'Pager', val: result.call });
  if (result.subspec > 0) comps.push({ label: 'Sub', val: result.subspec });
  if (result.supervision > 0) comps.push({ label: 'Supv', val: result.supervision });
  if (comps.length > 0) {
    bdHtml += `<div style="display:flex;gap:6px;flex-wrap:wrap;margin-top:8px;">`;
    comps.forEach(c => {
      const chipColor = c.label === 'Pager' ? 'rgba(245,166,35,0.15)' : 'rgba(255,255,255,0.06)';
      const textColor = c.label === 'Pager' ? 'rgba(245,166,35,0.9)' : 'var(--text-dim)';
      bdHtml += `<span style="font-size:0.7rem;padding:2px 8px;border-radius:10px;background:${chipColor};color:${textColor};font-weight:500;">${c.label} ${c.val.toFixed(1)}</span>`;
    });
    bdHtml += `</div>`;
  }

  bdHtml += '<div id="todayRateChips"></div>';
  bdHtml += '</div>';
  document.getElementById('todayBreakdown').innerHTML = bdHtml;
  updateTodayRateChips();

  document.getElementById('todayCaseCount').textContent = `(${shiftCases.length})`;

  if (shiftCases.length === 0) {
    document.getElementById('todayCaseList').innerHTML = '<div class="empty-state"><p>No cases logged yet.</p></div>';
    return;
  }

  let listHtml = '';
  shiftCases.forEach(c => {
    const pts = calcCasePoints(c, shift);
    const name = c.caseType === 'standard' ? (c.procedure || 'Standard Case') : getCaseTypeName(c.caseType);
    const orTag = c.isORCase ? ' <span style="color:var(--accent2);font-size:0.75rem;">[OR]</span>' : '';
    const sharedTag = c.isSharedCase ? ` <span style="color:var(--purple);font-size:0.75rem;">[Shared ${c.sharedStartupPct || 50}%]</span>` : '';
    const isOpenLabor = c.caseType === 'labor_epidural' && c.startTime && !c.endTime;
    const timeStr = c.startTime && c.endTime ? `${c.startTime} - ${c.endTime}` :
                    (isOpenLabor ? `${c.startTime} - now` : '');
    const openLaborTag = isOpenLabor ? ' <span style="color:var(--accent2);font-size:0.75rem;">(est.)</span>' : '';
    const details = [];
    if (c.physicalStatus && c.caseType === 'standard') details.push(c.physicalStatus);
    if (c.baseUnits && c.caseType === 'standard') details.push(`${c.baseUnits} base`);
    if (timeStr) details.push(timeStr);
    if (c.caseType === 'aps_rounding') {
      const epi = parseInt(c.epiduralRounds) || 0;
      const pain = parseInt(c.painRounds) || 0;
      if (epi > 0) details.push(`${epi} epi`);
      if (pain > 0) details.push(`${pain} pain`);
    }
    listHtml += `
      <div class="case-list-item">
        <div class="info">
          <h4>${escHtml(name)}${orTag}${sharedTag}${openLaborTag}</h4>
          <p>${escHtml(details.join(' | '))}</p>
          ${c.notes ? `<p style="margin-top:2px;font-style:italic;">${escHtml(c.notes)}</p>` : ''}
        </div>
        <div class="actions">
          <span class="point-badge">${pts.toFixed(1)} pts</span>
          <button class="btn btn-outline btn-sm" onclick="openCaseEdit('${c.id}')" style="padding:2px 8px;font-size:0.68rem;">Edit</button>
          <button class="btn btn-danger btn-sm" onclick="deleteCase('${c.id}')">Del</button>
        </div>
      </div>`;
  });
  document.getElementById('todayCaseList').innerHTML = listHtml;
}

function updateTodayRateChips() {
  const el = document.getElementById('todayRateChips');
  if (!el) return;
  const date = workingDate;
  const shift = data.shifts[date];
  if (!shift || shift.assignmentType === 'vacation' || shift.assignmentType === 'forced_off' || shift.forcedOff) {
    el.innerHTML = '';
    return;
  }
  const result = getShiftPointsForDate(date, true);
  const shiftHrs = calcShiftHours(shift);
  const dt = new Date(date + 'T12:00:00');
  const dayOfWeek = dt.getDay();
  const isWknd = dayOfWeek === 0 || dayOfWeek === 6;
  const isHol = shift.isHoliday || false;
  const monthKey = date.substring(0, 7);
  const pv = getPointValueForMonth(monthKey);
  const now = new Date();
  const currentMin = now.getHours() * 60 + now.getMinutes();

  let html = '<div style="display:flex;gap:12px;flex-wrap:wrap;margin-top:8px;font-size:0.78rem;">';

  // Current rate chip (only for today)
  if (date === todayStr()) {
    const currentRate = getARRate(shift.assignmentType, isHol, isWknd, currentMin);
    const isWkndOrHol = isWknd || isHol;
    const pagerWin = getPagerPayWindow(shift.assignmentType, isWkndOrHol);
    let inPagerWindow = false;
    if (pagerWin) {
      const nowMin = currentMin < pagerWin.start && pagerWin.end > 1440 ? currentMin + 1440 : currentMin;
      inPagerWindow = nowMin >= pagerWin.start && nowMin < pagerWin.end;
    }
    const pagerRate = inPagerWindow ? 3.5 : 0;

    // In-progress production rate (open cases without end time)
    let prodRate = 0;
    const openCases = data.cases.filter(c => c.shiftDate === date && c.startTime && !c.endTime);
    openCases.forEach(c => {
      const cs = timeToMinutes(c.startTime);
      let elapsed = currentMin - cs;
      if (elapsed < 0) elapsed += 1440;
      const elapsedHrs = elapsed / 60;
      if (c.caseType === 'labor_epidural') {
        // Labor epidural tier rates (already OB doubled)
        if (cs === 420) {
          prodRate += 1.25 * 2;
        } else {
          if (elapsedHrs < 1) prodRate += 7.5 * 2;
          else if (elapsedHrs < 2) prodRate += 2.5 * 2;
          else prodRate += 1.25 * 2;
        }
      } else if (c.caseType === 'standard') {
        // Standard/OR: flat 6 pts/hr (multiplier is in AR, no OB doubling)
        prodRate += 6;
      }
    });

    const totalRate = currentRate + pagerRate + prodRate;
    const parts = [];
    parts.push('AR ' + currentRate.toFixed(0));
    if (pagerRate > 0) parts.push('Pager 3.5');
    if (prodRate > 0) parts.push('Prod ' + prodRate.toFixed(1));
    const hasExtras = pagerRate > 0 || prodRate > 0;

    html += `<div style="padding:4px 10px;background:rgba(66,133,244,0.12);border-radius:12px;color:rgba(66,133,244,1);font-weight:600;">`;
    if (hasExtras) {
      html += `Rate: ${totalRate.toFixed(1)} pts/hr`;
      html += ` <span style="font-weight:400;color:var(--text-dim);font-size:0.72rem;">(${parts.join(' + ')})</span>`;
    } else {
      html += `AR: ${currentRate.toFixed(0)} pts/hr`;
    }
    html += ` <span style="font-weight:400;color:var(--text-dim);font-size:0.72rem;">($${round2(totalRate * pv).toFixed(0)}/hr)</span>`;
    html += `</div>`;
  }

  // Daily pts/hr chip
  if (shiftHrs > 0) {
    const dailyPtsHr = result.total / shiftHrs;
    const dailyDollarsHr = round2(dailyPtsHr * pv);
    html += `<div style="padding:4px 10px;background:rgba(255,255,255,0.06);border-radius:12px;color:var(--text-dim);font-weight:600;">`;
    html += `Day: ${dailyPtsHr.toFixed(1)} pts/hr`;
    html += ` <span style="font-weight:400;font-size:0.72rem;">($${dailyDollarsHr.toFixed(0)}/hr)</span>`;
    html += `</div>`;
  }

  html += '</div>';
  el.innerHTML = html;
}

// Auto-update rate chips every 60 seconds
setInterval(() => {
  if (document.getElementById('page-today') && document.getElementById('page-today').classList.contains('active')) {
    updateTodayRateChips();
  }
}, 60000);

function renderWeeklyChart() {
  const weekDates = getWeekDates(workingDate);
  const today = todayStr();
  const labels = weekDates.map(d => {
    const dt = new Date(d + 'T12:00:00');
    return dt.toLocaleDateString('en-US', { weekday: 'short' });
  });

  const baseValues = [];
  const pagerValues = [];
  const totalValues = [];
  const rawPts = [];
  const hoursArr = [];
  const baseBgColors = [];
  const baseBorderColors = [];
  const pagerBgColors = [];
  const pagerBorderColors = [];
  const inProgressFlags = [];
  let weekTotal = 0;

  weekDates.forEach((d, i) => {
    const result = getShiftPointsForDate(d, true);
    const shift = data.shifts[d];
    const hrs = shift ? calcShiftHours(shift) : 0;
    rawPts.push(result.total);
    hoursArr.push(hrs);

    const baseRaw = result.ar + result.prod + result.subspec + result.supervision;
    const pagerRaw = result.call;
    let baseVal = baseRaw;
    let pagerVal = pagerRaw;
    if (weeklyShowDollars) {
      const monthKey = d.substring(0, 7);
      const pv = getPointValueForMonth(monthKey);
      baseVal = round2(baseRaw * pv);
      pagerVal = round2(pagerRaw * pv);
    }
    baseValues.push(baseVal);
    pagerValues.push(pagerVal);
    totalValues.push(round2(baseVal + pagerVal));
    weekTotal += baseVal + pagerVal;
    inProgressFlags.push(result.isInProgress);

    if (result.isInProgress) {
      baseBgColors.push('rgba(66,133,244,0.35)');
      baseBorderColors.push('rgba(66,133,244,0.6)');
      pagerBgColors.push('rgba(245,166,35,0.45)');
      pagerBorderColors.push('rgba(245,166,35,0.8)');
    } else if (d === today) {
      baseBgColors.push('rgba(66,133,244,0.85)');
      baseBorderColors.push('rgba(66,133,244,1)');
      pagerBgColors.push('rgba(245,166,35,0.85)');
      pagerBorderColors.push('rgba(245,166,35,1)');
    } else {
      baseBgColors.push('rgba(66,133,244,0.3)');
      baseBorderColors.push('rgba(66,133,244,0.6)');
      pagerBgColors.push('rgba(245,166,35,0.3)');
      pagerBorderColors.push('rgba(245,166,35,0.6)');
    }
  });

  // Build assignment labels for chart (calendar label preferred, shift type as fallback)
  const calendarLabels = weekDates.map(d => {
    const cal = data.calendarAssignments[d];
    if (cal) return cal.label;
    const shift = data.shifts[d];
    if (shift && shift.assignmentType) {
      const sel = document.getElementById('shiftAssignmentType');
      const opt = sel && sel.querySelector('option[value="' + shift.assignmentType + '"]');
      return opt ? opt.textContent : shift.assignmentType;
    }
    return '';
  });

  // Bar value labels plugin — draws total on top of stacked bar
  const barValueLabels = {
    id: 'barValueLabels',
    afterDatasetsDraw(chart) {
      const { ctx } = chart;
      ctx.save();
      ctx.font = '10px sans-serif';
      ctx.fillStyle = 'rgba(255,255,255,0.85)';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'bottom';
      const numBars = totalValues.length;
      for (let i = 0; i < numBars; i++) {
        const v = totalValues[i];
        if (v > 0) {
          // Find topmost visible segment
          let topY = Infinity;
          let barX = 0;
          for (let ds = chart.data.datasets.length - 1; ds >= 0; ds--) {
            const meta = chart.getDatasetMeta(ds);
            if (meta.data[i] && chart.data.datasets[ds].data[i] > 0) {
              topY = Math.min(topY, meta.data[i].y);
              barX = meta.data[i].x;
            }
          }
          if (topY < Infinity) {
            const label = (weeklyShowDollars ? '$' : '') + v.toFixed(1);
            ctx.fillText(label, barX, topY - 3);
          }
        }
      }
      ctx.restore();
    }
  };

  // Month boundary plugin
  const monthBoundaryPlugin = {
    id: 'weeklyMonthBoundary',
    afterDraw(chart) {
      const xAxis = chart.scales.x;
      const yAxis = chart.scales.y;
      for (let i = 1; i < weekDates.length; i++) {
        const prevMonth = weekDates[i-1].substring(5,7);
        const currMonth = weekDates[i].substring(5,7);
        if (prevMonth !== currMonth) {
          const x = (xAxis.getPixelForValue(i-1) + xAxis.getPixelForValue(i)) / 2;
          const ctx = chart.ctx;
          ctx.save();
          ctx.setLineDash([4,4]);
          ctx.strokeStyle = 'rgba(255,255,255,0.3)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x, yAxis.top);
          ctx.lineTo(x, yAxis.bottom);
          ctx.stroke();
          // Month labels
          const prevName = new Date(weekDates[i-1] + 'T12:00:00').toLocaleDateString('en-US', { month: 'short' });
          const currName = new Date(weekDates[i] + 'T12:00:00').toLocaleDateString('en-US', { month: 'short' });
          ctx.font = '10px sans-serif';
          ctx.fillStyle = 'rgba(255,255,255,0.45)';
          ctx.textAlign = 'right';
          ctx.fillText(prevName, x - 4, yAxis.top + 12);
          ctx.textAlign = 'left';
          ctx.fillText(currName, x + 4, yAxis.top + 12);
          ctx.restore();
        }
      }
    }
  };

  // Assignment label plugin
  const assignmentLabelPlugin = {
    id: 'assignmentLabels',
    afterDatasetsDraw(chart) {
      const { ctx } = chart;
      const meta = chart.getDatasetMeta(0);
      ctx.save();
      meta.data.forEach((bar, i) => {
        const lbl = calendarLabels[i];
        if (!lbl) return;
        const v = totalValues[i];
        const isToday = weekDates[i] === today;
        if (v > 0) {
          // Draw inside bar near bottom
          ctx.font = 'bold 9px sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'top';
          if (isToday) {
            ctx.fillStyle = 'rgba(30,58,138,0.9)';
          } else {
            ctx.fillStyle = 'rgba(255,255,255,0.4)';
          }
          const barBottom = chart.scales.y.getPixelForValue(0);
          ctx.fillText(lbl, bar.x, barBottom - 14);
        } else {
          // No bar — draw below x-axis
          ctx.font = '8px sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'top';
          ctx.fillStyle = 'rgba(255,255,255,0.3)';
          const axisBottom = chart.scales.x.bottom;
          ctx.fillText(lbl, bar.x, axisBottom + 4);
        }
      });
      ctx.restore();
    }
  };

  const canvas = document.getElementById('weeklyBarCanvas');
  if (weeklyBarChart) {
    weeklyBarChart.destroy();
    weeklyBarChart = null;
  }
  const ctx = canvas.getContext('2d');
  weeklyBarChart = new Chart(ctx, {
    type: 'bar',
    data: {
      labels: labels,
      datasets: [
        {
          label: 'Base',
          data: baseValues,
          backgroundColor: baseBgColors,
          borderColor: baseBorderColors,
          borderWidth: 1,
          borderRadius: function(ctx) {
            const i = ctx.dataIndex;
            const hasPager = pagerValues[i] > 0;
            // Base gets top rounding only if no pager segment above it
            return hasPager ? { bottomLeft: 3, bottomRight: 3, topLeft: 0, topRight: 0 }
                            : { bottomLeft: 3, bottomRight: 3, topLeft: 3, topRight: 3 };
          },
          borderSkipped: false,
          stack: 'stack0'
        },
        {
          label: 'Pager',
          data: pagerValues,
          backgroundColor: pagerBgColors,
          borderColor: pagerBorderColors,
          borderWidth: 1,
          borderRadius: function(ctx) {
            const i = ctx.dataIndex;
            const hasBase = baseValues[i] > 0;
            // Pager gets bottom rounding only if no base segment below it
            return hasBase ? { bottomLeft: 0, bottomRight: 0, topLeft: 3, topRight: 3 }
                           : { bottomLeft: 3, bottomRight: 3, topLeft: 3, topRight: 3 };
          },
          borderSkipped: false,
          stack: 'stack0'
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      layout: { padding: { top: 18, bottom: 16 } },
      plugins: {
        legend: { display: false },
        tooltip: {
          mode: 'index',
          filter: function(item) { return item.raw > 0; },
          callbacks: {
            title: function(items) {
              const i = items[0].dataIndex;
              return formatDate(weekDates[i]);
            },
            label: function(item) {
              const suffix = weeklyShowDollars ? '' : ' pts';
              const prefix = weeklyShowDollars ? '$' : '';
              return item.dataset.label + ': ' + prefix + item.raw.toFixed(2) + suffix;
            },
            afterBody: function(items) {
              const i = items[0].dataIndex;
              const suffix = weeklyShowDollars ? '' : ' pts';
              const prefix = weeklyShowDollars ? '$' : '';
              const est = inProgressFlags[i] ? ' (est.)' : '';
              const lines = ['Total: ' + prefix + totalValues[i].toFixed(2) + suffix + est];
              if (hoursArr[i] > 0) {
                if (weeklyShowDollars) {
                  const monthKey = weekDates[i].substring(0, 7);
                  const pv = getPointValueForMonth(monthKey);
                  const dph = (rawPts[i] * pv) / hoursArr[i];
                  lines.push('$' + dph.toFixed(2) + '/hr (' + hoursArr[i].toFixed(1) + ' hrs)');
                } else {
                  const pph = rawPts[i] / hoursArr[i];
                  lines.push(pph.toFixed(2) + ' pts/hr (' + hoursArr[i].toFixed(1) + ' hrs)');
                }
              }
              return lines;
            }
          }
        }
      },
      scales: {
        x: {
          stacked: true,
          grid: { display: false },
          ticks: { color: 'rgba(255,255,255,0.6)', font: { size: 11 } }
        },
        y: {
          stacked: true,
          beginAtZero: true,
          grid: { color: 'rgba(255,255,255,0.08)' },
          ticks: {
            color: 'rgba(255,255,255,0.5)',
            font: { size: 10 },
            callback: function(v) { return weeklyShowDollars ? '$' + v : v; }
          }
        }
      },
      onClick: function(evt, elements) {
        if (elements.length > 0) {
          const i = elements[0].index;
          setWorkingDate(weekDates[i]);
        }
      }
    },
    plugins: [monthBoundaryPlugin, barValueLabels, assignmentLabelPlugin]
  });

  // Compute month total
  const monthPrefix = workingDate.substring(0, 7);
  let monthTotal = 0;
  Object.keys(data.shifts).forEach(d => {
    if (d.substring(0, 7) === monthPrefix) {
      const r = getShiftPointsForDate(d, true);
      let v = r.total;
      if (weeklyShowDollars) {
        const pv = getPointValueForMonth(monthPrefix);
        v = round2(v * pv);
      }
      monthTotal += v;
    }
  });
  monthTotal = round2(monthTotal);

  const prefix = weeklyShowDollars ? '$' : '';
  const suffix = weeklyShowDollars ? '' : ' pts';
  const monthName = new Date(workingDate + 'T12:00:00').toLocaleDateString('en-US', { month: 'short' });
  document.getElementById('weeklySummary').textContent = 'Week: ' + prefix + weekTotal.toFixed(2) + suffix + '  \u00B7  ' + monthName + ': ' + prefix + monthTotal.toFixed(2) + suffix;
}

document.getElementById('weeklyToggleBtn').addEventListener('click', () => {
  weeklyShowDollars = !weeklyShowDollars;
  document.getElementById('weeklyToggleBtn').textContent = weeklyShowDollars ? 'pts' : '$';
  renderWeeklyChart();
});

// Add Cases button: navigate to Data Entry page
document.getElementById('todayAddCasesBtn').addEventListener('click', () => {
  document.querySelector('.bottom-nav button[data-page="dataentry"]').click();
});

// Back button: return to Dashboard Daily tab
document.getElementById('todayBackBtn').addEventListener('click', () => {
  returnToDailyTab = false;
  document.querySelectorAll('.bottom-nav button').forEach(b => b.classList.remove('active'));
  document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
  const dashBtn = document.querySelector('.bottom-nav button[data-page="dashboard"]');
  if (dashBtn) dashBtn.classList.add('active');
  document.getElementById('page-dashboard').classList.add('active');
  switchDashboardTab('daily');
});

function escHtml(s) {
  const div = document.createElement('div');
  div.textContent = s;
  return div.innerHTML;
}

function deleteCase(id) {
  if (!confirm('Delete this case?')) return;
  data.cases = data.cases.filter(c => c.id !== id);
  saveData(data);
  updateHeaderPoints();
  renderToday();
  renderCaseLogTable();
  renderDECaseList();
  updateDETally();
  showToast('Case deleted');
}

// ================================================================
// HISTORY (in More page)
// ================================================================
let historyYear = new Date().getFullYear();
let historyMonth = new Date().getMonth();

function renderHistory() {
  const monthNames = ['January','February','March','April','May','June','July','August','September','October','November','December'];
  document.getElementById('historyMonth').textContent = `${monthNames[historyMonth]} ${historyYear}`;
  const prefix = `${historyYear}-${String(historyMonth+1).padStart(2,'0')}`;
  const monthShifts = Object.values(data.shifts).filter(s => s.date.startsWith(prefix)).sort((a,b) => b.date.localeCompare(a.date));
  let monthTotalPts = 0;
  let listHtml = '';
  monthShifts.forEach(shift => {
    const totals = calcShiftTotal(shift);
    monthTotalPts += totals.total;
    const caseCount = data.cases.filter(c => c.shiftDate === shift.date).length;
    const entries = shift.timeEntries || [{ start: shift.startTime, end: shift.endTime }];
    const timeStr = entries.map(e => `${e.start}-${e.end || '?'}`).join(', ');
    listHtml += `
      <div class="day-list-item" onclick="showDayDetail('${shift.date}')">
        <div>
          <div class="date">${formatDate(shift.date)}</div>
          <div class="meta">${getAssignmentTypeName(shift.assignmentType)} | ${timeStr} | ${caseCount} cases</div>
        </div>
        <span class="point-badge large">${totals.total.toFixed(1)}</span>
      </div>`;
  });
  document.getElementById('monthTotal').textContent = monthTotalPts.toFixed(1);
  document.getElementById('monthDays').textContent = monthShifts.length;
  document.getElementById('historyList').innerHTML = monthShifts.length === 0
    ? '<div class="empty-state"><p>No shifts recorded for this month.</p></div>'
    : listHtml;
}

document.getElementById('prevMonth').addEventListener('click', () => {
  historyMonth--;
  if (historyMonth < 0) { historyMonth = 11; historyYear--; }
  renderHistory();
});

document.getElementById('nextMonth').addEventListener('click', () => {
  historyMonth++;
  if (historyMonth > 11) { historyMonth = 0; historyYear++; }
  renderHistory();
});

function showDayDetail(dateStr) {
  const shift = data.shifts[dateStr];
  if (!shift) return;
  const totals = calcShiftTotal(shift);
  const shiftCases = data.cases.filter(c => c.shiftDate === dateStr);
  document.getElementById('dayModalTitle').textContent = formatDate(dateStr);
  const detailEntries = shift.timeEntries || [{ start: shift.startTime, end: shift.endTime }];
  const detailTimeStr = detailEntries.map(e => `${e.start}-${e.end || '?'}`).join(', ');
  let html = `
    <p style="font-size:0.8rem;color:var(--text-dim);margin-bottom:8px;">${getAssignmentTypeName(shift.assignmentType)} | ${detailTimeStr}${detailEntries.length > 1 ? ' (' + detailEntries.length + ' entries)' : ''}</p>
    <div class="summary-grid" style="margin-bottom:12px;">
      <div class="summary-item"><div class="label">AR</div><div class="value blue">${totals.ar.toFixed(1)}</div></div>
      <div class="summary-item"><div class="label">Prod</div><div class="value green">${totals.prod.toFixed(1)}</div></div>
      <div class="summary-item"><div class="label">Call/Other</div><div class="value yellow">${(totals.call + totals.subspec + totals.supervision).toFixed(1)}</div></div>
      <div class="summary-item"><div class="label">Total</div><div class="value">${totals.total.toFixed(1)}</div></div>
    </div>
    <h3 style="margin-bottom:8px;">Cases (${shiftCases.length})</h3>`;
  shiftCases.forEach(c => {
    const pts = calcCasePoints(c, shift);
    const name = c.caseType === 'standard' ? (c.procedure || 'Standard Case') : getCaseTypeName(c.caseType);
    const breakdown = getCaseBreakdown(c, shift);
    html += `<div style="padding:8px 0;border-bottom:1px solid var(--surface2);">
      <div style="display:flex;justify-content:space-between;"><strong>${escHtml(name)}</strong><span class="point-badge">${pts.toFixed(1)}</span></div>`;
    breakdown.forEach(r => {
      html += `<div style="display:flex;justify-content:space-between;font-size:0.75rem;color:var(--text-dim);padding:2px 0;"><span>${escHtml(r.label)}</span><span>${r.pts.toFixed(2)}</span></div>`;
    });
    if (c.notes) html += `<div style="font-size:0.75rem;color:var(--text-dim);font-style:italic;margin-top:2px;">${escHtml(c.notes)}</div>`;
    html += '</div>';
  });
  document.getElementById('dayModalContent').innerHTML = html;
  document.getElementById('dayModal').classList.remove('hidden');
}

document.getElementById('closeDayModal').addEventListener('click', () => { document.getElementById('dayModal').classList.add('hidden'); });
document.getElementById('dayModal').addEventListener('click', (e) => {
  if (e.target.id === 'dayModal') document.getElementById('dayModal').classList.add('hidden');
});

// ================================================================
// DASHBOARD — Tabs & Rendering
// ================================================================
let weeklyBarChart = null;
let weeklyShowDollars = false;
let monthlyChart = null;
let monthlyShowDollars = false;
let breakdownChart = null; // unused, kept for compat
let pipelineChart = null;
let productionTrendChart = null;
let activeDashTab = 'daily';

// Dashboard sub-tab switching
document.querySelectorAll('.dash-tab-btn').forEach(btn => {
  btn.addEventListener('click', () => switchDashboardTab(btn.dataset.dtab));
});

function switchDashboardTab(tabName) {
  if (tabName === 'projections') tabName = 'daily';
  activeDashTab = tabName;
  document.querySelectorAll('.dash-tab-btn').forEach(b => b.classList.toggle('active', b.dataset.dtab === tabName));
  document.getElementById('dtab-caselogs').classList.toggle('hidden', tabName !== 'caselogs');
  document.getElementById('dtab-shiftlogs').classList.toggle('hidden', tabName !== 'shiftlogs');
  document.getElementById('dtab-time').classList.toggle('hidden', tabName !== 'time');
  document.getElementById('dtab-analytics').classList.toggle('hidden', tabName !== 'analytics');
  document.getElementById('dtab-daily').classList.toggle('hidden', tabName !== 'daily');
  document.getElementById('dtab-reconcile').classList.toggle('hidden', tabName !== 'reconcile');
  updateDashStickyHeaderSpacer();
  if (tabName === 'caselogs') renderCaseLogTable();
  if (tabName === 'shiftlogs') renderShiftLogTable();
  if (tabName === 'time') renderTimeTab();
  if (tabName === 'analytics') renderAnalyticsTab();
  if (tabName === 'daily') renderDailyTab();
  if (tabName === 'reconcile') renderReconTabs();
}

function updateDashStickyHeaderSpacer() {
  requestAnimationFrame(() => {
    const h = document.getElementById('dashStickyHeader').offsetHeight;
    document.getElementById('dashStickyHeaderSpacer').style.height = h + 'px';
  });
}

// Generic collapsible toggle
function toggleCollapse(sectionId) {
  const bodyMap = {
    deScan: 'deScanBody',
    timeWknd: 'timeWkndBody', timeNight: 'timeNightBody',
    histOverride: 'histOverrideBody', compStipends: 'compStipendsBody',
    importScan: 'importScanBody'
  };
  const arrowMap = {
    deScan: 'deScanArrow',
    timeWknd: 'timeWkndArrow', timeNight: 'timeNightArrow',
    histOverride: 'histOverrideArrow', compStipends: 'compStipendsArrow',
    importScan: 'importScanArrow'
  };
  const body = document.getElementById(bodyMap[sectionId]);
  const arrow = document.getElementById(arrowMap[sectionId]);
  if (!body || !arrow) return;
  if (body.style.maxHeight && body.style.maxHeight !== '0px') {
    body.style.maxHeight = '0';
    arrow.classList.remove('open');
  } else {
    body.style.maxHeight = body.scrollHeight + 'px';
    arrow.classList.add('open');
  }
}

// Shared helper: shift clocked-in hours (sum of time entries, not gaps)
function calcShiftHours(shift) {
  if (!shift || shift.assignmentType === 'vacation') return 0;
  const entries = shift.timeEntries || [];
  if (entries.length > 0) {
    let totalMin = 0;
    entries.forEach(e => {
      if (!e.start || !e.end) return;
      let s = timeToMinutes(e.start);
      let en = timeToMinutes(e.end);
      if (en <= s) en += 1440;
      totalMin += (en - s);
    });
    if (totalMin > 0) return totalMin / 60;
  }
  // Fallback for legacy shifts without timeEntries
  if (!shift.endTime) return 0;
  let start = timeToMinutes(shift.startTime);
  let end = timeToMinutes(shift.endTime);
  if (end <= start) end += 1440;
  return (end - start) / 60;
}

// ================================================================
// CASE LOGS TAB
// ================================================================
let clYear = new Date().getFullYear();
let clMonth = new Date().getMonth();

function updateCLMonthLabel() {
  const mn = ['January','February','March','April','May','June','July','August','September','October','November','December'];
  document.getElementById('clMonthLabel').textContent = `${mn[clMonth]} ${clYear}`;
}

document.getElementById('clPrevMonth').addEventListener('click', () => {
  clMonth--; if (clMonth < 0) { clMonth = 11; clYear--; }
  updateCLMonthLabel(); renderCaseLogTable();
});
document.getElementById('clNextMonth').addEventListener('click', () => {
  clMonth++; if (clMonth > 11) { clMonth = 0; clYear++; }
  updateCLMonthLabel(); renderCaseLogTable();
});

document.getElementById('caseLogSearch').addEventListener('input', () => filterCaseLog());

function getCaseAddOnSummary(c) {
  const parts = [];
  if (c.nerveBlock === 'brachial_plexus') parts.push('NB-BP');
  else if (c.nerveBlock === 'other') parts.push('NB');
  if (c.hasCentralLine) parts.push('CL');
  if (c.hasArterialLine) parts.push('AL');
  if (c.hasPAC) parts.push('PAC');
  if (c.hasTEEAddOn) parts.push('TEE');
  if (c.hasITMorphine) parts.push('ITM');
  return parts.join(', ');
}

function renderCaseLogTable() {
  updateCLMonthLabel();
  const prefix = `${clYear}-${String(clMonth+1).padStart(2,'0')}`;
  const monthCases = data.cases.filter(c => c.shiftDate && c.shiftDate.startsWith(prefix))
    .sort((a, b) => (b.shiftDate + (b.startTime || '')).localeCompare(a.shiftDate + (a.startTime || '')));
  const container = document.getElementById('caseLogTableContainer');
  // Hide delete-selected button on re-render
  document.getElementById('clDeleteSelectedBtn').classList.add('hidden');
  if (monthCases.length === 0) {
    container.innerHTML = '<div class="empty-state"><p>No cases for this month.</p></div>';
    return;
  }
  let html = '<table class="case-log-table" id="caseLogTable"><thead><tr>';
  html += '<th><input type="checkbox" class="cl-cb" id="clSelectAll" onclick="clToggleSelectAll(this)"></th>';
  html += '<th>Date</th><th>Case</th><th>Start</th><th>Stop</th><th>Pts</th><th></th><th></th>';
  html += '</tr></thead><tbody>';
  let totalPts = 0;
  monthCases.forEach(c => {
    const shift = data.shifts[c.shiftDate];
    const pts = calcCasePoints(c, shift);
    totalPts += pts;
    const name = c.caseType === 'standard' ? (c.procedure || 'Standard') : getCaseTypeName(c.caseType);
    const sharedMark = c.isSharedCase ? ' [S]' : '';
    const flaggedClass = c.flagged ? ' flagged-row' : '';
    html += `<tr class="${flaggedClass}" data-caseid="${c.id}" onclick="openCaseEdit('${c.id}')">`;
    html += `<td><input type="checkbox" class="cl-cb cl-row-cb" data-caseid="${c.id}" onclick="event.stopPropagation();clUpdateDeleteBtn()"></td>`;
    html += `<td>${formatDateShort(c.shiftDate)}</td>`;
    html += `<td>${escHtml(name)}${sharedMark}</td>`;
    html += `<td>${c.startTime || '-'}</td>`;
    html += `<td>${c.endTime || '-'}</td>`;
    html += `<td><strong>${pts.toFixed(1)}</strong></td>`;
    html += `<td><span class="cl-del" onclick="event.stopPropagation();deleteCase('${c.id}')">&times;</span></td>`;
    html += `<td><button class="flag-btn ${c.flagged ? 'flagged' : ''}" onclick="event.stopPropagation();toggleCaseFlag('${c.id}')">&#9873;</button></td>`;
    html += '</tr>';
  });
  html += '</tbody><tfoot><tr style="border-top:2px solid var(--accent);">';
  html += `<td colspan="7" style="text-align:right;font-weight:600;">Monthly Total (${monthCases.length} cases)</td>`;
  html += `<td><strong>${round2(totalPts).toFixed(1)}</strong></td>`;
  html += '</tr></tfoot></table>';
  container.innerHTML = html;
}

function clToggleSelectAll(masterCb) {
  const cbs = document.querySelectorAll('#caseLogTable .cl-row-cb');
  cbs.forEach(cb => { cb.checked = masterCb.checked; });
  clUpdateDeleteBtn();
}

function clUpdateDeleteBtn() {
  const cbs = document.querySelectorAll('#caseLogTable .cl-row-cb:checked');
  const btn = document.getElementById('clDeleteSelectedBtn');
  const count = cbs.length;
  document.getElementById('clDeleteSelectedCount').textContent = count;
  btn.classList.toggle('hidden', count === 0);
  // Update select-all checkbox state
  const allCbs = document.querySelectorAll('#caseLogTable .cl-row-cb');
  const selectAll = document.getElementById('clSelectAll');
  if (selectAll) {
    selectAll.checked = allCbs.length > 0 && count === allCbs.length;
    selectAll.indeterminate = count > 0 && count < allCbs.length;
  }
}

document.getElementById('clDeleteSelectedBtn').addEventListener('click', () => {
  const cbs = document.querySelectorAll('#caseLogTable .cl-row-cb:checked');
  const ids = Array.from(cbs).map(cb => cb.getAttribute('data-caseid'));
  if (ids.length === 0) return;
  if (!confirm(`Delete ${ids.length} selected case${ids.length > 1 ? 's' : ''}?`)) return;
  const idSet = new Set(ids);
  data.cases = data.cases.filter(c => !idSet.has(c.id));
  saveData(data);
  updateHeaderPoints();
  renderCaseLogTable();
  renderToday();
  renderDECaseList();
  updateDETally();
  showToast(`${ids.length} case${ids.length > 1 ? 's' : ''} deleted`);
});

function filterCaseLog() {
  const query = (document.getElementById('caseLogSearch').value || '').toLowerCase();
  const table = document.getElementById('caseLogTable');
  if (!table) return;
  const rows = table.querySelectorAll('tbody tr');
  rows.forEach(row => {
    const text = row.textContent.toLowerCase();
    row.style.display = text.includes(query) ? '' : 'none';
  });
}

// ================================================================
// SHIFT LOGS TAB
// ================================================================
let slYear = new Date().getFullYear();
let slMonth = new Date().getMonth();

function updateSLMonthLabel() {
  const mn = ['January','February','March','April','May','June','July','August','September','October','November','December'];
  document.getElementById('slMonthLabel').textContent = `${mn[slMonth]} ${slYear}`;
}

document.getElementById('slPrevMonth').addEventListener('click', () => {
  slMonth--; if (slMonth < 0) { slMonth = 11; slYear--; }
  updateSLMonthLabel(); renderShiftLogTable();
});
document.getElementById('slNextMonth').addEventListener('click', () => {
  slMonth++; if (slMonth > 11) { slMonth = 0; slYear++; }
  updateSLMonthLabel(); renderShiftLogTable();
});

document.getElementById('shiftLogSearch').addEventListener('input', () => filterShiftLog());

function getPayCodeName(normalizedMin, assignmentType, isWknd, isHol) {
  const isDaytime = normalizedMin >= 420 && normalizedMin < 1020;
  // OB_restricted always uses restricted OB rate; SF1 only during non-holiday weekday daytime
  const isOB = assignmentType === 'OB_restricted' ||
    (assignmentType === 'SF1' && !isHol && !isWknd && isDaytime);
  const isEvening = normalizedMin >= 1020 && normalizedMin < 1380;
  if (isWknd || isHol) {
    if (isDaytime) return isOB ? 'Restricted OB Weekend Day' : 'Weekend Day';
    return isOB ? 'Restricted OB Weekend Night' : 'Weekend Night';
  }
  if (isDaytime) return isOB ? 'Restricted OB Hours' : 'MD Hourly';
  if (isEvening) return isOB ? 'Restricted OB Evening' : 'Evening Diff';
  return isOB ? 'Restricted OB Night' : 'Night Diff';
}

function getShiftPayBreakdown(shift) {
  if (shift.assignmentType === 'vacation') return [];
  if (shift.forcedOff || shift.assignmentType === 'forced_off') return [{ clockIn: '', clockOut: '', payCode: 'Forced Off', durationMin: 0, payRate: 0, amount: 56 }];
  const isHol = shift.isHoliday;
  const isWknd = isWeekend(shift.date);
  const isWkndOrHol = isHol || isWknd;
  const pagerWindowEarly = getPagerPayWindow(shift.assignmentType, isWkndOrHol);

  // Temp coverage (covering): only coverage-scoped rows
  if (shift.tempCoverage && shift.tempCoverage.length > 0 && shift.tempCoverage[0].type === 'covering') {
    const tc = shift.tempCoverage[0];
    if (!tc.start || !tc.end) return [];
    let tcS = timeToMinutes(tc.start);
    let tcE = timeToMinutes(tc.end);
    if (tcE <= tcS) tcE += 1440;
    const tcDurMin = tcE - tcS;
    const coverageRows = [];
    coverageRows.push({
      clockIn: tc.start, clockOut: tc.end,
      payCode: 'Temp Coverage Pager',
      durationMin: tcDurMin, payRate: 3.5,
      amount: round2((tcDurMin / 60) * 3.5),
      isPager: true, isSubRow: false
    });
    (tc.timeEntries || []).forEach(e => {
      if (!e.start || !e.end) return;
      let es = timeToMinutes(e.start);
      let ee = timeToMinutes(e.end);
      if (ee <= es) ee += 1440;
      const eDurMin = ee - es;
      const normMin = es % 1440;
      const rate = getARRate(shift.assignmentType, isHol, isWknd, normMin);
      coverageRows.push({
        clockIn: e.start, clockOut: e.end,
        payCode: 'Temp Coverage AR',
        durationMin: eDurMin, payRate: rate,
        amount: round2((eDurMin / 60) * rate),
        isSubRow: false
      });
    });
    return coverageRows;
  }

  const entries = shift.timeEntries || [];
  const hasEntries = entries.length > 0 && (entries.length > 1 || entries[0].start);
  const lastEntry = hasEntries ? entries[entries.length - 1] : null;
  const hasEnd = hasEntries && (entries.length > 1 || (lastEntry && lastEntry.end));

  // No time entries: return pager pay row only if eligible
  if (!hasEntries || !hasEnd) {
    if (pagerWindowEarly) {
      const durMin = pagerWindowEarly.end - pagerWindowEarly.start;
      return [{ clockIn: minutesToTimeStr(pagerWindowEarly.start), clockOut: minutesToTimeStr(pagerWindowEarly.end), payCode: 'Pager Pay', durationMin: durMin, payRate: 3.5, amount: round2((durMin / 60) * 3.5), isPager: true, isSubRow: false }];
    }
    return [];
  }
  const isSF = ['SF1','SF2'].includes(shift.assignmentType);

  let orRanges = [];
  if (isSF) {
    const shiftCases = data.cases.filter(c => c.shiftDate === shift.date && c.isORCase);
    shiftCases.forEach(c => {
      let cs = timeToMinutes(c.startTime);
      let ce = timeToMinutes(c.endTime);
      if (ce <= cs) ce += 1440;
      orRanges.push({ start: cs, end: ce });
    });
  }

  const clockedRanges = [];
  entries.forEach(e => {
    if (!e.start) return;
    const s = timeToMinutes(e.start);
    let en = e.end ? timeToMinutes(e.end) : s;
    if (en <= s && e.end) en += 1440;
    clockedRanges.push({ start: s, end: en, startStr: e.start, endStr: e.end || '' });
  });
  // Fix cross-midnight ordering: if an entry starts before the previous entry, it's the next day
  for (let i = 1; i < clockedRanges.length; i++) {
    if (clockedRanges[i].start < clockedRanges[i-1].start) {
      clockedRanges[i].start += 1440;
      clockedRanges[i].end += 1440;
    }
  }

  function pagerOnlyRows() {
    if (pagerWindowEarly) {
      const durMin = pagerWindowEarly.end - pagerWindowEarly.start;
      return [{ clockIn: minutesToTimeStr(pagerWindowEarly.start), clockOut: minutesToTimeStr(pagerWindowEarly.end), payCode: 'Pager Pay', durationMin: durMin, payRate: 3.5, amount: round2((durMin / 60) * 3.5), isPager: true, isSubRow: false }];
    }
    return [];
  }
  if (clockedRanges.length === 0) return pagerOnlyRows();
  const spanStart = clockedRanges[0].start;
  const spanEnd = clockedRanges[clockedRanges.length - 1].end;
  if (spanEnd <= spanStart) return pagerOnlyRows();

  const rows = [];

  // Build pre-call range (OR rates during pre-call period)
  let preCallRange = null;
  if (shift.preCallStart && shift.preCallEnd) {
    let pcs = timeToMinutes(shift.preCallStart);
    let pce = timeToMinutes(shift.preCallEnd);
    if (pce <= pcs) pce += 1440;
    preCallRange = { start: pcs, end: pce };
  }

  // Rate-change boundaries (minute of day)
  function getBoundaries() {
    const b = (isWknd || isHol) ? [420, 1020] : [420, 1020, 1380];
    // Add supervision overlay boundaries so segments split at supervision start/end
    if (shift.supervisionStart && shift.supervisionEnd && shift.assignmentType !== 'CRNA_supervision') {
      const ss = timeToMinutes(shift.supervisionStart);
      const se = timeToMinutes(shift.supervisionEnd);
      if (ss > 0 && !b.includes(ss)) b.push(ss);
      if (se > 0 && !b.includes(se)) b.push(se);
    }
    // Add pre-call boundaries so segments split at pre-call start/end
    if (preCallRange) {
      const pcStart = preCallRange.start % 1440;
      const pcEnd = preCallRange.end % 1440;
      if (!b.includes(pcStart)) b.push(pcStart);
      if (pcEnd > 0 && !b.includes(pcEnd)) b.push(pcEnd);
    }
    return b.sort((a, c) => a - c);
  }
  const bounds = getBoundaries();

  // For each clocked range, segment at rate boundaries
  clockedRanges.forEach((cr, idx) => {
    let segStart = cr.start;
    while (segStart < cr.end) {
      const normStart = segStart % 1440;
      // Find next boundary after normStart
      let nextBound = cr.end;
      for (const b of bounds) {
        // Calculate the actual minute where this boundary hits within the shift span
        const base = segStart - normStart;
        let boundMin = base + b;
        if (boundMin <= segStart) boundMin += 1440;
        if (boundMin < nextBound) nextBound = boundMin;
      }
      const segEnd = Math.min(nextBound, cr.end);
      const normSeg = segStart % 1440;
      let rateType = shift.assignmentType;
      let isPreCallSeg = false;
      if (preCallRange && segStart >= preCallRange.start && segStart < preCallRange.end) {
        rateType = 'OR';
        isPreCallSeg = true;
      } else if (isSF) {
        for (const r of orRanges) {
          if (segStart >= r.start && segStart < r.end) { rateType = 'OR'; break; }
        }
      }
      const payCode = isPreCallSeg ? 'Pre-Call ' + getPayCodeName(normSeg, 'OR', isWknd, isHol) : getPayCodeName(normSeg, rateType, isWknd, isHol);
      let payRate = getARRate(rateType, isHol, isWknd, normSeg);

      // CRNA supervision bonus: +7/hr
      let supBonus = 0;
      if (shift.assignmentType === 'CRNA_supervision') {
        // Standalone CRNA supervision: +7 on all clocked time
        supBonus = 7;
      } else if (shift.supervisionStart && shift.supervisionEnd) {
        // Overlay: +7 only during supervision period
        let supStart = timeToMinutes(shift.supervisionStart);
        let supEnd = timeToMinutes(shift.supervisionEnd);
        if (supEnd <= supStart) supEnd += 1440;
        if (segStart < supEnd && segEnd > supStart) supBonus = 7;
      }
      payRate += supBonus;

      const durMin = segEnd - segStart;
      rows.push({
        clockIn: segStart === cr.start ? cr.startStr : '',
        clockOut: segEnd === cr.end ? cr.endStr : '',
        payCode: supBonus > 0 ? payCode + ' + CRNA' : payCode,
        durationMin: durMin,
        payRate,
        amount: round2((durMin / 60) * payRate),
        entryIdx: idx,
        isSubRow: segStart !== cr.start
      });
      segStart = segEnd;
    }
  });

  // Pager pay: guaranteed full window duration (does not stop when clocked in)
  const pagerWindow = getPagerPayWindow(shift.assignmentType, isWkndOrHol);
  if (pagerWindow) {
    const durMin = pagerWindow.end - pagerWindow.start;
    if (durMin > 0) {
      rows.push({
        clockIn: minutesToTimeStr(pagerWindow.start),
        clockOut: minutesToTimeStr(pagerWindow.end),
        payCode: 'Pager Pay',
        durationMin: durMin,
        payRate: 3.5,
        amount: round2((durMin / 60) * 3.5),
        isPager: true,
        isSubRow: false
      });
    }
  }

  // Temp coverage rows
  if (shift.tempCoverage && shift.tempCoverage.length > 0) {
    shift.tempCoverage.forEach(tc => {
      if (!tc.start || !tc.end) return;
      let tcS = timeToMinutes(tc.start);
      let tcE = timeToMinutes(tc.end);
      if (tcE <= tcS) tcE += 1440;
      const tcDurMin = tcE - tcS;
      if (tc.type === 'covered') {
        rows.push({
          clockIn: tc.start, clockOut: tc.end,
          payCode: 'Temp Coverage (Covered)',
          durationMin: tcDurMin, payRate: -3.5,
          amount: round2((tcDurMin / 60) * -3.5),
          isPager: true, isSubRow: false
        });
      } else if (tc.type === 'covering') {
        rows.push({
          clockIn: tc.start, clockOut: tc.end,
          payCode: 'Temp Coverage Pager',
          durationMin: tcDurMin, payRate: 3.5,
          amount: round2((tcDurMin / 60) * 3.5),
          isPager: true, isSubRow: false
        });
        // AR rows for coverage work time entries
        const tcEntries = tc.timeEntries || [];
        tcEntries.forEach(e => {
          if (!e.start || !e.end) return;
          let es = timeToMinutes(e.start);
          let ee = timeToMinutes(e.end);
          if (ee <= es) ee += 1440;
          const eDurMin = ee - es;
          const normMin = es % 1440;
          const rate = getARRate(shift.assignmentType, isHol, isWknd, normMin);
          rows.push({
            clockIn: e.start, clockOut: e.end,
            payCode: 'Temp Coverage AR',
            durationMin: eDurMin, payRate: rate,
            amount: round2((eDurMin / 60) * rate),
            isSubRow: false
          });
        });
      }
    });
  }

  // Merge consecutive same-payCode segments within the same entry
  const merged = [];
  for (let i = 0; i < rows.length; i++) {
    const r = rows[i];
    if (merged.length > 0) {
      const prev = merged[merged.length - 1];
      if (prev.payCode === r.payCode && prev.entryIdx === r.entryIdx && !r.isPager && !prev.isPager) {
        prev.durationMin += r.durationMin;
        prev.amount = round2(prev.amount + r.amount);
        if (r.clockOut) prev.clockOut = r.clockOut;
        continue;
      }
    }
    merged.push({ ...r });
  }

  // Consolidate all rows with the same payCode + payRate into single totals
  const consolidated = [];
  const seen = {};
  for (const r of merged) {
    const key = r.payCode + '|' + r.payRate;
    if (seen[key] !== undefined) {
      const c = consolidated[seen[key]];
      c.durationMin += r.durationMin;
      c.amount = round2(c.amount + r.amount);
      if (r.clockOut) c.clockOut = r.clockOut;
    } else {
      seen[key] = consolidated.length;
      consolidated.push({ ...r });
    }
  }

  // Guaranteed minimum logic
  if (!isHol && !isWknd) {
    if (preCallRange) {
      // Pre-call split: apply separate minimums to pre-call and evening rows
      const preCallRows = consolidated.filter(r => !r.isPager && r.payCode && r.payCode.startsWith('Pre-Call'));
      const eveningRows = consolidated.filter(r => !r.isPager && r.payCode && !r.payCode.startsWith('Pre-Call'));
      const pagerRows = consolidated.filter(r => r.isPager);

      const preCallTotal = preCallRows.reduce((sum, r) => sum + r.amount, 0);
      const preCallMin = 20 * 4; // OR rate minimum = 80 pts
      let preCallResult = preCallRows;
      if (preCallTotal > 0 && preCallTotal < preCallMin) {
        preCallResult = [{
          clockIn: preCallRows[0]?.clockIn || '', clockOut: preCallRows[preCallRows.length - 1]?.clockOut || '',
          payCode: 'Pre-Call 4-Hour Minimum',
          durationMin: 240, payRate: 20, amount: preCallMin,
          isSubRow: false, isPreCall: true
        }];
      }

      let eveningResult = eveningRows;
      if (shift.assignmentType !== 'mole') {
        const eveningTotal = eveningRows.reduce((sum, r) => sum + r.amount, 0);
        const isOBRate = ['OB_restricted','SF1'].includes(shift.assignmentType);
        const eveningMin = isOBRate ? 13 * 4 : 20 * 4;
        if (eveningTotal > 0 && eveningTotal < eveningMin) {
          eveningResult = [{
            clockIn: eveningRows[0]?.clockIn || '', clockOut: eveningRows[eveningRows.length - 1]?.clockOut || '',
            payCode: getAssignmentTypeName(shift.assignmentType) + ' 4-Hour Minimum',
            durationMin: 240, payRate: isOBRate ? 13 : 20, amount: eveningMin,
            isSubRow: false
          }];
        }
      }

      consolidated.length = 0;
      preCallResult.forEach(r => consolidated.push(r));
      eveningResult.forEach(r => consolidated.push(r));
      pagerRows.forEach(r => consolidated.push(r));
    } else if (shift.assignmentType !== 'mole') {
      // Non-pre-call: single 4hr minimum
      const isOBRate = ['OB_restricted','SF1'].includes(shift.assignmentType);
      const minPoints = isOBRate ? 13 * 4 : 20 * 4;
      const arRows = consolidated.filter(r => !r.isPager);
      const arTotal = arRows.reduce((sum, r) => sum + r.amount, 0);
      if (arTotal > 0 && arTotal < minPoints) {
        const pagerRows = consolidated.filter(r => r.isPager);
        consolidated.length = 0;
        consolidated.push({
          clockIn: arRows[0]?.clockIn || '', clockOut: arRows[arRows.length - 1]?.clockOut || '',
          payCode: '4-Hour Minimum',
          durationMin: 240, payRate: isOBRate ? 13 : 20, amount: minPoints,
          isSubRow: false
        });
        pagerRows.forEach(r => consolidated.push(r));
      }
    }
  }

  return consolidated;
}

function getShiftBadgeClass(type) {
  if (type === 'OR' || type === 'cardiac_liver' || type === 'NORA' || type === 'ACS' || type === 'pre_call') return 'sl-badge-or';
  if (type === 'OB_restricted') return 'sl-badge-ob';
  if (type.includes('call')) return 'sl-badge-call';
  if (type === 'endo') return 'sl-badge-endo';
  if (type === 'SF1' || type === 'SF2') return 'sl-badge-sf';
  if (type === 'vacation' || type === 'forced_off') return 'sl-badge-vac';
  return 'sl-badge-other';
}

function minutesToTimeStr(m) {
  const norm = ((m % 1440) + 1440) % 1440;
  return String(Math.floor(norm / 60)).padStart(2, '0') + ':' + String(norm % 60).padStart(2, '0');
}

function renderShiftLogTable() {
  updateSLMonthLabel();
  const prefix = `${slYear}-${String(slMonth + 1).padStart(2, '0')}`;
  const monthShifts = Object.values(data.shifts)
    .filter(s => s.date && s.date.startsWith(prefix))
    .sort((a, b) => a.date.localeCompare(b.date));

  const container = document.getElementById('shiftLogTableContainer');
  const summaryEl = document.getElementById('shiftLogSummary');
  document.getElementById('slDeleteBar').classList.add('hidden');

  if (monthShifts.length === 0) {
    container.innerHTML = '<div class="empty-state"><p>No shifts for this month.</p></div>';
    summaryEl.innerHTML = '';
    return;
  }

  // Build breakdowns for all shifts
  const allBreakdowns = [];
  monthShifts.forEach(shift => {
    const rows = getShiftPayBreakdown(shift);
    allBreakdowns.push({ shift, rows });
  });

  // Summary card: aggregate by payCode
  const payCodeTotals = {};
  allBreakdowns.forEach(({ rows }) => {
    rows.forEach(r => {
      if (!payCodeTotals[r.payCode]) payCodeTotals[r.payCode] = { hours: 0, amount: 0 };
      payCodeTotals[r.payCode].hours += r.durationMin / 60;
      payCodeTotals[r.payCode].amount += r.amount;
    });
  });

  let totalHours = 0, totalAmount = 0;
  let summaryHtml = '<table class="sl-summary-table"><thead><tr><th>Pay Code</th><th>Hours</th><th>Amount</th></tr></thead><tbody>';
  const sortedCodes = Object.keys(payCodeTotals).sort((a, b) => payCodeTotals[b].amount - payCodeTotals[a].amount);
  sortedCodes.forEach(code => {
    const t = payCodeTotals[code];
    totalHours += t.hours;
    totalAmount += t.amount;
    const cls = code === 'Pager Pay' ? ' class="sl-pager-row"' : '';
    summaryHtml += `<tr${cls}><td>${code}</td><td>${t.hours.toFixed(1)}</td><td>${t.amount.toFixed(1)}</td></tr>`;
  });
  summaryHtml += `<tr><td><strong>Total</strong></td><td><strong>${totalHours.toFixed(1)}</strong></td><td><strong>${totalAmount.toFixed(1)}</strong></td></tr>`;
  summaryHtml += '</tbody></table>';
  summaryEl.innerHTML = summaryHtml;

  // Detail table
  const dayNames = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
  let html = '<table class="shift-log-table" id="shiftLogTable"><thead><tr>';
  html += '<th class="sl-check"><input type="checkbox" id="slSelectAll" onclick="slToggleAll(this)"></th>';
  html += '<th>Date</th><th>Assignment</th><th>Time</th><th>Duration</th><th>Clock In</th><th>Clock Out</th><th>Pay Code</th><th>Hours</th><th>Pay Rate</th><th>Amount</th><th></th><th class="sl-del-cell"></th>';
  html += '</tr></thead><tbody>';

  let grandTotal = 0;
  let shiftIdx = 0;

  allBreakdowns.forEach(({ shift, rows }) => {
    const d = new Date(shift.date + 'T12:00:00');
    const dayName = dayNames[d.getDay()];
    const month = d.getMonth() + 1;
    const day = d.getDate();
    const dateLabel = `${dayName} ${month}/${day}`;
    const typeName = getAssignmentTypeName(shift.assignmentType);
    const badgeClass = getShiftBadgeClass(shift.assignmentType);
    const hasPreCall = shift.preCallStart && shift.preCallEnd;
    const totalHrs = calcShiftHours(shift);
    const entries = shift.timeEntries || [];
    const timeStr = entries.length > 0 && entries[0].start
      ? entries[0].start + (entries[entries.length - 1].end ? ' - ' + entries[entries.length - 1].end : '')
      : '-';
    const shiftTotal = rows.reduce((s, r) => s + r.amount, 0);
    grandTotal += shiftTotal;
    const checkboxCell = `<td class="sl-check"><input type="checkbox" class="sl-shift-cb" data-date="${shift.date}" onclick="event.stopPropagation();slUpdateDeleteBar()"></td>`;
    const deleteCell = `<td class="sl-del-cell"><button class="sl-del-btn" title="Delete shift" onclick="event.stopPropagation();deleteShiftFromLog('${shift.date}')">&times;</button></td>`;

    if (shift.assignmentType === 'vacation') {
      const altClass = shiftIdx % 2 === 1 ? ' sl-alt' : '';
      const fClass = shift.flagged ? ' flagged-row' : '';
      shiftIdx++;
      html += `<tr class="${altClass}${fClass}" data-shiftdate="${shift.date}" onclick="openShiftEdit('${shift.date}')">`;
      html += checkboxCell;
      html += `<td>${dateLabel}</td>`;
      html += `<td><span class="sl-badge ${badgeClass}">${escHtml(typeName)}</span></td>`;
      html += `<td>-</td><td>-</td><td>-</td><td>-</td><td>Vacation</td><td>-</td><td>-</td><td>0.0</td>`;
      html += `<td><button class="flag-btn ${shift.flagged ? 'flagged' : ''}" onclick="event.stopPropagation();toggleShiftFlag('${shift.date}')">&#9873;</button></td>`;
      html += deleteCell;
      html += '</tr>';
      return;
    }

    if (rows.length === 0) {
      const altClass = shiftIdx % 2 === 1 ? ' sl-alt' : '';
      const fClass = shift.flagged ? ' flagged-row' : '';
      shiftIdx++;
      html += `<tr class="${altClass}${fClass}" data-shiftdate="${shift.date}" onclick="openShiftEdit('${shift.date}')">`;
      html += checkboxCell;
      html += `<td>${dateLabel}</td>`;
      html += `<td><span class="sl-badge ${badgeClass}">${escHtml(typeName)}</span></td>`;
      html += `<td>${timeStr}</td><td>${totalHrs.toFixed(1)}h</td>`;
      html += `<td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>0.0</td>`;
      html += `<td><button class="flag-btn ${shift.flagged ? 'flagged' : ''}" onclick="event.stopPropagation();toggleShiftFlag('${shift.date}')">&#9873;</button></td>`;
      html += deleteCell;
      html += '</tr>';
      return;
    }

    // Pre-call shifts: render as two separate visual groups
    if (hasPreCall) {
      const preCallRows = rows.filter(r => r.payCode && r.payCode.startsWith('Pre-Call'));
      const eveningRows = rows.filter(r => !r.payCode || !r.payCode.startsWith('Pre-Call'));
      const pcTimeStr = shift.preCallStart + ' - ' + shift.preCallEnd;
      // Compute pre-call clocked hours
      let pcMinutes = 0;
      const pcEnd = (() => { let e = timeToMinutes(shift.preCallEnd); const s = timeToMinutes(shift.preCallStart); if (e <= s) e += 1440; return e; })();
      const pcStart = timeToMinutes(shift.preCallStart);
      entries.forEach(e => {
        if (!e.start || !e.end) return;
        let s = timeToMinutes(e.start);
        let en = timeToMinutes(e.end);
        if (en <= s) en += 1440;
        // Overlap with pre-call window
        const overlapStart = Math.max(s, pcStart);
        const overlapEnd = Math.min(en, pcEnd);
        if (overlapEnd > overlapStart) pcMinutes += (overlapEnd - overlapStart);
      });
      const pcHrs = pcMinutes / 60;
      const eveningHrs = totalHrs - pcHrs;

      // Pre-Call group
      const pcAlt = shiftIdx % 2 === 1 ? ' sl-alt' : '';
      const pcFClass = shift.flagged ? ' flagged-row' : '';
      shiftIdx++;
      if (preCallRows.length > 0) {
        preCallRows.forEach((r, i) => {
          const rowClass = i > 0 ? `sl-sub-row${pcAlt}` : pcAlt.trim();
          html += `<tr class="${rowClass}${pcFClass}" data-shiftdate="${shift.date}" onclick="openShiftEdit('${shift.date}')">`;
          if (i === 0) {
            html += checkboxCell;
            html += `<td>${dateLabel}</td>`;
            html += `<td><span class="sl-badge sl-badge-or">Pre-Call</span></td>`;
            html += `<td>${pcTimeStr}</td>`;
            html += `<td>${pcHrs.toFixed(1)}h</td>`;
          } else {
            html += '<td data-blank></td><td data-blank></td><td data-blank></td><td data-blank></td><td data-blank></td>';
          }
          html += `<td>${r.clockIn || ''}</td><td>${r.clockOut || ''}</td>`;
          html += `<td>${r.payCode}</td><td>${(r.durationMin / 60).toFixed(1)}</td>`;
          html += `<td>${r.payRate.toFixed(1)}/hr</td><td><strong>${r.amount.toFixed(1)}</strong></td>`;
          html += i === 0 ? `<td><button class="flag-btn ${shift.flagged ? 'flagged' : ''}" onclick="event.stopPropagation();toggleShiftFlag('${shift.date}')">&#9873;</button></td>` : '<td></td>';
          html += i === 0 ? deleteCell : '<td></td>';
          html += '</tr>';
        });
      } else {
        html += `<tr class="${pcAlt}${pcFClass}" data-shiftdate="${shift.date}" onclick="openShiftEdit('${shift.date}')">`;
        html += checkboxCell;
        html += `<td>${dateLabel}</td>`;
        html += `<td><span class="sl-badge sl-badge-or">Pre-Call</span></td>`;
        html += `<td>${pcTimeStr}</td><td>${pcHrs.toFixed(1)}h</td>`;
        html += `<td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>0.0</td>`;
        html += `<td><button class="flag-btn ${shift.flagged ? 'flagged' : ''}" onclick="event.stopPropagation();toggleShiftFlag('${shift.date}')">&#9873;</button></td>`;
        html += deleteCell;
        html += '</tr>';
      }

      // Evening group
      const evAlt = shiftIdx % 2 === 1 ? ' sl-alt' : '';
      shiftIdx++;
      if (eveningRows.length > 0) {
        eveningRows.forEach((r, i) => {
          const rowClass = i > 0 ? `sl-sub-row${evAlt}` : evAlt.trim();
          html += `<tr class="${rowClass}${pcFClass}" data-shiftdate="${shift.date}" onclick="openShiftEdit('${shift.date}')">`;
          if (i === 0) {
            html += '<td data-blank></td>';
            html += `<td>${dateLabel}</td>`;
            html += `<td><span class="sl-badge ${badgeClass}">${escHtml(typeName)}</span></td>`;
            html += `<td>${timeStr}</td>`;
            html += `<td>${eveningHrs.toFixed(1)}h</td>`;
          } else {
            html += '<td data-blank></td><td data-blank></td><td data-blank></td><td data-blank></td><td data-blank></td>';
          }
          html += `<td>${r.clockIn || ''}</td><td>${r.clockOut || ''}</td>`;
          html += `<td>${r.payCode}</td><td>${(r.durationMin / 60).toFixed(1)}</td>`;
          html += `<td>${r.payRate.toFixed(1)}/hr</td><td><strong>${r.amount.toFixed(1)}</strong></td>`;
          html += '<td></td>';
          html += '<td></td>';
          html += '</tr>';
        });
      } else {
        html += `<tr class="${evAlt}${pcFClass}" data-shiftdate="${shift.date}" onclick="openShiftEdit('${shift.date}')">`;
        html += '<td data-blank></td>';
        html += `<td>${dateLabel}</td>`;
        html += `<td><span class="sl-badge ${badgeClass}">${escHtml(typeName)}</span></td>`;
        html += `<td>${timeStr}</td><td>${eveningHrs.toFixed(1)}h</td>`;
        html += `<td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>0.0</td>`;
        html += '<td></td>';
        html += '<td></td>';
        html += '</tr>';
      }
      return;
    }

    // Non-pre-call shifts: single group
    const altClass = shiftIdx % 2 === 1 ? ' sl-alt' : '';
    const fClass = shift.flagged ? ' flagged-row' : '';
    shiftIdx++;
    rows.forEach((r, i) => {
      const rowClass = i > 0 ? `sl-sub-row${altClass}` : altClass.trim();
      html += `<tr class="${rowClass}${fClass}" data-shiftdate="${shift.date}" onclick="openShiftEdit('${shift.date}')">`;
      if (i === 0) {
        html += checkboxCell;
        html += `<td>${dateLabel}</td>`;
        html += `<td><span class="sl-badge ${badgeClass}">${escHtml(typeName)}</span></td>`;
        html += `<td>${timeStr}</td>`;
        html += `<td>${totalHrs.toFixed(1)}h</td>`;
      } else {
        html += '<td data-blank></td><td data-blank></td><td data-blank></td><td data-blank></td><td data-blank></td>';
      }
      html += `<td>${r.clockIn || ''}</td>`;
      html += `<td>${r.clockOut || ''}</td>`;
      html += `<td>${r.payCode}</td>`;
      html += `<td>${(r.durationMin / 60).toFixed(1)}</td>`;
      html += `<td>${r.payRate.toFixed(1)}/hr</td>`;
      html += `<td><strong>${r.amount.toFixed(1)}</strong></td>`;
      html += i === 0 ? `<td><button class="flag-btn ${shift.flagged ? 'flagged' : ''}" onclick="event.stopPropagation();toggleShiftFlag('${shift.date}')">&#9873;</button></td>` : '<td></td>';
      html += i === 0 ? deleteCell : '<td></td>';
      html += '</tr>';
    });
  });

  html += `<tr style="border-top:2px solid var(--border);"><td colspan="12" style="text-align:right;font-weight:700;">Monthly Total</td><td><strong>${grandTotal.toFixed(1)}</strong></td></tr>`;
  html += '</tbody></table>';
  container.innerHTML = html;
}

function slToggleAll(masterCb) {
  const cbs = document.querySelectorAll('.sl-shift-cb');
  cbs.forEach(cb => { cb.checked = masterCb.checked; });
  slUpdateDeleteBar();
}

function slUpdateDeleteBar() {
  const cbs = document.querySelectorAll('.sl-shift-cb:checked');
  const bar = document.getElementById('slDeleteBar');
  const countEl = document.getElementById('slDeleteCount');
  if (cbs.length > 0) {
    bar.classList.remove('hidden');
    countEl.textContent = cbs.length + ' selected';
  } else {
    bar.classList.add('hidden');
  }
  // Sync select-all checkbox
  const allCbs = document.querySelectorAll('.sl-shift-cb');
  const selectAll = document.getElementById('slSelectAll');
  if (selectAll) {
    selectAll.checked = allCbs.length > 0 && cbs.length === allCbs.length;
  }
}

function deleteShiftFromLog(dateStr) {
  if (!confirm('Delete this shift and its associated cases? This cannot be undone.')) return;
  delete data.shifts[dateStr];
  data.cases = data.cases.filter(c => c.shiftDate !== dateStr);
  saveData(data);
  updateHeaderPoints();
  renderShiftLogTable();
  renderToday();
  renderDailyTab();
  showToast('Shift deleted');
}

function deleteSelectedShifts() {
  const cbs = document.querySelectorAll('.sl-shift-cb:checked');
  if (cbs.length === 0) return;
  const dates = Array.from(cbs).map(cb => cb.dataset.date);
  const unique = [...new Set(dates)];
  if (!confirm(`Delete ${unique.length} shift${unique.length > 1 ? 's' : ''} and their associated cases? This cannot be undone.`)) return;
  unique.forEach(dateStr => {
    delete data.shifts[dateStr];
    data.cases = data.cases.filter(c => c.shiftDate !== dateStr);
  });
  saveData(data);
  updateHeaderPoints();
  renderShiftLogTable();
  renderToday();
  renderDailyTab();
  showToast(`${unique.length} shift${unique.length > 1 ? 's' : ''} deleted`);
}

function filterShiftLog() {
  const query = (document.getElementById('shiftLogSearch').value || '').toLowerCase();
  const table = document.getElementById('shiftLogTable');
  if (!table) return;
  const rows = table.querySelectorAll('tbody tr');
  rows.forEach(row => {
    const text = row.textContent.toLowerCase();
    row.style.display = text.includes(query) ? '' : 'none';
  });
}

function toggleCaseFlag(caseId) {
  const c = data.cases.find(x => x.id === caseId);
  if (c) { c.flagged = !c.flagged; saveData(); renderCaseLogTable(); }
}
function toggleShiftFlag(dateStr) {
  const s = data.shifts[dateStr];
  if (s) { s.flagged = !s.flagged; saveData(); renderShiftLogTable(); }
}

function renderFlaggedPage() {
  const flaggedShifts = Object.values(data.shifts).filter(s => s.flagged).sort((a,b) => a.date.localeCompare(b.date));
  const flaggedCases = data.cases.filter(c => c.flagged).sort((a,b) => (a.shiftDate||'').localeCompare(b.shiftDate||''));
  const total = flaggedShifts.length + flaggedCases.length;
  const countEl = document.getElementById('flaggedCount');
  const listEl = document.getElementById('flaggedList');
  countEl.textContent = total > 0 ? `${total} flagged item${total !== 1 ? 's' : ''}` : '';

  if (total === 0) {
    listEl.innerHTML = '<div class="empty-state"><p>No flagged items.</p></div>';
    listEl.dataset.emailText = '';
    return;
  }

  // Build combined list sorted by date
  const items = [];
  flaggedShifts.forEach(s => {
    const d = new Date(s.date + 'T12:00:00');
    const dateStr = `${d.getMonth()+1}/${d.getDate()}/${d.getFullYear()}`;
    const typeName = getAssignmentTypeName(s.assignmentType);
    const entries = s.timeEntries || [];
    const times = entries.length > 0 && entries[0].start
      ? entries[0].start + (entries[entries.length-1].end ? ' \u2013 ' + entries[entries.length-1].end : '')
      : 'no times recorded';
    items.push({ date: s.date, dateStr, type: 'shift', label: typeName, detail: times, id: s.date });
  });
  flaggedCases.forEach(c => {
    const d = new Date(c.shiftDate + 'T12:00:00');
    const dateStr = `${d.getMonth()+1}/${d.getDate()}/${d.getFullYear()}`;
    const name = c.caseType === 'standard' ? (c.procedure || 'Standard') : getCaseTypeName(c.caseType);
    const times = (c.startTime || '?') + ' \u2013 ' + (c.endTime || '?');
    items.push({ date: c.shiftDate, dateStr, type: 'case', label: name, detail: times, id: c.id });
  });
  items.sort((a, b) => a.date.localeCompare(b.date));

  let html = '<ul class="flagged-list">';
  items.forEach(item => {
    const badge = item.type === 'shift'
      ? '<span style="background:var(--primary);color:#fff;font-size:0.65rem;padding:1px 6px;border-radius:4px;margin-right:6px;">SHIFT</span>'
      : '<span style="background:var(--accent2);color:#000;font-size:0.65rem;padding:1px 6px;border-radius:4px;margin-right:6px;">CASE</span>';
    html += `<li style="display:flex;align-items:center;justify-content:space-between;">`;
    html += `<div>${badge}<strong>${item.dateStr}</strong> &mdash; ${escHtml(item.label)} <span style="color:var(--text-dim);font-size:0.75rem;">(${item.detail})</span></div>`;
    if (item.type === 'shift') {
      html += `<button class="flag-btn flagged" onclick="toggleShiftFlag('${item.id}');renderFlaggedPage()" style="font-size:1.1rem;">&#9873;</button>`;
    } else {
      html += `<button class="flag-btn flagged" onclick="toggleCaseFlag('${item.id}');renderFlaggedPage()" style="font-size:1.1rem;">&#9873;</button>`;
    }
    html += '</li>';
  });
  html += '</ul>';
  listEl.innerHTML = html;

  // Build email text for clipboard
  const userName = data.settings?.name || settings.name || 'Provider';
  let emailText = `Subject: Missing Time Punches \u2014 ${userName}\n\nHi,\n\nThe following items are missing time punches on the compensation sheet:\n\n`;
  items.forEach((item, i) => {
    const prefix = item.type === 'case' ? 'Case: ' : '';
    emailText += `${i+1}. ${item.dateStr} \u2014 ${prefix}${item.label} (${item.detail})\n`;
  });
  emailText += `\nPlease update accordingly.\n\nThanks,\n${userName}`;
  listEl.dataset.emailText = emailText;
}

// ================================================================
// SHIFT EDIT MODAL
// ================================================================
let editingShiftDate = null;

function openShiftEdit(dateStr) {
  const shift = data.shifts[dateStr];
  if (!shift) return;

  // Navigate to Data Entry page for this date in edit mode
  setWorkingDate(dateStr);
  deShiftEditing = true;
  returnToShiftLogs = true;
  document.querySelectorAll('.bottom-nav button').forEach(b => b.classList.remove('active'));
  document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
  const deBtn = document.querySelector('.bottom-nav button[data-page="dataentry"]');
  deBtn.classList.add('active');
  document.getElementById('page-dataentry').classList.add('active');
  loadDataEntryPage();
}

function navigateToShiftLogs() {
  returnToShiftLogs = false;
  document.querySelectorAll('.bottom-nav button').forEach(b => b.classList.remove('active'));
  document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
  const dashBtn = document.querySelector('.bottom-nav button[data-page="dashboard"]');
  dashBtn.classList.add('active');
  document.getElementById('page-dashboard').classList.add('active');
  document.querySelectorAll('.dash-tab').forEach(t => t.classList.remove('active'));
  const slTab = document.getElementById('dashShiftLogsTab');
  if (slTab) { slTab.classList.add('active'); slTab.click(); }
}

function renderEditShiftTimeEntries(entries) {
  const container = document.getElementById('editShiftTimeEntries');
  if (!entries || entries.length === 0) entries = [{ start: '', end: '' }];
  let html = '';
  entries.forEach((e, i) => {
    html += `<div class="form-row" style="align-items:end;gap:8px;margin-top:8px;">
      <div class="form-group" style="flex:1;">
        <label>Start${entries.length > 1 ? ' #' + (i + 1) : ''}</label>
        <input type="text" inputmode="numeric" placeholder="HH:MM" maxlength="5" class="mil-time edit-shift-start" value="${e.start || ''}">
      </div>
      <div class="form-group" style="flex:1;">
        <label>End${entries.length > 1 ? ' #' + (i + 1) : ''}</label>
        <input type="text" inputmode="numeric" placeholder="HH:MM" maxlength="5" class="mil-time edit-shift-end" value="${e.end || ''}">
      </div>
      ${entries.length > 1 ? `<button class="btn btn-danger btn-sm" onclick="removeEditShiftEntry(${i})" style="margin-bottom:4px;padding:4px 8px;">x</button>` : ''}
    </div>`;
  });
  container.innerHTML = html;
  container.querySelectorAll('.mil-time').forEach(inp => bindMilTimeInput(inp));
}

function getEditShiftEntries() {
  const starts = document.querySelectorAll('#editShiftTimeEntries .edit-shift-start');
  const ends = document.querySelectorAll('#editShiftTimeEntries .edit-shift-end');
  const entries = [];
  starts.forEach((s, i) => {
    entries.push({ start: s.value.trim(), end: (ends[i] ? ends[i].value.trim() : '') });
  });
  return entries;
}

function removeEditShiftEntry(idx) {
  const entries = getEditShiftEntries();
  entries.splice(idx, 1);
  renderEditShiftTimeEntries(entries);
}

document.getElementById('editShiftAddEntry').addEventListener('click', () => {
  const entries = getEditShiftEntries();
  entries.push({ start: '', end: '' });
  renderEditShiftTimeEntries(entries);
});

document.getElementById('saveShiftEdit').addEventListener('click', () => {
  if (!editingShiftDate) return;
  const shift = data.shifts[editingShiftDate];
  if (!shift) return;
  shift.assignmentType = document.getElementById('editShiftType').value;
  shift.isHoliday = document.getElementById('editShiftHoliday').checked;
  shift.timeEntries = getEditShiftEntries();
  // Also sync legacy startTime/endTime
  if (shift.timeEntries.length > 0) {
    shift.startTime = shift.timeEntries[0].start;
    shift.endTime = shift.timeEntries[shift.timeEntries.length - 1].end;
  }
  saveData(data);
  document.getElementById('shiftEditModal').classList.add('hidden');
  editingShiftDate = null;
  updateHeaderPoints();
  renderShiftLogTable();
  renderToday();
  renderDailyTab();
  showToast('Shift updated');
});

document.getElementById('deleteShiftBtn').addEventListener('click', () => {
  if (!editingShiftDate) return;
  if (!confirm('Delete this shift? This cannot be undone.')) return;
  delete data.shifts[editingShiftDate];
  saveData(data);
  document.getElementById('shiftEditModal').classList.add('hidden');
  editingShiftDate = null;
  updateHeaderPoints();
  renderShiftLogTable();
  renderToday();
  renderDailyTab();
  showToast('Shift deleted');
});

document.getElementById('cancelShiftEdit').addEventListener('click', () => {
  document.getElementById('shiftEditModal').classList.add('hidden');
  editingShiftDate = null;
});

// ================================================================
// MONTHLY OVERRIDE
// ================================================================
let ovYear = new Date().getFullYear();
let ovMonth = new Date().getMonth();

function updateOVMonthLabel() {
  const mn = ['January','February','March','April','May','June','July','August','September','October','November','December'];
  document.getElementById('ovMonthLabel').textContent = `${mn[ovMonth]} ${ovYear}`;
}

function getOVKey() {
  return ovYear + '-' + String(ovMonth + 1).padStart(2, '0');
}

function loadOverrideUI() {
  updateOVMonthLabel();
  const mk = getOVKey();
  if (!data.overrides) data.overrides = {};
  const ov = data.overrides[mk];

  // Calculate current values to show as placeholders
  const monthShifts = Object.values(data.shifts).filter(s => s.date && s.date.startsWith(mk));
  let calcTime = 0, calcProd = 0;
  monthShifts.forEach(shift => {
    const t = calcShiftTotal(shift);
    calcTime += t.ar + t.call + t.subspec + t.supervision;
    calcProd += t.prod;
  });

  const timeInput = document.getElementById('overrideTimePoints');
  const prodInput = document.getElementById('overrideProdPoints');
  timeInput.placeholder = `Calculated: ${calcTime.toFixed(1)}`;
  prodInput.placeholder = `Calculated: ${calcProd.toFixed(1)}`;
  timeInput.value = ov && ov.timePoints != null ? ov.timePoints : '';
  prodInput.value = ov && ov.prodPoints != null ? ov.prodPoints : '';

  const status = document.getElementById('overrideStatus');
  if (ov && (ov.timePoints != null || ov.prodPoints != null)) {
    status.innerHTML = '<span style="color:var(--accent2);font-weight:600;">Override active for this month</span>';
  } else {
    status.textContent = '';
  }
}

document.getElementById('ovPrevMonth').addEventListener('click', () => {
  ovMonth--; if (ovMonth < 0) { ovMonth = 11; ovYear--; }
  loadOverrideUI();
});
document.getElementById('ovNextMonth').addEventListener('click', () => {
  ovMonth++; if (ovMonth > 11) { ovMonth = 0; ovYear++; }
  loadOverrideUI();
});

document.getElementById('saveOverrideBtn').addEventListener('click', () => {
  if (!data.overrides) data.overrides = {};
  const mk = getOVKey();
  const timeVal = document.getElementById('overrideTimePoints').value;
  const prodVal = document.getElementById('overrideProdPoints').value;
  const ov = {};
  if (timeVal !== '') ov.timePoints = parseFloat(timeVal);
  if (prodVal !== '') ov.prodPoints = parseFloat(prodVal);
  if (Object.keys(ov).length > 0) {
    data.overrides[mk] = ov;
  } else {
    delete data.overrides[mk];
  }
  saveData(data);
  loadOverrideUI();
  showToast('Override saved');
});

document.getElementById('clearOverrideBtn').addEventListener('click', () => {
  if (!data.overrides) data.overrides = {};
  const mk = getOVKey();
  delete data.overrides[mk];
  saveData(data);
  loadOverrideUI();
  showToast('Override cleared');
});

// ================================================================
// MONTHLY STIPENDS
// ================================================================
let stipMonth = new Date().getMonth();
let stipYear = new Date().getFullYear();

function getStipKey() {
  return stipYear + '-' + String(stipMonth + 1).padStart(2, '0');
}

function updateStipMonthLabel() {
  const monthNames = ['January','February','March','April','May','June','July','August','September','October','November','December'];
  document.getElementById('stipMonthLabel').textContent = monthNames[stipMonth] + ' ' + stipYear;
}

function loadStipendUI() {
  updateStipMonthLabel();
  if (!data.stipends) data.stipends = {};
  const mk = getStipKey();
  const entries = data.stipends[mk] || [];
  const container = document.getElementById('stipendEntries');
  container.innerHTML = '';
  if (entries.length === 0) {
    addStipendRow(container, '', '');
  } else {
    entries.forEach(e => addStipendRow(container, e.label, e.amount));
  }
  updateStipendStatus();
}

function addStipendRow(container, label, amount) {
  const row = document.createElement('div');
  row.style.cssText = 'display:flex;gap:8px;margin-bottom:8px;align-items:center;';
  row.innerHTML = `<input type="text" placeholder="Label (e.g., Med Director)" value="${label}" style="flex:2;padding:8px;border-radius:6px;border:1px solid var(--border);background:var(--surface);color:var(--text);" class="stip-label">
    <input type="number" placeholder="$ Amount" value="${amount}" min="0" step="0.01" style="flex:1;padding:8px;border-radius:6px;border:1px solid var(--border);background:var(--surface);color:var(--text);" class="stip-amount">
    <button type="button" style="background:none;border:none;color:var(--danger);font-size:1.2rem;cursor:pointer;padding:4px 8px;" class="stip-remove">&times;</button>`;
  row.querySelector('.stip-remove').addEventListener('click', () => {
    row.remove();
    if (container.children.length === 0) addStipendRow(container, '', '');
  });
  container.appendChild(row);
}

function updateStipendStatus() {
  const mk = getStipKey();
  const entries = (data.stipends || {})[mk] || [];
  const total = entries.reduce((s, e) => s + (e.amount || 0), 0);
  const status = document.getElementById('stipendStatus');
  if (total > 0) {
    status.innerHTML = `<span style="color:var(--accent2);font-weight:600;">$${total.toLocaleString('en-US', {minimumFractionDigits:2})} in stipends this month</span>`;
  } else {
    status.textContent = '';
  }
}

function getMonthlyStipendTotal(monthKey) {
  if (!data.stipends) return 0;
  const entries = data.stipends[monthKey] || [];
  return entries.reduce((s, e) => s + (e.amount || 0), 0);
}

document.getElementById('stipPrevMonth').addEventListener('click', () => {
  stipMonth--; if (stipMonth < 0) { stipMonth = 11; stipYear--; }
  loadStipendUI();
});
document.getElementById('stipNextMonth').addEventListener('click', () => {
  stipMonth++; if (stipMonth > 11) { stipMonth = 0; stipYear++; }
  loadStipendUI();
});

document.getElementById('addStipendBtn').addEventListener('click', () => {
  addStipendRow(document.getElementById('stipendEntries'), '', '');
});

document.getElementById('saveStipendBtn').addEventListener('click', () => {
  if (!data.stipends) data.stipends = {};
  const mk = getStipKey();
  const rows = document.getElementById('stipendEntries').children;
  const entries = [];
  for (const row of rows) {
    const label = row.querySelector('.stip-label').value.trim();
    const amount = parseFloat(row.querySelector('.stip-amount').value) || 0;
    if (label || amount > 0) entries.push({ label, amount });
  }
  if (entries.length > 0) {
    data.stipends[mk] = entries;
  } else {
    delete data.stipends[mk];
  }
  saveData(data);
  updateStipendStatus();
  showToast('Stipends saved');
});

document.getElementById('clearStipendBtn').addEventListener('click', () => {
  if (!data.stipends) data.stipends = {};
  const mk = getStipKey();
  delete data.stipends[mk];
  saveData(data);
  loadStipendUI();
  showToast('Stipends cleared');
});

// ================================================================
// NAVIGATE TO WORK SCAN
// ================================================================
function navigateToWorkScan() {
  closeDrawer();
  document.querySelectorAll('.bottom-nav button[data-page]').forEach(b => b.classList.remove('active'));
  document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
  const workBtn = document.querySelector('.bottom-nav button[data-page="dataentry"]');
  if (workBtn) workBtn.classList.add('active');
  document.getElementById('page-dataentry').classList.add('active');
  loadDataEntryPage();
  // Open scan collapsible
  setTimeout(() => {
    const body = document.getElementById('deScanBody');
    const arrow = document.getElementById('deScanArrow');
    if (body && (!body.style.maxHeight || body.style.maxHeight === '0px')) {
      body.style.maxHeight = body.scrollHeight + 'px';
      if (arrow) arrow.classList.add('open');
    }
    body && body.scrollIntoView({ behavior: 'smooth', block: 'start' });
  }, 200);
}

// ================================================================
// TUTORIAL
// ================================================================
let tutorialStep = 0;
const TUTORIAL_TOTAL = 5;

function showTutorial() {
  tutorialStep = 0;
  updateTutorialStep();
  document.getElementById('tutorialOverlay').classList.remove('hidden');
}

function closeTutorial() {
  document.getElementById('tutorialOverlay').classList.add('hidden');
}

function updateTutorialStep() {
  const steps = document.querySelectorAll('#tutorialOverlay .tutorial-step');
  steps.forEach((s, i) => s.classList.toggle('active', i === tutorialStep));
  const dots = document.querySelectorAll('#tutorialDots .dot');
  dots.forEach((d, i) => d.classList.toggle('active', i === tutorialStep));
  const backBtn = document.getElementById('tutBackBtn');
  const nextBtn = document.getElementById('tutNextBtn');
  backBtn.style.display = tutorialStep === 0 ? 'none' : '';
  // Step 4 (index 3) has its own option cards — hide Next
  if (tutorialStep === 3) {
    nextBtn.style.display = 'none';
  } else if (tutorialStep === TUTORIAL_TOTAL - 1) {
    nextBtn.style.display = '';
    nextBtn.textContent = 'Get Started';
  } else {
    nextBtn.style.display = '';
    nextBtn.textContent = 'Next';
  }
}

function tutorialNext() {
  if (tutorialStep >= TUTORIAL_TOTAL - 1) {
    finishTutorial();
    return;
  }
  tutorialStep++;
  updateTutorialStep();
}

function tutorialPrev() {
  if (tutorialStep > 0) {
    tutorialStep--;
    updateTutorialStep();
  }
}

function tutorialHistoryChoice(choice) {
  if (choice === 'fresh') {
    tutorialStep = 4;
    updateTutorialStep();
  } else if (choice === 'import') {
    closeTutorial();
    navigateToImportPage();
  } else if (choice === 'override') {
    closeTutorial();
    navigateToHistoryOverrides();
  }
}

function finishTutorial() {
  closeTutorial();
  // Navigate to Work tab
  document.querySelectorAll('.bottom-nav button[data-page]').forEach(b => b.classList.remove('active'));
  document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
  const workBtn = document.querySelector('.bottom-nav button[data-page="dataentry"]');
  if (workBtn) workBtn.classList.add('active');
  document.getElementById('page-dataentry').classList.add('active');
  loadDataEntryPage();
}

function navigateToImportPage() {
  closeDrawer();
  document.querySelectorAll('.bottom-nav button[data-page]').forEach(b => b.classList.remove('active'));
  document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
  document.getElementById('page-import').classList.add('active');
}

function navigateToHistoryOverrides() {
  closeDrawer();
  document.querySelectorAll('.bottom-nav button[data-page]').forEach(b => b.classList.remove('active'));
  document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
  document.getElementById('page-history').classList.add('active');
  loadOverrideUI();

  // Hide everything except the override card
  const histPage = document.getElementById('page-history');
  const cards = histPage.querySelectorAll(':scope > .card');
  cards.forEach((card, i) => {
    if (i > 0) card.style.display = 'none';
  });

  // Force override open, hide collapse header
  const body = document.getElementById('histOverrideBody');
  const arrow = document.getElementById('histOverrideArrow');
  const collapseHeader = body.parentElement.querySelector('.collapse-header');
  if (collapseHeader) collapseHeader.style.display = 'none';
  if (body) body.style.maxHeight = 'none';
  if (arrow) arrow.classList.add('open');

  // Add instruction tip
  let tip = document.getElementById('overrideTutorialTip');
  if (!tip) {
    tip = document.createElement('p');
    tip.id = 'overrideTutorialTip';
    tip.style.cssText = 'font-size:0.8rem;color:var(--primary);margin-bottom:12px;font-weight:600;';
    tip.textContent = 'Use the arrows to switch months and enter your point totals for each.';
    body.querySelector('div').prepend(tip);
  }

  histPage.dataset.tutorialMode = 'true';
}

function exitHistoryTutorialMode() {
  const histPage = document.getElementById('page-history');
  if (!histPage || histPage.dataset.tutorialMode !== 'true') return;
  delete histPage.dataset.tutorialMode;

  // Restore hidden cards
  histPage.querySelectorAll(':scope > .card').forEach(card => {
    card.style.display = '';
  });

  // Restore collapse header and re-collapse
  const body = document.getElementById('histOverrideBody');
  const arrow = document.getElementById('histOverrideArrow');
  const collapseHeader = body.parentElement.querySelector('.collapse-header');
  if (collapseHeader) collapseHeader.style.display = '';
  if (body) body.style.maxHeight = '0';
  if (arrow) arrow.classList.remove('open');

  // Remove tip
  const tip = document.getElementById('overrideTutorialTip');
  if (tip) tip.remove();
}

// ================================================================
// POINT VALUE HISTORY
// ================================================================
function goToPVHistory() {
  // Navigate to compensation page
  document.querySelectorAll('.bottom-nav button[data-page]').forEach(b => b.classList.remove('active'));
  document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
  const compBtn = document.querySelector('.bottom-nav button[data-page="compensation"]');
  if (compBtn) compBtn.classList.add('active');
  document.getElementById('page-compensation').classList.add('active');
  renderProjections();
  // Open the history panel
  const panel = document.getElementById('pvHistoryPanel');
  const btn = document.getElementById('pvHistoryToggle');
  if (panel && panel.style.maxHeight === '0px' || panel && !panel.style.maxHeight) {
    panel.style.maxHeight = panel.scrollHeight + 'px';
    btn.innerHTML = 'History &#9650;';
  }
}

function togglePVHistory() {
  const panel = document.getElementById('pvHistoryPanel');
  const btn = document.getElementById('pvHistoryToggle');
  if (panel.style.maxHeight && panel.style.maxHeight !== '0px') {
    panel.style.maxHeight = '0';
    btn.innerHTML = 'History &#9660;';
  } else {
    panel.style.maxHeight = panel.scrollHeight + 'px';
    btn.innerHTML = 'History &#9650;';
  }
}

function renderPVHistory() {
  const container = document.getElementById('pvHistoryRows');
  if (!container) return;
  const now = new Date();
  const monthNames = ['January','February','March','April','May','June','July','August','September','October','November','December'];
  if (!settings.pointValues) settings.pointValues = {};
  let html = '';
  for (let i = 1; i <= 6; i++) {
    const d = new Date(now.getFullYear(), now.getMonth() - i, 1);
    const mk = d.getFullYear() + '-' + String(d.getMonth()+1).padStart(2,'0');
    const label = monthNames[d.getMonth()] + ' ' + d.getFullYear();
    const val = settings.pointValues[mk];
    const isConfirmed = val != null;
    const displayVal = isConfirmed ? val : '';
    const statusText = isConfirmed ? '<span style="color:var(--accent);font-weight:600;">Confirmed</span>' : '<span style="color:var(--text-dim);">Estimate: $' + (settings.pointValue || 0).toFixed(2) + '</span>';
    html += '<div style="display:flex;align-items:center;gap:8px;margin-bottom:8px;">';
    html += '<span style="font-size:0.82rem;min-width:100px;">' + label + '</span>';
    html += '<input type="number" data-pvmonth="' + mk + '" min="0" step="0.01" placeholder="$/pt" value="' + displayVal + '" style="max-width:100px;padding:6px 8px;border-radius:6px;border:1px solid var(--border);background:var(--surface);color:var(--text);font-size:0.85rem;">';
    html += '<span style="font-size:0.72rem;">' + statusText + '</span>';
    html += '</div>';
  }
  container.innerHTML = html;
}

document.addEventListener('click', function(e) {
  if (e.target && e.target.id === 'savePVHistoryBtn') {
    if (!settings.pointValues) settings.pointValues = {};
    const inputs = document.querySelectorAll('[data-pvmonth]');
    inputs.forEach(inp => {
      const mk = inp.dataset.pvmonth;
      const val = inp.value.trim();
      if (val !== '') {
        settings.pointValues[mk] = parseFloat(val);
      } else {
        delete settings.pointValues[mk];
      }
    });
    prunePointValues();
    saveSettings(settings);
    renderPVHistory();
    // Re-render revenue charts with updated values
    renderMonthlyChart();
    renderStabilization();
    renderProjectedAnnual();
    renderPipelineChart();
    const status = document.getElementById('pvHistoryStatus');
    if (status) { status.innerHTML = '<span style="color:var(--accent);">Point values saved</span>'; setTimeout(() => { status.textContent = ''; }, 3000); }
  }
});

function dismissPVReminder() {
  window._pvReminderDismissed = true;
  const today = document.getElementById('todayPVReminder');
  const comp = document.getElementById('pvReminderBanner');
  if (today) today.classList.add('hidden');
  if (comp) comp.classList.add('hidden');
}

function checkOpenLaborReminder() {
  const banner = document.getElementById('openLaborReminder');
  if (!banner) return;
  const now = new Date();
  const openCases = data.cases.filter(c => {
    if (c.caseType !== 'labor_epidural' || !c.startTime || c.endTime) return false;
    const caseDate = new Date(c.shiftDate + 'T' + c.startTime + ':00');
    return (now - caseDate) > 24 * 60 * 60 * 1000;
  });
  if (openCases.length > 0) {
    const dates = [...new Set(openCases.map(c => formatDate(c.shiftDate)))];
    const textEl = document.getElementById('openLaborReminderText');
    textEl.textContent = openCases.length === 1
      ? `Open labor epidural from ${dates[0]} needs an end time.`
      : `${openCases.length} open labor epidurals need end times (${dates.join(', ')}).`;
    banner.classList.remove('hidden');
    banner.style.display = 'flex';
  } else {
    banner.classList.add('hidden');
  }
}

function checkPVReminder() {
  const todayBanner = document.getElementById('todayPVReminder');
  const compBanner = document.getElementById('pvReminderBanner');
  if (window._pvReminderDismissed) {
    if (todayBanner) todayBanner.classList.add('hidden');
    if (compBanner) compBanner.classList.add('hidden');
    return;
  }
  const now = new Date();
  if (now.getDate() < 20) {
    if (todayBanner) todayBanner.classList.add('hidden');
    if (compBanner) compBanner.classList.add('hidden');
    return;
  }
  const prevMonth = new Date(now.getFullYear(), now.getMonth() - 1, 1);
  const prevKey = prevMonth.getFullYear() + '-' + String(prevMonth.getMonth()+1).padStart(2,'0');
  const monthNames = ['January','February','March','April','May','June','July','August','September','October','November','December'];
  if (!settings.pointValues || settings.pointValues[prevKey] == null) {
    const msg = monthNames[prevMonth.getMonth()] + ' $/point hasn\'t been confirmed yet.';
    if (todayBanner) {
      document.getElementById('todayPVReminderText').textContent = msg;
      todayBanner.classList.remove('hidden');
      todayBanner.style.display = 'flex';
    }
    if (compBanner) {
      document.getElementById('pvReminderText').textContent = msg;
      compBanner.classList.remove('hidden');
      compBanner.style.display = 'flex';
    }
  } else {
    if (todayBanner) todayBanner.classList.add('hidden');
    if (compBanner) compBanner.classList.add('hidden');
  }
}

// ================================================================
// PROJECTIONS TAB
// ================================================================
function renderProjections() {
  renderMonthlyPace();
  renderStabilization();
  renderPipelineChart();
  renderProjectedAnnual();
  renderMonthlyChart();
  loadStipendUI();
  renderPVHistory();
  checkPVReminder();
}

function getMonthlyTotals() {
  const months = {};
  // First compute from shift data
  const monthBreakdowns = {};
  Object.values(data.shifts).forEach(shift => {
    const mk = shift.date.substring(0, 7);
    if (!monthBreakdowns[mk]) monthBreakdowns[mk] = { time: 0, prod: 0 };
    const t = calcShiftTotal(shift);
    monthBreakdowns[mk].time += t.ar + t.call + t.subspec + t.supervision;
    monthBreakdowns[mk].prod += t.prod;
  });
  // Apply overrides where present
  const overrides = (data.overrides || {});
  Object.keys(monthBreakdowns).forEach(mk => {
    const ov = overrides[mk];
    let time = monthBreakdowns[mk].time;
    let prod = monthBreakdowns[mk].prod;
    if (ov) {
      if (ov.timePoints != null) time = ov.timePoints;
      if (ov.prodPoints != null) prod = ov.prodPoints;
    }
    months[mk] = round2(time + prod);
  });
  // Also include override-only months (where no shifts exist but override was set)
  Object.keys(overrides).forEach(mk => {
    if (!months[mk]) {
      const ov = overrides[mk];
      months[mk] = round2((ov.timePoints || 0) + (ov.prodPoints || 0));
    }
  });
  return months;
}

function renderMonthlyChart() {
  const totals = getMonthlyTotals();
  const sortedKeys = Object.keys(totals).sort();
  const last6 = sortedKeys.slice(-6);
  const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
  const labels = last6.map(k => { const [y,m] = k.split('-'); return monthNames[parseInt(m)-1] + ' ' + y; });
  const rawValues = last6.map(k => round2(totals[k]));
  const values = monthlyShowDollars
    ? last6.map((k, i) => { const pv = getPointValueForMonth(k); return round2(rawValues[i] * (pv || 0)); })
    : rawValues;
  const avg = values.length > 0 ? round2(values.reduce((a, b) => a + b, 0) / values.length) : 0;
  const prefix = monthlyShowDollars ? '$' : '';
  const suffix = monthlyShowDollars ? '' : ' pts';
  const ctx = document.getElementById('monthlyChart').getContext('2d');
  if (monthlyChart) monthlyChart.destroy();
  const datasets = [
    { label: monthlyShowDollars ? 'Revenue' : 'Total Points', data: values, backgroundColor: 'rgba(59,130,246,0.7)', borderColor: '#3b82f6', borderWidth: 1, borderRadius: 4 }
  ];
  if (values.length > 1) {
    datasets.push({
      label: 'Average', data: values.map(() => avg), type: 'line',
      borderColor: '#f59e0b', borderWidth: 2, borderDash: [6, 3],
      pointRadius: 0, fill: false
    });
  }
  monthlyChart = new Chart(ctx, {
    type: 'bar',
    data: { labels, datasets },
    options: {
      responsive: true, maintainAspectRatio: false,
      plugins: { legend: { display: values.length > 1, labels: { color: '#94a3b8' } } },
      scales: {
        y: { beginAtZero: true, ticks: { color: '#94a3b8', callback: function(v) { return monthlyShowDollars ? '$' + v.toLocaleString() : v; } }, grid: { color: 'rgba(71,85,105,0.3)' } },
        x: { ticks: { color: '#94a3b8' }, grid: { display: false } }
      }
    }
  });
  const summaryEl = document.getElementById('monthlyChartSummary');
  if (monthlyShowDollars) {
    summaryEl.innerHTML = values.length > 0 ? `6-Month Avg: $${avg.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}` : '';
  } else {
    let summaryText = values.length > 0 ? `6-Month Avg: ${avg.toFixed(1)} pts` : '';
    if (last6.length > 0) {
      let totalRevenue = 0;
      let hasAnyPv = false;
      last6.forEach((k, i) => {
        const mpv = getPointValueForMonth(k);
        if (mpv > 0) { totalRevenue += rawValues[i] * mpv; hasAnyPv = true; }
      });
      if (hasAnyPv && totalRevenue > 0) {
        const avgRevenue = totalRevenue / last6.length;
        summaryText += ` &nbsp;|&nbsp; Avg Monthly Revenue: $${avgRevenue.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
      }
    }
    summaryEl.innerHTML = summaryText;
  }
  document.getElementById('monthlyTrendToggle').textContent = monthlyShowDollars ? 'pts' : '$';
}

function toggleStabBreakdown() {
  const panel = document.getElementById('stabBreakdown');
  const link = document.getElementById('stabBreakdownToggle');
  if (panel.style.maxHeight && panel.style.maxHeight !== '0px') {
    panel.style.maxHeight = '0';
    link.innerHTML = 'Show breakdown &#9660;';
  } else {
    panel.style.maxHeight = panel.scrollHeight + 'px';
    link.innerHTML = 'Hide breakdown &#9650;';
  }
}

function renderStabilization() {
  const now = new Date();
  const mt = getMonthlyTotals();
  const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
  function mk(offset) { const d = new Date(now.getFullYear(), now.getMonth() - offset, 1); return d.getFullYear() + '-' + String(d.getMonth()+1).padStart(2,'0'); }
  const weights = [0.10, 0.40, 0.25, 0.15, 0.10];
  const labels = ['This month', 'Last month', '2 months ago', '3 months ago', '4 months ago'];
  const vals = [0,1,2,3,4].map(i => mt[mk(i)] || 0);
  const raw = vals[0];
  const weighted = round2(weights.reduce((sum, w, i) => sum + w * vals[i], 0));
  document.getElementById('stabRaw').textContent = raw.toFixed(1);
  document.getElementById('stabWeighted').textContent = weighted.toFixed(1);

  // Render breakdown
  let bdHtml = '<div style="font-size:0.75rem;color:var(--text-dim);margin-bottom:6px;">How the blend is calculated:</div>';
  weights.forEach((w, i) => {
    const pct = (w * 100).toFixed(0);
    const mDate = new Date(now.getFullYear(), now.getMonth() - i, 1);
    const mLabel = monthNames[mDate.getMonth()] + ' ' + mDate.getFullYear();
    const contribution = round2(w * vals[i]);
    bdHtml += `<div style="display:flex;justify-content:space-between;align-items:center;padding:3px 0;font-size:0.8rem;">`;
    bdHtml += `<span style="color:var(--text-dim);">${mLabel} <span style="opacity:0.6;">(${pct}%)</span></span>`;
    bdHtml += `<span>${vals[i].toFixed(1)} &times; ${pct}% = <strong>${contribution.toFixed(1)}</strong></span>`;
    bdHtml += `</div>`;
  });
  document.getElementById('stabBreakdown').innerHTML = bdHtml;
  const currentMonthKey = mk(0);
  const pv = getPointValueForMonth(currentMonthKey);
  const decAdv = settings.decemberAdvance !== false;
  const paycheckLabel = document.getElementById('stabPaycheckLabel');

  if (decAdv && now.getMonth() === 0) {
    // January: paycheck was already received in December
    document.getElementById('stabPaycheck').textContent = '$0.00';
    paycheckLabel.textContent = 'January paycheck received in December';
  } else if (pv && pv > 0) {
    const currentStipend = getMonthlyStipendTotal(mk(0));
    let paycheck = weighted * pv + currentStipend;

    if (decAdv && now.getMonth() === 11) {
      // December: add January's advance paycheck
      function mkFwd(month) { const d = new Date(now.getFullYear() + 1, month, 1); return d.getFullYear() + '-' + String(d.getMonth()+1).padStart(2,'0'); }
      const janWeighted = round2(0.10 * (mt[mkFwd(0)]||0) + 0.40 * raw + 0.25 * (mt[mk(1)]||0) + 0.15 * (mt[mk(2)]||0) + 0.10 * (mt[mk(3)]||0));
      const decStipend = getMonthlyStipendTotal(mk(0)); // Dec stipend -> Jan paycheck
      const janPv = getPointValueForMonth(mkFwd(0));
      paycheck += janWeighted * janPv + decStipend;
      paycheckLabel.textContent = "Projected Dec paycheck + Jan advance";
    } else {
      paycheckLabel.textContent = "Projected next month\u2019s paycheck";
    }

    document.getElementById('stabPaycheck').textContent = '$' + paycheck.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
  } else {
    document.getElementById('stabPaycheck').innerHTML = '&mdash;';
    paycheckLabel.textContent = "Projected next month\u2019s paycheck";
  }

  // Current month's paycheck (blend shifted back 1 month)
  const curEl = document.getElementById('stabCurrentPaycheck');
  const lastMonthKey = mk(1);
  const lastPv = getPointValueForMonth(lastMonthKey);
  if (decAdv && now.getMonth() === 0) {
    curEl.textContent = 'This month: received in Dec advance';
  } else if (lastPv && lastPv > 0) {
    const curVals = [1,2,3,4,5].map(i => mt[mk(i)] || 0);
    const curWeighted = round2(weights.reduce((sum, w, i) => sum + w * curVals[i], 0));
    const curStipend = getMonthlyStipendTotal(mk(1));
    const curPaycheck = curWeighted * lastPv + curStipend;
    curEl.textContent = 'This month: $' + curPaycheck.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
  } else {
    curEl.textContent = '';
  }
}

// ================================================================
// PROJECTED ANNUAL INCOME
// ================================================================
function renderProjectedAnnual() {
  const mt = getMonthlyTotals();
  const now = new Date();
  const thisYear = now.getFullYear();
  function mk(offset) { const d = new Date(now.getFullYear(), now.getMonth() - offset, 1); return d.getFullYear() + '-' + String(d.getMonth()+1).padStart(2,'0'); }
  const last3 = [mt[mk(0)]||0, mt[mk(1)]||0, mt[mk(2)]||0].filter(v => v > 0);
  const avg = last3.length > 0 ? last3.reduce((a,b)=>a+b,0) / last3.length : 0;
  document.getElementById('projRollingAvg').textContent = avg.toFixed(1);
  const globalPv = settings.pointValue;

  // YTD revenue: sum each month's pts * that month's confirmed point value
  let ytdRevenue = 0;
  let ytdPts = 0;
  let ytdMonths = 0;
  let ytdStipends = 0;
  for (let m = 0; m <= now.getMonth(); m++) {
    const key = thisYear + '-' + String(m + 1).padStart(2, '0');
    if (mt[key]) {
      ytdPts += mt[key];
      ytdRevenue += mt[key] * getPointValueForMonth(key);
      ytdMonths++;
    }
    ytdStipends += getMonthlyStipendTotal(key);
  }
  ytdRevenue += ytdStipends;
  const remainingMonths = 12 - now.getMonth() - 1; // full months left after current

  // Average monthly stipend for projection
  const stipMonths = [];
  for (let i = 0; i < 3; i++) {
    const key = mk(i);
    const s = getMonthlyStipendTotal(key);
    if (s > 0) stipMonths.push(s);
  }
  const avgStipend = stipMonths.length > 0 ? stipMonths.reduce((a,b)=>a+b,0) / stipMonths.length : 0;

  const pv = globalPv; // use global estimate for projections of future months
  if (pv && pv > 0 && avg > 0) {
    const annualPts = avg * 12 * pv;
    const annualStipend = avgStipend * 12;
    const annual = annualPts + annualStipend;
    const projRemaining = avg * remainingMonths * pv + avgStipend * remainingMonths;
    document.getElementById('projAnnualIncome').textContent = '$' + annual.toLocaleString('en-US', { maximumFractionDigits: 0 });
    document.getElementById('projYTDRevenue').textContent = '$' + ytdRevenue.toLocaleString('en-US', { maximumFractionDigits: 0 });
    document.getElementById('projRemaining').textContent = '$' + projRemaining.toLocaleString('en-US', { maximumFractionDigits: 0 });
    let detail = `${ytdPts.toFixed(0)} pts earned YTD across ${ytdMonths} month${ytdMonths !== 1 ? 's' : ''} \u2022 ${remainingMonths} month${remainingMonths !== 1 ? 's' : ''} remaining`;
    if (ytdStipends > 0) detail += ` \u2022 $${ytdStipends.toLocaleString('en-US', {maximumFractionDigits:0})} stipends YTD`;
    document.getElementById('projYTDDetail').textContent = detail;
  } else {
    document.getElementById('projAnnualIncome').innerHTML = '&mdash;';
    document.getElementById('projYTDRevenue').innerHTML = '&mdash;';
    document.getElementById('projRemaining').innerHTML = '&mdash;';
    document.getElementById('projYTDDetail').textContent = pv ? '' : 'Set $/point above to see revenue projections';
  }
}

function renderMonthlyPace() {
  const now = new Date();
  const thisPrefix = now.getFullYear() + '-' + String(now.getMonth() + 1).padStart(2, '0');
  const dayOfMonth = now.getDate();
  const daysInMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0).getDate();

  // Current month's shifts
  const monthShifts = Object.values(data.shifts).filter(s => s.date.startsWith(thisPrefix));
  let currentPts = 0;
  monthShifts.forEach(s => { currentPts += calcShiftTotal(s).total; });
  currentPts = round2(currentPts);

  // Count vacation days this month
  const vacationDays = monthShifts.filter(s => s.assignmentType === 'vacation');
  const totalVacDays = vacationDays.length;
  const vacDaysPassed = vacationDays.filter(s => parseInt(s.date.split('-')[2]) <= dayOfMonth).length;
  const workingDaysInMonth = daysInMonth - totalVacDays;
  const workingDaysElapsed = dayOfMonth - vacDaysPassed;
  const vacationRatio = workingDaysInMonth / daysInMonth; // fraction of month that's working

  // Build cumulative-by-day curves for prior months
  const priorMonthCurves = [];
  const mt = getMonthlyTotals();
  for (let offset = 1; offset <= 6; offset++) {
    const d = new Date(now.getFullYear(), now.getMonth() - offset, 1);
    const key = d.getFullYear() + '-' + String(d.getMonth() + 1).padStart(2, '0');
    if (!mt[key]) continue;

    const mDays = new Date(d.getFullYear(), d.getMonth() + 1, 0).getDate();
    const shifts = Object.values(data.shifts).filter(s => s.date.startsWith(key));
    if (shifts.length === 0) continue;

    const dailyPts = new Array(mDays + 1).fill(0);
    shifts.forEach(s => {
      const day = parseInt(s.date.split('-')[2]);
      dailyPts[day] += calcShiftTotal(s).total;
    });

    const cumulative = new Array(mDays + 1).fill(0);
    for (let i = 1; i <= mDays; i++) {
      cumulative[i] = cumulative[i - 1] + dailyPts[i];
    }

    priorMonthCurves.push({ key, days: mDays, cumulative, total: round2(cumulative[mDays]) });
  }

  // Calculate expected points by now and target end-of-month
  // Use working-day fraction instead of calendar fraction to account for vacation
  let expectedByNow = 0;
  let avgMonthEnd = 0;
  if (priorMonthCurves.length > 0) {
    let sumAtDay = 0;
    let sumTotal = 0;
    priorMonthCurves.forEach(curve => {
      // Map effective working-day fraction to prior month's timeline
      const fraction = workingDaysInMonth > 0 ? workingDaysElapsed / workingDaysInMonth : 0;
      const mappedDay = fraction * curve.days;
      const lower = Math.floor(mappedDay);
      const upper = Math.min(Math.ceil(mappedDay), curve.days);
      const frac = mappedDay - lower;
      const interpolated = lower >= 1
        ? curve.cumulative[lower] * (1 - frac) + curve.cumulative[upper] * frac
        : curve.cumulative[upper] * frac;
      sumAtDay += interpolated;
      sumTotal += curve.total;
    });
    // Scale prior month averages by vacation ratio (fewer working days = lower expected total)
    avgMonthEnd = round2((sumTotal / priorMonthCurves.length) * vacationRatio);
    expectedByNow = round2((sumAtDay / priorMonthCurves.length) * vacationRatio);
  }

  // Project end-of-month
  let projected;
  if (expectedByNow > 0) {
    projected = round2(currentPts * (avgMonthEnd / expectedByNow));
  } else {
    const fractionElapsed = workingDaysInMonth > 0 ? workingDaysElapsed / workingDaysInMonth : 0;
    projected = fractionElapsed > 0 ? round2(currentPts / fractionElapsed) : 0;
  }

  document.getElementById('paceCurrentPts').textContent = currentPts.toFixed(1) + ' pts';
  document.getElementById('paceProjected').textContent = projected.toFixed(0) + ' pts';

  // Progress bar
  let pct = 0;
  let label = '';
  if (expectedByNow > 0) {
    pct = Math.min(100, round2(currentPts / avgMonthEnd * 100));
    const diff = round2(currentPts - expectedByNow);
    const nMonths = priorMonthCurves.length;
    let vacNote = totalVacDays > 0 ? ` \u2022 ${totalVacDays}d vacation` : '';
    label = `${pct.toFixed(0)}% of adj avg (${avgMonthEnd.toFixed(0)} pts) \u2022 ${diff >= 0 ? '+' : ''}${diff.toFixed(0)} pts vs pace (${nMonths}-mo)${vacNote}`;
  } else {
    pct = Math.min(100, (dayOfMonth / daysInMonth) * 100);
    label = `Day ${dayOfMonth} of ${daysInMonth} \u2022 No prior data for comparison`;
  }
  document.getElementById('paceBar').style.width = pct + '%';
  let paceColor = 'var(--primary)';
  if (expectedByNow > 0) {
    if (currentPts >= expectedByNow) paceColor = 'var(--accent)';
    else if (currentPts >= expectedByNow * 0.9) paceColor = 'var(--accent2)';
    else paceColor = 'var(--danger)';
  }
  document.getElementById('paceBar').style.background = paceColor;
  document.getElementById('paceLabel').textContent = label;
}

function renderPipelineChart() {
  const now = new Date();
  const mt = getMonthlyTotals();
  const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
  const pv = settings.pointValue || 0;

  // Stabilization weights: paycheck for month M uses:
  //   10% of M + 40% of M-1 + 25% of M-2 + 15% of M-3 + 10% of M-4
  const weights = [0.10, 0.40, 0.25, 0.15, 0.10];

  // Helper: get month key like "2026-02"
  function mkKey(year, month) {
    const d = new Date(year, month, 1);
    return d.getFullYear() + '-' + String(d.getMonth() + 1).padStart(2, '0');
  }

  // Calculate rolling avg from recent known months for optional projections
  const includeProjections = document.getElementById('pipelineProjectToggle').checked;
  const recentKnown = [];
  for (let i = 0; i < 3; i++) {
    const k = mkKey(now.getFullYear(), now.getMonth() - i);
    if (mt[k]) recentKnown.push(mt[k]);
  }
  const avgProjection = includeProjections && recentKnown.length > 0
    ? recentKnown.reduce((a, b) => a + b, 0) / recentKnown.length : 0;

  // For each of the next 5 months, compute the full stabilization-weighted paycheck
  // using real data where available; projected avg only when toggle is on
  const labels = [];
  const realValues = [];      // solid portion (from recorded data)
  const projectedValues = []; // translucent portion (from rolling avg)
  const breakdowns = [];

  for (let target = 0; target < 5; target++) {
    const targetDate = new Date(now.getFullYear(), now.getMonth() + target, 1);
    const label = monthNames[targetDate.getMonth()] + ' ' + targetDate.getFullYear();
    labels.push(target === 0 ? label + ' (current)' : label);

    // For this target month's paycheck, we need months: target, target-1, target-2, target-3, target-4
    let realPts = 0;
    let projPts = 0;
    const bd = [];
    for (let w = 0; w < 5; w++) {
      const srcDate = new Date(now.getFullYear(), now.getMonth() + target - w, 1);
      const srcKey = mkKey(srcDate.getFullYear(), srcDate.getMonth());
      const srcLabel = monthNames[srcDate.getMonth()] + ' ' + srcDate.getFullYear().toString().slice(2);

      const isCurrentOrPast = srcDate <= now || srcKey === mkKey(now.getFullYear(), now.getMonth());
      const isProjected = !mt[srcKey] && !isCurrentOrPast;
      let srcPts;
      if (mt[srcKey] !== undefined) {
        srcPts = mt[srcKey];
      } else if (isCurrentOrPast) {
        srcPts = 0;
      } else {
        srcPts = avgProjection;
      }

      const contribution = round2(srcPts * weights[w]);
      if (isProjected) {
        projPts += contribution;
      } else {
        realPts += contribution;
      }
      bd.push({ label: srcLabel, weight: weights[w], pts: round2(srcPts), contribution, isProjected });
    }

    realValues.push(round2(realPts));
    projectedValues.push(round2(projPts));
    breakdowns.push(bd);
  }

  // Add stipends: each target month's paycheck includes the previous month's stipend
  const stipendValues = [];
  for (let target = 0; target < 5; target++) {
    const stipKey = mkKey(now.getFullYear(), now.getMonth() + target - 1);
    stipendValues.push(getMonthlyStipendTotal(stipKey));
  }

  // December advance: December gets January's paycheck added, January becomes $0
  const decAdv = settings.decemberAdvance !== false;
  const decAdvFlags = []; // track which months are affected for tooltip
  for (let target = 0; target < 5; target++) {
    const targetDate = new Date(now.getFullYear(), now.getMonth() + target, 1);
    const targetMonth = targetDate.getMonth();
    decAdvFlags.push({ isDec: targetMonth === 11, isJan: targetMonth === 0 });

    if (decAdv && targetMonth === 0) {
      // January: $0 (already received in December)
      realValues[target] = 0;
      projectedValues[target] = 0;
      stipendValues[target] = 0;
    }

    if (decAdv && targetMonth === 11) {
      // December: add January's paycheck as advance
      const janDate = new Date(targetDate.getFullYear() + 1, 0, 1);
      let janReal = 0, janProj = 0;
      for (let w = 0; w < 5; w++) {
        const srcDate = new Date(janDate.getFullYear(), janDate.getMonth() - w, 1);
        const srcKey = mkKey(srcDate.getFullYear(), srcDate.getMonth());
        const isCurrentOrPast = srcDate <= now || srcKey === mkKey(now.getFullYear(), now.getMonth());
        const isProjected = !mt[srcKey] && !isCurrentOrPast;
        const srcPts = mt[srcKey] !== undefined ? mt[srcKey] : (isCurrentOrPast ? 0 : avgProjection);
        const contribution = round2(srcPts * weights[w]);
        if (isProjected) janProj += contribution; else janReal += contribution;
      }
      realValues[target] += round2(janReal);
      projectedValues[target] += round2(janProj);
      // Add December's stipend → January paycheck (now included in December)
      const janStipKey = mkKey(targetDate.getFullYear(), 11); // Dec stipend → Jan paycheck
      stipendValues[target] += getMonthlyStipendTotal(janStipKey);
    }
  }

  // Build per-target point values for each bar
  const targetPvs = [];
  for (let target = 0; target < 5; target++) {
    const targetDate = new Date(now.getFullYear(), now.getMonth() + target, 1);
    const targetKey = mkKey(targetDate.getFullYear(), targetDate.getMonth());
    targetPvs.push(getPointValueForMonth(targetKey));
  }

  const ctx = document.getElementById('pipelineChart').getContext('2d');
  if (pipelineChart) pipelineChart.destroy();

  const useDollars = pv > 0;
  const realData = useDollars ? realValues.map((v, i) => round2(v * targetPvs[i] + stipendValues[i])) : realValues;
  const projData = useDollars ? projectedValues.map((v, i) => round2(v * targetPvs[i])) : projectedValues;
  const hasAnyProjections = projectedValues.some(v => v > 0);

  const datasets = [{
    label: useDollars ? 'Recorded ($)' : 'Recorded Data',
    data: realData,
    backgroundColor: '#10b981',
    borderWidth: 0,
    borderRadius: hasAnyProjections ? 0 : 4
  }];

  if (hasAnyProjections) {
    datasets.push({
      label: useDollars ? 'Projected ($)' : 'Projected (3-mo avg)',
      data: projData,
      backgroundColor: 'rgba(245,158,11,0.35)',
      borderWidth: 0,
      borderRadius: 4
    });
  }

  pipelineChart = new Chart(ctx, {
    type: 'bar',
    data: { labels, datasets },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: { display: hasAnyProjections, labels: { color: '#94a3b8', boxWidth: 12, padding: 12 } },
        tooltip: {
          callbacks: {
            title: ctx => ctx[0].label,
            afterBody: function(ctx) {
              const idx = ctx[0].dataIndex;
              const flags = decAdvFlags[idx];
              if (decAdv && flags.isJan) return ['  $0 \u2014 advanced in December'];
              const bd = breakdowns[idx];
              const lines = bd.map(b => {
                const pct = (b.weight * 100).toFixed(0);
                const proj = b.isProjected ? ' (est)' : '';
                return `  ${pct}% \u00d7 ${b.pts.toFixed(0)} pts${proj} (${b.label}) = ${b.contribution.toFixed(1)}`;
              });
              const total = round2(realValues[idx] + projectedValues[idx]);
              const stip = stipendValues[idx];
              if (useDollars) {
                const tpv = targetPvs[idx];
                let line = `  Total: ${total.toFixed(1)} pts \u2192 $${round2(total * tpv).toLocaleString('en-US', {maximumFractionDigits:0})}`;
                if (stip > 0) line += ` + $${stip.toLocaleString('en-US', {maximumFractionDigits:0})} stipend`;
                if (flags.isDec) line += ' (incl. Jan advance)';
                lines.push(line);
              }
              return lines;
            }
          }
        }
      },
      scales: {
        y: {
          beginAtZero: true,
          stacked: true,
          ticks: { color: '#94a3b8', callback: v => useDollars ? '$' + v.toLocaleString() : v },
          grid: { color: 'rgba(71,85,105,0.3)' }
        },
        x: { stacked: true, ticks: { color: '#94a3b8', font: { size: 10 } }, grid: { display: false } }
      }
    }
  });

  // Summary — next paycheck date and amount
  const currentPts = mt[mkKey(now.getFullYear(), now.getMonth())] || 0;
  // Paid on the 20th: if before the 20th, next payday is this month's 20th;
  // if on/after the 20th, next payday is next month's 20th
  const nextPayDate = now.getDate() < 20
    ? new Date(now.getFullYear(), now.getMonth(), 20)
    : new Date(now.getFullYear(), now.getMonth() + 1, 20);
  const nextPayDateStr = monthNames[nextPayDate.getMonth()] + ' 20, ' + nextPayDate.getFullYear();
  let summary = `Current month: ${currentPts.toFixed(0)} pts`;
  if (useDollars) {
    const nextPaycheck = round2((realValues[0] + projectedValues[0]) * targetPvs[0] + stipendValues[0]);
    const isCurrentJan = decAdv && now.getMonth() === 0;
    if (isCurrentJan) {
      summary += ' \u2022 Next paycheck: $0 (advanced in Dec)';
    } else {
      summary += ` \u2022 Next paycheck (${nextPayDateStr}): $${nextPaycheck.toLocaleString('en-US', {maximumFractionDigits: 0})}`;
      if (decAdv && now.getMonth() === 11) summary += ' (incl. Jan)';
    }
  } else {
    summary += ` \u2022 Next paycheck: ${nextPayDateStr}`;
  }
  document.getElementById('pipelineSummary').textContent = summary;

  // Earnings not yet received
  const unreceivedEl = document.getElementById('pipelineUnreceived');
  if (useDollars) {
    let totalUnreceived = 0;
    for (let i = 0; i < 5; i++) {
      totalUnreceived += realData[i];
    }
    totalUnreceived = round2(totalUnreceived);
    unreceivedEl.innerHTML = `<div style="font-size:1.1rem;font-weight:700;color:var(--accent2);">$${totalUnreceived.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</div><div style="font-size:0.75rem;color:var(--text-dim);margin-top:2px;">Total earnings not yet received</div>`;
  } else {
    unreceivedEl.innerHTML = '';
  }
}

let activeAssignDataTab = 'totals';

function switchAssignDataTab(tab) {
  activeAssignDataTab = tab;
  document.getElementById('adTabTotals').classList.toggle('active', tab === 'totals');
  document.getElementById('adTabDOW').classList.toggle('active', tab === 'dow');
  document.getElementById('adTabEfficiency').classList.toggle('active', tab === 'efficiency');
  document.getElementById('adTabWorkerBee').classList.toggle('active', tab === 'workerBee');
  renderAssignData();
}

function renderAssignData() {
  const el = document.getElementById('assignDataContent');
  if (activeAssignDataTab === 'totals') {
    el.innerHTML = buildAvgShiftTotals();
  } else if (activeAssignDataTab === 'dow') {
    el.innerHTML = buildDayOfWeek();
  } else if (activeAssignDataTab === 'efficiency') {
    el.innerHTML = buildShiftEfficiency();
  } else {
    el.innerHTML = buildWorkerBeeAvg();
  }
}

function buildAvgShiftTotals() {
  const groups = {};
  Object.values(data.shifts).forEach(shift => {
    const t = calcShiftTotal(shift).total;
    const type = shift.assignmentType;
    if (!groups[type]) groups[type] = { totalPts: 0, count: 0 };
    groups[type].totalPts += t;
    groups[type].count++;
  });
  const ranked = Object.entries(groups)
    .map(([type, g]) => ({ name: getAssignmentTypeName(type), avgPts: round2(g.totalPts / g.count), count: g.count }))
    .sort((a, b) => b.avgPts - a.avgPts);
  let html = '';
  if (ranked.length > 0) {
    html += '<div style="font-size:0.75rem;color:var(--text-dim);margin-bottom:8px;">Average total points per shift (AR + production + call)</div>';
    ranked.forEach(r => {
      html += `<div class="efficiency-item"><span class="eff-label">${escHtml(r.name)} <span style="color:var(--text-dim);font-size:0.75rem;">(${r.count} shift${r.count !== 1 ? 's' : ''})</span></span><span class="eff-value" style="color:var(--primary);">${r.avgPts.toFixed(1)}</span></div>`;
    });
  }
  return html || '<p style="font-size:0.85rem;color:var(--text-dim);">No shift data yet.</p>';
}

function buildShiftEfficiency() {
  const groups = {};
  Object.values(data.shifts).forEach(shift => {
    const hrs = calcShiftHours(shift);
    if (hrs <= 0) return;
    const total = calcShiftTotal(shift).total;
    const type = shift.assignmentType;
    if (!groups[type]) groups[type] = { totalPts: 0, totalHrs: 0, count: 0 };
    groups[type].totalPts += total;
    groups[type].totalHrs += hrs;
    groups[type].count++;
  });
  const ranked = Object.entries(groups)
    .filter(([, g]) => g.count >= 1)
    .map(([type, g]) => ({ name: getAssignmentTypeName(type), ptsPerHr: round2(g.totalPts / g.totalHrs), count: g.count }))
    .sort((a, b) => b.ptsPerHr - a.ptsPerHr);
  let html = '';
  if (ranked.length > 0) {
    html += '<div style="font-size:0.75rem;color:var(--text-dim);margin-bottom:8px;">Points per hour by shift type — most to least efficient</div>';
    ranked.forEach(r => {
      html += `<div class="efficiency-item"><span class="eff-label">${escHtml(r.name)} <span style="color:var(--text-dim);font-size:0.75rem;">(${r.count} shift${r.count !== 1 ? 's' : ''})</span></span><span class="eff-value" style="color:var(--primary);">${r.ptsPerHr.toFixed(1)}</span></div>`;
    });
  }
  return html || '<p style="font-size:0.85rem;color:var(--text-dim);">No shift data yet.</p>';
}

function buildWorkerBeeAvg() {
  const groups = {};
  Object.values(data.shifts).forEach(shift => {
    const cal = data.calendarAssignments[shift.date];
    if (!cal || !cal.label) return;
    const label = cal.label;
    const pts = calcShiftTotal(shift).total;
    const hrs = calcShiftHours(shift);
    if (!groups[label]) groups[label] = { totalPts: 0, totalHrs: 0, count: 0 };
    groups[label].totalPts += pts;
    groups[label].totalHrs += hrs;
    groups[label].count++;
  });
  const ranked = Object.entries(groups)
    .filter(([, g]) => g.totalHrs > 0)
    .map(([label, g]) => ({
      label,
      avgPts: round2(g.totalPts / g.count),
      avgHrs: round2(g.totalHrs / g.count),
      ptsPerHr: round2(g.totalPts / g.totalHrs),
      count: g.count
    }))
    .sort((a, b) => b.avgPts - a.avgPts);
  let html = '';
  if (ranked.length > 0) {
    html += '<div style="font-size:0.75rem;color:var(--text-dim);margin-bottom:8px;">Calendar assignments — sorted by average total points</div>';
    ranked.forEach(r => {
      html += `<div class="efficiency-item" style="flex-wrap:wrap;gap:2px;">`;
      html += `<span class="eff-label">${escHtml(r.label)} <span style="color:var(--text-dim);font-size:0.75rem;">(${r.count})</span></span>`;
      html += `<span style="font-size:0.82rem;"><span class="eff-value" style="color:var(--primary);">${r.avgPts.toFixed(1)} pts</span> <span style="color:var(--text-dim);font-size:0.75rem;">&middot; ${r.avgHrs.toFixed(1)} hrs</span></span>`;
      html += `</div>`;
    });
  }
  return html || '<p style="font-size:0.85rem;color:var(--text-dim);">No calendar assignment data yet. Sync your calendar in Settings.</p>';
}

// ================================================================
// TIME TAB
// ================================================================
function renderTimeTab() {
  renderTimeSummary();
  renderProductionTrend();
  renderWeekendVsWeekday();
  renderAssignData();
  renderNightCallFreq();
}

function getRecentShifts(months) {
  const now = new Date();
  const cutoff = new Date(now.getFullYear(), now.getMonth() - months, 1);
  const cutoffStr = cutoff.getFullYear() + '-' + String(cutoff.getMonth()+1).padStart(2,'0') + '-01';
  return Object.values(data.shifts).filter(s => s.date >= cutoffStr);
}

function renderTimeSummary() {
  const recent = getRecentShifts(3);
  if (recent.length === 0) {
    document.getElementById('timeAvgMonth').textContent = '0';
    document.getElementById('timeAvgWeek').textContent = '0';
    document.getElementById('timeAvgStart').textContent = '--:--';
    document.getElementById('timeAvgEnd').textContent = '--:--';
    return;
  }
  let totalHours = 0, totalStartMin = 0, totalEndMin = 0, count = 0;
  recent.forEach(s => {
    const hrs = calcShiftHours(s);
    if (hrs > 0) {
      totalHours += hrs;
      const entries = s.timeEntries || [{ start: s.startTime, end: s.endTime }];
      totalStartMin += timeToMinutes(entries[0].start);
      const lastEnd = entries[entries.length - 1].end;
      totalEndMin += timeToMinutes(lastEnd || entries[0].start);
      count++;
    }
  });
  const avgMonthHrs = count > 0 ? round2(totalHours / 3) : 0;
  const avgWeekHrs = count > 0 ? round2(totalHours / 13) : 0; // ~13 weeks in 3 months
  document.getElementById('timeAvgMonth').textContent = avgMonthHrs.toFixed(0);
  document.getElementById('timeAvgWeek').textContent = avgWeekHrs.toFixed(0);
  if (count > 0) {
    const avgSM = Math.round(totalStartMin / count);
    const avgEM = Math.round(totalEndMin / count);
    document.getElementById('timeAvgStart').textContent = String(Math.floor(avgSM/60)).padStart(2,'0') + ':' + String(avgSM%60).padStart(2,'0');
    document.getElementById('timeAvgEnd').textContent = String(Math.floor(avgEM/60)).padStart(2,'0') + ':' + String(avgEM%60).padStart(2,'0');
  }
}

function renderProductionTrend() {
  const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
  // Build last 13 month keys (current month + 12 prior)
  const now = new Date();
  const monthKeys = [];
  for (let i = 12; i >= 0; i--) {
    const d = new Date(now.getFullYear(), now.getMonth() - i, 1);
    const y = d.getFullYear();
    const m = String(d.getMonth() + 1).padStart(2, '0');
    monthKeys.push(y + '-' + m);
  }
  // Group shifts by month and compute average daily hours
  const hoursByMonth = {};
  const countByMonth = {};
  monthKeys.forEach(k => { hoursByMonth[k] = 0; countByMonth[k] = 0; });
  const shifts = data.shifts || {};
  Object.keys(shifts).forEach(dateKey => {
    const mk = dateKey.substring(0, 7);
    if (hoursByMonth.hasOwnProperty(mk)) {
      const shift = shifts[dateKey];
      if (shift && shift.assignmentType !== 'vacation') {
        const hrs = calcShiftHours(shift);
        hoursByMonth[mk] += hrs;
        countByMonth[mk] += 1;
      }
    }
  });
  const labels = monthKeys.map(k => { const [y, m] = k.split('-'); return monthNames[parseInt(m) - 1] + ' ' + y; });
  const values = monthKeys.map(k => countByMonth[k] > 0 ? round2(hoursByMonth[k] / countByMonth[k]) : 0);
  const ctx = document.getElementById('productionTrendChart').getContext('2d');
  if (productionTrendChart) productionTrendChart.destroy();
  productionTrendChart = new Chart(ctx, {
    type: 'line',
    data: {
      labels,
      datasets: [{ label: 'Avg Daily Hours', data: values, borderColor: '#3b82f6', backgroundColor: 'rgba(59,130,246,0.15)', fill: true, tension: 0.3, pointRadius: 4, pointBackgroundColor: '#3b82f6' }]
    },
    options: {
      responsive: true, maintainAspectRatio: false,
      plugins: { legend: { display: false } },
      scales: {
        y: { beginAtZero: true, ticks: { color: '#94a3b8' }, grid: { color: 'rgba(71,85,105,0.3)' } },
        x: { ticks: { color: '#94a3b8', maxRotation: 45, minRotation: 45 }, grid: { display: false } }
      }
    }
  });
}

function buildDayOfWeek() {
  const days = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
  const ptsByDay = [0,0,0,0,0,0,0];
  const countByDay = [0,0,0,0,0,0,0];
  const recent = getRecentShifts(3);
  recent.forEach(s => {
    const d = new Date(s.date + 'T12:00:00');
    const dow = d.getDay();
    ptsByDay[dow] += calcShiftTotal(s).total;
    countByDay[dow]++;
  });
  const maxPts = Math.max(...ptsByDay, 1);
  let html = '<div style="font-size:0.75rem;color:var(--text-dim);margin-bottom:8px;">Total points by day of week (past 3 months)</div>';
  for (let i = 1; i <= 7; i++) {
    const idx = i % 7;
    const pct = maxPts > 0 ? (ptsByDay[idx] / maxPts * 100) : 0;
    const avg = countByDay[idx] > 0 ? (ptsByDay[idx] / countByDay[idx]).toFixed(1) : '0';
    const intensity = maxPts > 0 ? ptsByDay[idx] / maxPts : 0;
    const r = Math.round(30 + intensity * 29);
    const g = Math.round(41 + intensity * 89);
    const b = Math.round(59 + intensity * 187);
    html += `<div class="heatmap-row">
      <span class="hm-label">${days[idx]}</span>
      <div style="flex:1;display:flex;align-items:center;">
        <div style="height:24px;border-radius:4px;width:${Math.max(pct, 4)}%;background:rgb(${r},${g},${b});transition:width 0.3s;"></div>
      </div>
      <span class="hm-value">${ptsByDay[idx].toFixed(0)}pts (${avg}/shift)</span>
    </div>`;
  }
  return html || '<p style="color:var(--text-dim);font-size:0.85rem;">No data.</p>';
}

function renderWeekendVsWeekday() {
  let wdHrs = 0, wdPts = 0, wdN = 0, weHrs = 0, wePts = 0, weN = 0;
  Object.values(data.shifts).forEach(s => {
    const hrs = calcShiftHours(s);
    const pts = calcShiftTotal(s).total;
    if (isWeekend(s.date)) { weHrs += hrs; wePts += pts; weN++; }
    else { wdHrs += hrs; wdPts += pts; wdN++; }
  });
  let html = '<div style="display:grid;grid-template-columns:auto 1fr 1fr 1fr;gap:2px 12px;align-items:center;font-size:0.8rem;">';
  html += '<div style="font-size:0.62rem;color:var(--text-dim);"></div><div style="font-size:0.62rem;color:var(--text-dim);text-align:center;text-transform:uppercase;">Avg Pts</div><div style="font-size:0.62rem;color:var(--text-dim);text-align:center;text-transform:uppercase;">Avg Hrs</div><div style="font-size:0.62rem;color:var(--text-dim);text-align:center;text-transform:uppercase;">Shifts</div>';
  html += `<div style="font-weight:600;color:var(--primary);">Weekday</div><div style="text-align:center;color:var(--primary);">${wdN > 0 ? (wdPts/wdN).toFixed(1) : '0'}</div><div style="text-align:center;color:var(--primary);">${wdN > 0 ? (wdHrs/wdN).toFixed(1) : '0'}</div><div style="text-align:center;color:var(--primary);">${wdN}</div>`;
  html += `<div style="font-weight:600;color:var(--accent);">Weekend</div><div style="text-align:center;color:var(--accent);">${weN > 0 ? (wePts/weN).toFixed(1) : '0'}</div><div style="text-align:center;color:var(--accent);">${weN > 0 ? (weHrs/weN).toFixed(1) : '0'}</div><div style="text-align:center;color:var(--accent);">${weN}</div>`;
  html += '</div>';
  document.getElementById('wkndContent').innerHTML = html;
}

function renderNightCallFreq() {
  const recent = getRecentShifts(3);
  const callLabels = {
    'mole': 'Mole', '1st_call': '1st Call', '2nd_call': '2nd Call',
    '3rd_call': '3rd Call', '4th_call': '4th Call', 'endo': 'Endo',
    'SF1': 'SF 1', 'SF2': 'SF 2'
  };
  const callTypes = ['mole','1st_call','2nd_call','3rd_call','4th_call','endo','SF1','SF2'];
  const counts = {};
  callTypes.forEach(t => counts[t] = 0);
  recent.forEach(s => {
    if (counts.hasOwnProperty(s.assignmentType)) counts[s.assignmentType]++;
  });
  const totalCall = callTypes.reduce((sum, t) => sum + counts[t], 0);
  let html = '';
  callTypes.forEach(t => {
    if (counts[t] > 0) {
      html += `<div class="efficiency-item"><span class="eff-label">${callLabels[t]}</span><span class="eff-value">${counts[t]}</span></div>`;
    }
  });
  html += `<div class="efficiency-item" style="margin-top:8px;border-top:1px solid var(--border);padding-top:8px;"><span class="eff-label" style="font-weight:600;">Total Call Shifts</span><span class="eff-value" style="font-weight:600;">${totalCall}</span></div>`;
  html += `<div class="efficiency-item"><span class="eff-label">Total Shifts (3 mo)</span><span class="eff-value">${recent.length}</span></div>`;
  document.getElementById('nightContent').innerHTML = html || '<p style="color:var(--text-dim);font-size:0.85rem;">No call shifts in the past 3 months.</p>';
}

function renderProcLookup() {
  const query = (document.getElementById('procLookupSearch').value || '').trim().toLowerCase();
  const el = document.getElementById('procLookupResults');
  if (!query) { el.innerHTML = ''; return; }

  // Find matching procedures
  const procNames = {};
  data.cases.forEach(c => {
    if (!c.startTime || !c.endTime || c.isSharedCase) return;
    const name = c.caseType === 'standard' ? (c.procedure || '') : getCaseTypeName(c.caseType);
    if (!name || !name.toLowerCase().includes(query)) return;
    if (!procNames[name]) procNames[name] = [];
    const surgeon = (c.notes || '').trim();
    let s = timeToMinutes(c.startTime);
    let e = timeToMinutes(c.endTime);
    if (e <= s) e += 1440;
    const mins = e - s;
    if (mins <= 0) return;
    procNames[name].push({ surgeon, mins });
  });

  const procs = Object.keys(procNames);
  if (procs.length === 0) { el.innerHTML = '<p style="color:var(--text-dim);font-size:0.82rem;">No matching procedures found.</p>'; return; }

  let html = '';
  procs.sort().forEach(proc => {
    const cases = procNames[proc];
    // Overall average
    const totalMins = cases.reduce((s, c) => s + c.mins, 0);
    const avgAll = Math.round(totalMins / cases.length);
    html += `<div style="margin-bottom:12px;">`;
    html += `<div style="display:flex;justify-content:space-between;align-items:baseline;margin-bottom:4px;">`;
    html += `<span style="font-weight:600;font-size:0.85rem;">${escHtml(proc)}</span>`;
    html += `<span style="font-size:0.78rem;color:var(--text-dim);">${cases.length} case${cases.length !== 1 ? 's' : ''} &middot; avg ${avgAll} min</span>`;
    html += `</div>`;

    // Group by surgeon
    const bySurgeon = {};
    cases.forEach(c => {
      const key = c.surgeon || 'Unknown';
      if (!bySurgeon[key]) bySurgeon[key] = { total: 0, count: 0 };
      bySurgeon[key].total += c.mins;
      bySurgeon[key].count++;
    });
    const surgeons = Object.entries(bySurgeon)
      .map(([name, d]) => ({ name, avg: Math.round(d.total / d.count), count: d.count }))
      .sort((a, b) => a.avg - b.avg);
    surgeons.forEach(s => {
      html += `<div class="efficiency-item"><span class="eff-label">${escHtml(s.name)} <span style="color:var(--text-dim);font-size:0.75rem;">(${s.count})</span></span><span class="eff-value">${s.avg} min</span></div>`;
    });
    html += `</div>`;
  });
  el.innerHTML = html;
}

// ================================================================
// ANALYTICS TAB
// ================================================================
// ================================================================
// DAILY TAB
// ================================================================
let dailyMonth = new Date().getMonth();
let dailyYear = new Date().getFullYear();

function updateDailyMonthLabel() {
  const monthNames = ['January','February','March','April','May','June','July','August','September','October','November','December'];
  document.getElementById('dailyMonthLabel').textContent = monthNames[dailyMonth] + ' ' + dailyYear;
}

document.getElementById('dailyPrevMonth').addEventListener('click', () => {
  dailyMonth--; if (dailyMonth < 0) { dailyMonth = 11; dailyYear--; }
  renderDailyTab();
});
document.getElementById('dailyNextMonth').addEventListener('click', () => {
  dailyMonth++; if (dailyMonth > 11) { dailyMonth = 0; dailyYear++; }
  renderDailyTab();
});

function renderDailyTab() {
  updateDailyMonthLabel();
  const prefix = dailyYear + '-' + String(dailyMonth + 1).padStart(2, '0');
  const daysInMonth = new Date(dailyYear, dailyMonth + 1, 0).getDate();
  const firstDow = new Date(dailyYear, dailyMonth, 1).getDay(); // 0=Sun
  const today = new Date();
  const todayStr = today.getFullYear() + '-' + String(today.getMonth()+1).padStart(2,'0') + '-' + String(today.getDate()).padStart(2,'0');

  // Compute daily totals
  const dailyPts = {};
  const dailyTypes = {};
  Object.values(data.shifts).forEach(s => {
    if (!s.date || !s.date.startsWith(prefix)) return;
    const day = parseInt(s.date.split('-')[2]);
    const t = calcShiftTotal(s);
    dailyPts[day] = (dailyPts[day] || 0) + t.total;
    dailyTypes[day] = s.assignmentType;
  });

  // Build calendar grid
  let html = '<div class="daily-cal">';
  const dayNames = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
  dayNames.forEach(d => { html += `<div class="daily-cal-header">${d}</div>`; });

  // Empty cells for days before month starts
  for (let i = 0; i < firstDow; i++) {
    html += '<div class="daily-cal-cell empty"></div>';
  }

  let monthTotal = 0;
  let shiftCount = 0;
  for (let d = 1; d <= daysInMonth; d++) {
    const dateStr = prefix + '-' + String(d).padStart(2, '0');
    const pts = round2(dailyPts[d] || 0);
    const shiftType = dailyTypes[d];
    const isToday = dateStr === todayStr;
    const isVac = shiftType === 'vacation';
    monthTotal += pts;
    if (shiftType) shiftCount++;

    let classes = 'daily-cal-cell';
    if (isToday) classes += ' today';
    if (isVac) classes += ' vacation';

    // Calendar label preferred, shift type as fallback
    const cal = data.calendarAssignments[dateStr];
    const typeName = cal ? cal.label : (shiftType ? getAssignmentTypeName(shiftType) : '');
    const ptsClass = pts > 0 ? '' : ' zero';

    html += `<div class="${classes}" onclick="openDayDetail('${dateStr}')">`;
    html += `<div class="daily-cal-day">${d}</div>`;
    html += `<div class="daily-cal-pts${ptsClass}">${pts > 0 ? pts.toFixed(1) : (isVac ? 'VAC' : '—')}</div>`;
    if (typeName) html += `<div class="daily-cal-type">${escHtml(typeName)}</div>`;
    html += '</div>';
  }
  html += '</div>';

  document.getElementById('dailyCalendarContainer').innerHTML = html;

  // Summary
  const avgPerShift = shiftCount > 0 ? (monthTotal / shiftCount).toFixed(1) : '—';
  document.getElementById('dailyMonthSummary').innerHTML =
    `<span style="font-size:1.3rem;font-weight:700;color:var(--accent);">${round2(monthTotal).toFixed(1)}</span> <span style="color:var(--text-dim);">total pts</span> &bull; <strong>${shiftCount}</strong> shifts &bull; <strong>${avgPerShift}</strong> avg pts/shift`;
}

// ================================================================
// DAY DETAIL — Navigate to Today page from Daily tab
// ================================================================
let dayDetailDate = '';
let returnToDailyTab = false;

function openDayDetail(dateStr) {
  dayDetailDate = dateStr;
  returnToDailyTab = true;
  // Set working date and navigate to Today page
  setWorkingDate(dateStr);
  document.querySelectorAll('.bottom-nav button').forEach(b => b.classList.remove('active'));
  document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
  const todayBtn = document.querySelector('.bottom-nav button[data-page="today"]');
  if (todayBtn) todayBtn.classList.add('active');
  document.getElementById('page-today').classList.add('active');
  renderToday();
  window.scrollTo(0, 0);
}

function renderDayDetailContent() {
  const dateStr = dayDetailDate;
  if (!dateStr) return;
  const shift = data.shifts[dateStr];
  const shiftCases = data.cases.filter(c => c.shiftDate === dateStr);
  const body = document.getElementById('dayDetailBody');

  if (!shift) {
    body.innerHTML = '<p style="color:var(--text-dim);font-size:0.85rem;margin:12px 0;">No shift saved for this date.</p>' +
      (shiftCases.length > 0 ? renderDDCaseList(shiftCases, null) : '');
    return;
  }

  const totals = calcShiftTotal(shift);
  const isVacation = shift.assignmentType === 'vacation';
  const entries = shift.timeEntries || [{ start: shift.startTime, end: shift.endTime }];
  let timesText = '';
  if (isVacation) {
    timesText = 'Vacation Day';
  } else if (entries.length === 1) {
    timesText = (entries[0].start || '?') + ' - ' + (entries[0].end || '?');
  } else {
    timesText = entries.length + ' time entries';
  }

  let html = '';
  // Shift bar
  html += `<div class="dd-shift-bar">
    <span class="dd-badge${isVacation ? ' vacation' : ''}">${escHtml(getAssignmentTypeName(shift.assignmentType))}</span>
    <span class="dd-times">${escHtml(timesText)}</span>
    <button class="btn btn-outline btn-sm" onclick="openShiftEdit('${dateStr}')" style="padding:4px 10px;font-size:0.72rem;">Edit</button>
  </div>`;

  // Point summary
  html += `<div class="dd-summary">
    <div class="dd-summary-item"><div class="dd-label">Availability</div><div class="dd-value blue">${totals.ar.toFixed(1)}</div></div>
    <div class="dd-summary-item"><div class="dd-label">Productivity</div><div class="dd-value green">${totals.prod.toFixed(1)}</div></div>
    <div class="dd-summary-item"><div class="dd-label">Call / Other</div><div class="dd-value yellow">${(totals.call + totals.subspec + totals.supervision).toFixed(1)}</div></div>
    <div class="dd-summary-item"><div class="dd-label">Total</div><div class="dd-value green">${totals.total.toFixed(1)}</div></div>
  </div>`;

  // Case list
  if (!isVacation) {
    html += `<h3 style="font-size:0.85rem;margin-bottom:6px;">Cases (${shiftCases.length})</h3>`;
    html += renderDDCaseList(shiftCases, shift);
  }

  body.innerHTML = html;
}

function renderDDCaseList(cases, shift) {
  if (cases.length === 0) return '<p style="color:var(--text-dim);font-size:0.8rem;">No cases logged.</p>';
  let html = '';
  cases.forEach(c => {
    const pts = shift ? calcCasePoints(c, shift) : 0;
    const name = c.caseType === 'standard' ? (c.procedure || 'Standard Case') : getCaseTypeName(c.caseType);
    const timeStr = c.startTime && c.endTime ? `${c.startTime} - ${c.endTime}` : (c.startTime ? c.startTime : '');
    html += `<div class="dd-case-item">
      <div class="dd-case-info">
        <div class="dd-case-name">${escHtml(name)}</div>
        ${timeStr ? `<div class="dd-case-detail">${escHtml(timeStr)}</div>` : ''}
      </div>
      <div class="dd-case-actions">
        <span class="dd-case-pts">${pts.toFixed(1)}</span>
        <button class="btn btn-outline btn-sm" onclick="openCaseEdit('${c.id}')" style="padding:2px 8px;font-size:0.68rem;">Edit</button>
        <button class="btn btn-danger btn-sm" onclick="deleteCaseDayDetail('${c.id}')" style="padding:2px 8px;font-size:0.68rem;">Del</button>
      </div>
    </div>`;
  });
  return html;
}

function deleteCaseDayDetail(id) {
  if (!confirm('Delete this case?')) return;
  data.cases = data.cases.filter(c => c.id !== id);
  saveData(data);
  updateHeaderPoints();
  renderDayDetailContent();
  renderDailyTab();
  renderDECaseList();
  updateDETally();
  showToast('Case deleted');
}

document.getElementById('closeDayDetail').addEventListener('click', () => {
  document.getElementById('dayDetailModal').classList.add('hidden');
});

document.getElementById('dayDetailModal').addEventListener('click', (e) => {
  if (e.target.id === 'dayDetailModal') document.getElementById('dayDetailModal').classList.add('hidden');
});

function renderAnalyticsTab() {
  renderCaseMix();
  renderTopProcedures();
  renderSurgeonEfficiency();
}

function renderCaseMix() {
  if (data.cases.length === 0) {
    document.getElementById('caseMixContent').innerHTML = '<p style="color:var(--text-dim);font-size:0.85rem;">No cases logged yet.</p>';
    return;
  }
  const ranked = data.cases.map(c => {
    const shift = data.shifts[c.shiftDate] || {};
    const pts = calcCasePoints(c, shift);
    const procedure = c.procedure || c.notes || c.caseType;
    return { procedure, pts, date: c.shiftDate || '' };
  }).sort((a, b) => b.pts - a.pts).slice(0, 8);
  let html = '';
  ranked.forEach(item => {
    html += `<div class="efficiency-item"><span class="eff-label">${escHtml(item.procedure)}</span><span class="eff-value"><span class="point-badge">${item.pts.toFixed(1)}</span><span style="font-size:0.7rem;color:var(--text-dim);margin-left:6px;">${escHtml(item.date)}</span></span></div>`;
  });
  document.getElementById('caseMixContent').innerHTML = html;
}

let procEffData = { ranked: [], unranked: [] };
let activeProcTab = 'top';

function switchProcTab(tab) {
  activeProcTab = tab;
  ['top','grow','all'].forEach(t => {
    document.getElementById('peTab' + t.charAt(0).toUpperCase() + t.slice(1)).classList.toggle('active', t === tab);
  });
  renderProcTabContent();
}

function renderTopProcedures() {
  const procData = {};
  data.cases.forEach(c => {
    if (!c.startTime || !c.endTime || c.isSharedCase) return;
    let s = timeToMinutes(c.startTime);
    let e = timeToMinutes(c.endTime);
    if (e <= s) e += 1440;
    const hrs = (e - s) / 60;
    if (hrs <= 0) return;
    const name = c.caseType === 'standard' ? (c.procedure || 'Standard') : getCaseTypeName(c.caseType);
    const shift = data.shifts[c.shiftDate];
    const pts = calcCasePoints(c, shift);
    if (!procData[name]) procData[name] = { totalPts: 0, totalHrs: 0, count: 0 };
    procData[name].totalPts += pts;
    procData[name].totalHrs += hrs;
    procData[name].count++;
  });
  const all = Object.entries(procData).map(([name, d]) => ({ name, ptsPerHr: d.totalPts / d.totalHrs, count: d.count }));
  procEffData.ranked = all.filter(p => p.count >= 4).sort((a, b) => b.ptsPerHr - a.ptsPerHr);
  procEffData.unranked = all.filter(p => p.count < 4).sort((a, b) => a.name.localeCompare(b.name));
  renderProcTabContent();
}

function renderProcTabContent() {
  const { ranked, unranked } = procEffData;
  const el = document.getElementById('topProcContent');
  if (ranked.length === 0 && unranked.length === 0) {
    el.innerHTML = '<p style="color:var(--text-dim);font-size:0.85rem;">No procedure data yet.</p>';
    return;
  }
  let html = '';
  if (activeProcTab === 'top') {
    const top10 = ranked.slice(0, 10);
    if (top10.length === 0) { html = '<p style="color:var(--text-dim);font-size:0.85rem;">Not enough data (need 4+ cases per procedure).</p>'; }
    else { top10.forEach((p, i) => { html += procRow(i + 1, p, '#22c55e'); }); }
  } else if (activeProcTab === 'grow') {
    const bottom10 = ranked.slice(-Math.min(10, ranked.length)).reverse();
    if (bottom10.length === 0) { html = '<p style="color:var(--text-dim);font-size:0.85rem;">Not enough data (need 4+ cases per procedure).</p>'; }
    else { bottom10.forEach((p, i) => { html += procRow(ranked.length - i, p, '#f59e0b'); }); }
  } else {
    if (ranked.length > 0) { ranked.forEach((p, i) => { html += procRow(i + 1, p); }); }
    if (unranked.length > 0) {
      if (ranked.length > 0) html += '<div style="border-top:1px solid var(--border);margin:10px 0;"></div>';
      unranked.forEach(p => {
        html += `<div class="efficiency-item"><span class="eff-label">${escHtml(p.name)} <span style="color:var(--text-dim);font-size:0.75rem;">(${p.count} case${p.count !== 1 ? 's' : ''})</span></span><span class="eff-value" style="color:var(--text-dim);font-size:0.75rem;">Need more data</span></div>`;
      });
    }
  }
  el.innerHTML = html;
}

function procRow(rank, p, color) {
  const c = color ? ` style="color:${color}"` : '';
  return `<div class="efficiency-item"><span class="eff-label">${rank}. ${escHtml(p.name)} <span style="color:var(--text-dim);font-size:0.75rem;">(${p.count} cases)</span></span><span class="eff-value"${c}>${p.ptsPerHr.toFixed(1)} pts/hr</span></div>`;
}

let surgeonEffData = { ranked: [], unranked: [] };
let activeSurgeonTab = 'top';

function switchSurgeonTab(tab) {
  activeSurgeonTab = tab;
  ['top','grow','all'].forEach(t => {
    document.getElementById('seTab' + t.charAt(0).toUpperCase() + t.slice(1)).classList.toggle('active', t === tab);
  });
  renderSurgeonTabContent();
}

function renderSurgeonEfficiency() {
  const surgeonData = {};
  data.cases.forEach(c => {
    if (c.isSharedCase) return;
    const surgeon = (c.notes || '').trim();
    if (!surgeon || !c.startTime || !c.endTime) return;
    const shift = data.shifts[c.shiftDate];
    const pts = calcCasePoints(c, shift || {});
    const dateKey = c.shiftDate || 'unknown';
    if (!surgeonData[surgeon]) surgeonData[surgeon] = { totalPts: 0, dates: {}, caseCount: 0 };
    surgeonData[surgeon].totalPts += pts;
    surgeonData[surgeon].caseCount++;
    if (!surgeonData[surgeon].dates[dateKey]) surgeonData[surgeon].dates[dateKey] = { earliest: null, latest: null };
    const startMin = timeToMinutes(c.startTime);
    let endMin = timeToMinutes(c.endTime);
    if (endMin <= startMin) endMin += 1440;
    const dateEntry = surgeonData[surgeon].dates[dateKey];
    if (dateEntry.earliest === null || startMin < dateEntry.earliest) dateEntry.earliest = startMin;
    if (dateEntry.latest === null || endMin > dateEntry.latest) dateEntry.latest = endMin;
  });
  const all = Object.entries(surgeonData).map(([name, d]) => {
    let totalHrs = 0;
    Object.values(d.dates).forEach(dt => { totalHrs += (dt.latest - dt.earliest) / 60; });
    return { name, pph: totalHrs > 0 ? round2(d.totalPts / totalHrs) : 0, cases: d.caseCount, totalHrs };
  }).filter(r => r.totalHrs > 0);
  surgeonEffData.ranked = all.filter(s => s.cases >= 4).sort((a, b) => b.pph - a.pph);
  surgeonEffData.unranked = all.filter(s => s.cases < 4).sort((a, b) => a.name.localeCompare(b.name));
  renderSurgeonTabContent();
}

function renderSurgeonTabContent() {
  const { ranked, unranked } = surgeonEffData;
  const el = document.getElementById('surgeonEffContent');
  if (ranked.length === 0 && unranked.length === 0) {
    el.innerHTML = '<p style="color:var(--text-dim);font-size:0.85rem;">No surgeon data yet.</p>';
    return;
  }
  let html = '';
  if (activeSurgeonTab === 'top') {
    const top10 = ranked.slice(0, 10);
    if (top10.length === 0) { html = '<p style="color:var(--text-dim);font-size:0.85rem;">Not enough data (need 4+ cases per surgeon).</p>'; }
    else { top10.forEach((s, i) => { html += surgeonRow(i + 1, s, '#22c55e'); }); }
  } else if (activeSurgeonTab === 'grow') {
    const bottom10 = ranked.slice(-Math.min(10, ranked.length)).reverse();
    if (bottom10.length === 0) { html = '<p style="color:var(--text-dim);font-size:0.85rem;">Not enough data (need 4+ cases per surgeon).</p>'; }
    else { bottom10.forEach((s, i) => { html += surgeonRow(ranked.length - i, s, '#f59e0b'); }); }
  } else {
    if (ranked.length > 0) { ranked.forEach((s, i) => { html += surgeonRow(i + 1, s); }); }
    if (unranked.length > 0) {
      if (ranked.length > 0) html += '<div style="border-top:1px solid var(--border);margin:10px 0;"></div>';
      unranked.forEach(s => {
        html += `<div class="efficiency-item"><span class="eff-label">${escHtml(s.name)} <span style="color:var(--text-dim);font-size:0.75rem;">(${s.cases} case${s.cases !== 1 ? 's' : ''})</span></span><span class="eff-value" style="color:var(--text-dim);font-size:0.75rem;">Need more data</span></div>`;
      });
    }
  }
  el.innerHTML = html;
}

function surgeonRow(rank, s, color) {
  const c = color ? ` style="color:${color}"` : '';
  return `<div class="efficiency-item"><span class="eff-label">${rank}. ${escHtml(s.name)} <span style="color:var(--text-dim);font-size:0.75rem;">(${s.cases} cases)</span></span><span class="eff-value"${c}>${s.pph.toFixed(1)} pts/hr</span></div>`;
}

let editingCaseId = null;
let editCaseType = 'standard';

// Edit modal case type select
document.getElementById('editCaseTypeSelect').addEventListener('change', function() {
  editCaseType = this.value;
  const isStd = editCaseType === 'standard';
  const isLabor = editCaseType === 'labor_epidural';
  const isAPS = editCaseType === 'aps_rounding';
  document.getElementById('editStandardFields').classList.toggle('hidden', !isStd);
  document.getElementById('editLaborEpiduralFields').classList.toggle('hidden', !isLabor);
  document.getElementById('editApsRoundingFields').classList.toggle('hidden', !isAPS);
  document.getElementById('editSimpleFields').classList.toggle('hidden', isStd || isLabor || isAPS);
});

document.getElementById('editCaseAcutePain').addEventListener('change', function() {
  document.getElementById('editAcutePainUnitsRow').classList.toggle('hidden', !this.checked);
});

document.getElementById('editCaseShared').addEventListener('change', function() {
  document.getElementById('editSharedPctRow').classList.toggle('hidden', !this.checked);
});

function openCaseEdit(caseId) {
  const c = data.cases.find(x => x.id === caseId);
  if (!c) return;
  editingCaseId = caseId;
  editCaseType = c.caseType || 'standard';

  // Set case type
  document.getElementById('editCaseTypeSelect').value = editCaseType;
  const isStd = editCaseType === 'standard';
  const isLabor = editCaseType === 'labor_epidural';
  const isAPS = editCaseType === 'aps_rounding';
  document.getElementById('editStandardFields').classList.toggle('hidden', !isStd);
  document.getElementById('editLaborEpiduralFields').classList.toggle('hidden', !isLabor);
  document.getElementById('editApsRoundingFields').classList.toggle('hidden', !isAPS);
  document.getElementById('editSimpleFields').classList.toggle('hidden', isStd || isLabor || isAPS);

  // Fill fields
  document.getElementById('editCaseProcedure').value = c.procedure || '';
  document.getElementById('editCaseBaseUnits').value = c.baseUnits || '';
  document.getElementById('editCasePhysicalStatus').value = c.physicalStatus || 'P2';
  document.getElementById('editCaseStart').value = c.startTime || '';
  document.getElementById('editCaseEnd').value = c.endTime || '';
  document.getElementById('editCaseEmergency').checked = c.isEmergency || false;
  document.getElementById('editCaseAcutePain').checked = c.isAcutePain || false;
  document.getElementById('editAcutePainUnitsRow').classList.toggle('hidden', !c.isAcutePain);
  document.getElementById('editCaseAcutePainUnits').value = c.acutePainUnits || 0;
  document.getElementById('editCaseHighRiskPeds').checked = c.isHighRiskPeds || false;
  document.getElementById('editCaseNotes').value = c.notes || '';
  document.getElementById('editSimpleNotes').value = c.notes || '';

  // Add-ons
  document.getElementById('editNerveBlock').value = c.nerveBlock || 'none';
  document.getElementById('editCentralLine').checked = c.hasCentralLine || false;
  document.getElementById('editArterialLine').checked = c.hasArterialLine || false;
  document.getElementById('editPAC').checked = c.hasPAC || false;
  document.getElementById('editTEEAddOn').checked = c.hasTEEAddOn || false;
  document.getElementById('editITMorphine').checked = c.hasITMorphine || false;

  // Labor epidural fields
  if (editCaseType === 'labor_epidural') {
    document.getElementById('editLaborStart').value = c.startTime || '';
    document.getElementById('editLaborEnd').value = c.endTime || '';
  }

  // APS rounding fields
  if (editCaseType === 'aps_rounding') {
    document.getElementById('editApsEpiduralCount').value = c.epiduralRounds || 0;
    document.getElementById('editApsPainCount').value = c.painRounds || 0;
  }

  // Shared case
  document.getElementById('editCaseShared').checked = c.isSharedCase || false;
  document.getElementById('editCaseSharedPct').value = c.sharedStartupPct || 50;
  document.getElementById('editSharedPctRow').classList.toggle('hidden', !c.isSharedCase);

  // OR Case checkbox visibility
  const shift = data.shifts[c.shiftDate];
  const isSF = shift && ['SF1','SF2'].includes(shift.assignmentType);
  document.getElementById('editORCaseRow').classList.toggle('hidden', !isSF);
  document.getElementById('editCaseORCase').checked = c.isORCase || false;

  document.getElementById('caseEditModal').classList.remove('hidden');
}

document.getElementById('saveCaseEdit').addEventListener('click', () => {
  const c = data.cases.find(x => x.id === editingCaseId);
  if (!c) return;
  c.caseType = editCaseType;
  if (editCaseType === 'standard') {
    c.procedure = document.getElementById('editCaseProcedure').value;
    c.baseUnits = document.getElementById('editCaseBaseUnits').value;
    c.physicalStatus = document.getElementById('editCasePhysicalStatus').value;
    c.startTime = document.getElementById('editCaseStart').value;
    c.endTime = document.getElementById('editCaseEnd').value;
    c.isEmergency = document.getElementById('editCaseEmergency').checked;
    c.isAcutePain = document.getElementById('editCaseAcutePain').checked;
    c.acutePainUnits = document.getElementById('editCaseAcutePainUnits').value;
    c.isHighRiskPeds = document.getElementById('editCaseHighRiskPeds').checked;
    c.isORCase = document.getElementById('editCaseORCase').checked;
    c.isSharedCase = document.getElementById('editCaseShared').checked;
    c.sharedStartupPct = document.getElementById('editCaseSharedPct').value;
    c.nerveBlock = document.getElementById('editNerveBlock').value;
    c.hasCentralLine = document.getElementById('editCentralLine').checked;
    c.hasArterialLine = document.getElementById('editArterialLine').checked;
    c.hasPAC = document.getElementById('editPAC').checked;
    c.hasTEEAddOn = document.getElementById('editTEEAddOn').checked;
    c.hasITMorphine = document.getElementById('editITMorphine').checked;
    c.notes = document.getElementById('editCaseNotes').value;
  } else if (editCaseType === 'labor_epidural') {
    c.procedure = 'Labor Epidural';
    c.startTime = document.getElementById('editLaborStart').value;
    c.endTime = document.getElementById('editLaborEnd').value;
    c.notes = document.getElementById('editCaseNotes').value;
  } else if (editCaseType === 'aps_rounding') {
    c.procedure = 'APS Rounding';
    c.epiduralRounds = document.getElementById('editApsEpiduralCount').value;
    c.painRounds = document.getElementById('editApsPainCount').value;
    c.notes = document.getElementById('editCaseNotes').value;
  } else {
    c.notes = document.getElementById('editSimpleNotes').value || document.getElementById('editCaseNotes').value;
  }
  saveData(data);
  updateHeaderPoints();
  renderCaseLogTable();
  renderToday();
  renderDailyTab();
  renderDECaseList();
  updateDETally();
  document.getElementById('caseEditModal').classList.add('hidden');
  showToast('Case updated');
});

document.getElementById('cancelCaseEdit').addEventListener('click', () => {
  document.getElementById('caseEditModal').classList.add('hidden');
});

document.getElementById('caseEditModal').addEventListener('click', (e) => {
  if (e.target.id === 'caseEditModal') document.getElementById('caseEditModal').classList.add('hidden');
});

document.getElementById('deleteCaseEdit').addEventListener('click', () => {
  if (!editingCaseId) return;
  if (!confirm('Delete this case?')) return;
  data.cases = data.cases.filter(c => c.id !== editingCaseId);
  saveData(data);
  updateHeaderPoints();
  renderCaseLogTable();
  renderToday();
  renderDailyTab();
  renderDECaseList();
  updateDETally();
  document.getElementById('caseEditModal').classList.add('hidden');
  showToast('Case deleted');
});

function deleteCaseFromList(id) {
  if (!confirm('Delete this case?')) return;
  data.cases = data.cases.filter(c => c.id !== id);
  saveData(data);
  updateHeaderPoints();
  renderCaseLogTable();
  renderDECaseList();
  updateDETally();
  showToast('Case deleted');
}

// ================================================================
// EXPORT / IMPORT
// ================================================================
document.getElementById('exportCSVBtn').addEventListener('click', () => {
  const prefix = `${historyYear}-${String(historyMonth+1).padStart(2,'0')}`;
  const monthShifts = Object.values(data.shifts).filter(s => s.date.startsWith(prefix)).sort((a,b) => a.date.localeCompare(b.date));
  let csv = 'Date,Assignment,Time Entries,Entries Count,AR Points,Productivity Points,Call Points,Subspec Points,Supervision Points,Total Points,Cases\n';
  monthShifts.forEach(shift => {
    const totals = calcShiftTotal(shift);
    const cc = data.cases.filter(c => c.shiftDate === shift.date).length;
    const entries = shift.timeEntries || [{ start: shift.startTime, end: shift.endTime }];
    const timeStr = entries.map(e => `${e.start}-${e.end || '?'}`).join('; ');
    csv += `${shift.date},${getAssignmentTypeName(shift.assignmentType)},"${timeStr}",${entries.length},${totals.ar.toFixed(2)},${totals.prod.toFixed(2)},${totals.call.toFixed(2)},${totals.subspec.toFixed(2)},${totals.supervision.toFixed(2)},${totals.total.toFixed(2)},${cc}\n`;
  });
  const namePrefix = settings.name ? settings.name.replace(/\s+/g, '_') + '_' : '';
  downloadFile(csv, `${namePrefix}mwa-points-${prefix}.csv`, 'text/csv');
  showToast('CSV exported!');
});

document.getElementById('exportAllBtn').addEventListener('click', () => {
  const namePrefix = settings.name ? settings.name.replace(/\s+/g, '_') + '_' : '';
  downloadFile(JSON.stringify(data, null, 2), `${namePrefix}mwa-backup.json`, 'application/json');
  showToast('Data exported!');
});

document.getElementById('importFile').addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (ev) => {
    try {
      const imported = JSON.parse(ev.target.result);
      if (imported.shifts && imported.cases) {
        if (confirm('This will replace all existing data. Continue?')) {
          data = imported;
          migrateData(data); // handles timeEntries migration for old format
          saveData(data);
          updateHeaderPoints();
          showToast('Data imported!');
          renderHistory();
        }
      } else { showToast('Invalid file format'); }
    } catch(err) { showToast('Error reading file'); }
  };
  reader.readAsText(file);
  e.target.value = '';
});

document.getElementById('clearAllBtn').addEventListener('click', () => {
  if (confirm('Are you sure you want to delete ALL data? This cannot be undone.')) {
    if (confirm('Really delete everything?')) {
      data = { shifts: {}, cases: [], calendarAssignments: {} };
      saveData(data);
      updateHeaderPoints();
      showToast('All data cleared');
      renderHistory();
    }
  }
});

// Calendar sync button — uses GIS to get a properly-scoped token
document.getElementById('syncCalendarBtn').addEventListener('click', async () => {
  await syncCalendarEvents();
});

// Initialize last sync display
if (data.calendarLastSync) {
  const el = document.getElementById('calendarLastSync');
  if (el) el.textContent = 'Last synced: ' + new Date(data.calendarLastSync).toLocaleString();
}

document.getElementById('copyFlaggedEmailBtn').addEventListener('click', () => {
  const text = document.getElementById('flaggedList').dataset.emailText || '';
  if (!text) { document.getElementById('flaggedCopyStatus').textContent = 'Nothing to copy'; setTimeout(() => document.getElementById('flaggedCopyStatus').textContent = '', 2000); return; }
  navigator.clipboard.writeText(text).then(() => {
    document.getElementById('flaggedCopyStatus').textContent = 'Copied!';
    setTimeout(() => document.getElementById('flaggedCopyStatus').textContent = '', 2000);
  });
});
document.getElementById('clearAllFlagsBtn').addEventListener('click', () => {
  Object.values(data.shifts).forEach(s => s.flagged = false);
  data.cases.forEach(c => c.flagged = false);
  saveData();
  renderFlaggedPage();
  if (activeDashTab === 'caselogs') renderCaseLogTable();
  if (activeDashTab === 'shiftlogs') renderShiftLogTable();
});

document.getElementById('loadTestDataBtn').addEventListener('click', () => {
  if (Object.keys(data.shifts).length > 0 || data.cases.length > 0) {
    if (!confirm('This will ADD test data alongside your existing data. Continue?')) return;
  }
  generateTestData();
  saveData(data);
  updateHeaderPoints();
  renderHistory();
  showToast('Test data loaded — 3 months of shifts & cases');
});

function generateTestData() {
  const today = new Date();
  const threeMonthsAgo = new Date(today.getFullYear(), today.getMonth() - 3, 1);
  const yesterday = new Date(today);
  yesterday.setDate(yesterday.getDate() - 1);

  const procedures = [
    { name: 'Lap Cholecystectomy', units: 7 },
    { name: 'Total Knee Arthroplasty', units: 10 },
    { name: 'Total Hip Arthroplasty', units: 10 },
    { name: 'Lap Appendectomy', units: 6 },
    { name: 'Hernia Repair', units: 5 },
    { name: 'Thyroidectomy', units: 6 },
    { name: 'Rotator Cuff Repair', units: 5 },
    { name: 'ACL Reconstruction', units: 7 },
    { name: 'Lumbar Laminectomy', units: 10 },
    { name: 'Craniotomy', units: 13 },
    { name: 'CABG', units: 20 },
    { name: 'Colectomy', units: 10 },
    { name: 'Mastectomy', units: 6 },
    { name: 'Hysterectomy', units: 8 },
    { name: 'Cystoscopy', units: 3 },
    { name: 'TURP', units: 5 },
    { name: 'Carotid Endarterectomy', units: 10 },
    { name: 'Spinal Fusion', units: 13 },
    { name: 'Whipple', units: 20 },
    { name: 'AAA Repair', units: 15 },
    { name: 'Colonoscopy', units: 4 },
    { name: 'EGD', units: 5 },
    { name: 'Tonsillectomy', units: 5 },
    { name: 'Shoulder Arthroscopy', units: 4 },
    { name: 'Carpal Tunnel Release', units: 3 }
  ];

  const physStatuses = ['P1','P2','P2','P2','P3','P3','P3','P3','P4','P4'];
  const nerveBlocks = ['none','none','none','none','none','brachial_plexus','other'];
  const rand = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
  const pick = arr => arr[rand(0, arr.length - 1)];
  const pad2 = n => String(n).padStart(2, '0');
  const fmtDate = d => `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`;
  const fmtTime = (h, m) => `${pad2(h)}:${pad2(m)}`;

  // Weekday schedule patterns (weighted distribution)
  const weekdaySchedules = [
    { type: 'OR', weight: 40 },
    { type: 'OB_restricted', weight: 8 },
    { type: 'SF1', weight: 8 },
    { type: 'SF2', weight: 5 },
    { type: 'endo', weight: 6 },
    { type: 'NORA', weight: 5 },
    { type: 'ACS', weight: 3 },
    { type: 'cardiac_liver', weight: 3 },
    { type: 'mole', weight: 4 },
    { type: '1st_call', weight: 6 },
    { type: '2nd_call', weight: 4 },
    { type: '3rd_call', weight: 3 },
    { type: 'CRNA_supervision', weight: 5 }
  ];

  const weekendSchedules = [
    { type: 'OB_restricted', weight: 25 },
    { type: '1st_call', weight: 25 },
    { type: '2nd_call', weight: 20 },
    { type: '4th_call', weight: 15 },
    { type: 'cardiac_liver', weight: 10 },
    { type: '3rd_call', weight: 5 }
  ];

  function pickWeighted(items) {
    const total = items.reduce((s, i) => s + i.weight, 0);
    let r = Math.random() * total;
    for (const item of items) {
      r -= item.weight;
      if (r <= 0) return item.type;
    }
    return items[items.length - 1].type;
  }

  function getShiftTimes(aType, isWeekend) {
    switch (aType) {
      case 'OR': return { start: '07:10', end: fmtTime(rand(15,17), rand(0,3)*15) };
      case 'OB_restricted':
        if (isWeekend) return { start: '07:00', end: '19:00' };
        return rand(0,1) ? { start: '07:00', end: '19:00' } : { start: '19:00', end: '07:00' };
      case 'SF1': return { start: '07:00', end: fmtTime(rand(14,17), rand(0,3)*15) };
      case 'SF2': return { start: '07:00', end: fmtTime(rand(13,16), rand(0,3)*15) };
      case 'endo': return { start: '07:00', end: fmtTime(rand(13,15), rand(0,3)*15) };
      case 'NORA': return { start: '07:00', end: fmtTime(rand(14,16), 0) };
      case 'ACS': return { start: '07:00', end: fmtTime(rand(15,17), rand(0,3)*15) };
      case 'cardiac_liver': return { start: '07:00', end: fmtTime(rand(15,18), rand(0,3)*15) };
      case 'mole': return { start: '07:00', end: fmtTime(rand(15,17), rand(0,3)*15) };
      case '1st_call': case '2nd_call': case '3rd_call':
        if (isWeekend) return { start: '07:00', end: '07:00' };
        return { start: '17:00', end: fmtTime(rand(22,23), rand(0,3)*15) };
      case '4th_call': return { start: '07:00', end: '07:00' };
      case 'CRNA_supervision': return { start: '07:00', end: fmtTime(rand(15,17), 0) };
      default: return { start: '07:00', end: '17:00' };
    }
  }

  // Generate call shifts with multiple time entries
  function makeTimeEntries(aType, baseTimes, isWeekend) {
    if (['1st_call','2nd_call','3rd_call','4th_call'].includes(aType)) {
      // Call shifts: sometimes multiple call-ins
      const numEntries = rand(1,3);
      if (numEntries === 1) return [{ start: baseTimes.start, end: baseTimes.end }];
      const entries = [];
      if (isWeekend) {
        // Weekend call: scattered through 24hr period
        const starts = [rand(8,10), rand(13,15), rand(19,21)].slice(0, numEntries).sort((a,b)=>a-b);
        for (const h of starts) {
          const dur = rand(1,3);
          entries.push({ start: fmtTime(h, rand(0,3)*15), end: fmtTime(h+dur, rand(0,3)*15) });
        }
      } else {
        // Weekday evening call
        const starts = [17, rand(19,20), rand(21,22)].slice(0, numEntries);
        for (const h of starts) {
          const dur = rand(1,2);
          entries.push({ start: fmtTime(h, rand(0,3)*15), end: fmtTime(Math.min(h+dur,23), rand(0,3)*15) });
        }
      }
      return entries;
    }
    return [{ start: baseTimes.start, end: baseTimes.end }];
  }

  // Track which dates already have shifts to avoid overwriting
  const existingDates = new Set(Object.keys(data.shifts));

  // Generate data day by day
  const cur = new Date(threeMonthsAgo);
  while (cur <= yesterday) {
    const dateStr = fmtDate(cur);
    const dow = cur.getDay();
    const isWeekend = dow === 0 || dow === 6;

    // Skip ~20% of weekdays (days off), skip ~60% of weekends
    if (!existingDates.has(dateStr)) {
      const workChance = isWeekend ? 0.4 : 0.8;
      if (Math.random() < workChance) {
        const aType = isWeekend ? pickWeighted(weekendSchedules) : pickWeighted(weekdaySchedules);
        const baseTimes = getShiftTimes(aType, isWeekend);
        const timeEntries = makeTimeEntries(aType, baseTimes, isWeekend);

        const shift = {
          date: dateStr,
          assignmentType: aType,
          startTime: timeEntries[0].start,
          endTime: timeEntries[timeEntries.length - 1].end,
          timeEntries: timeEntries,
          isHoliday: false,
          forcedOff: false,
          subspecCoverage: false,
          teeCount: 0,
          supervisionStart: '',
          supervisionEnd: '',
          preCallStart: '',
          preCallEnd: '',
          tempCoverage: []
        };

        // CRNA supervision: add supervision times
        if (aType === 'CRNA_supervision') {
          shift.supervisionStart = timeEntries[0].start;
          shift.supervisionEnd = timeEntries[0].end;
        }

        // OR/SF1/SF2 occasionally get CRNA supervision overlay
        if (['OR','SF1','SF2'].includes(aType) && Math.random() < 0.1) {
          shift.supervisionStart = timeEntries[0].start;
          shift.supervisionEnd = fmtTime(rand(10,12), 0);
        }

        // Random temp coverage on pager-eligible shifts (~8%)
        if (getPagerPayWindow(aType, isWeekend) !== null && Math.random() < 0.08) {
          const tcType = Math.random() < 0.5 ? 'covered' : 'covering';
          const tcStartHr = rand(17, 20);
          const tcEndHr = Math.min(tcStartHr + rand(1, 3), 23);
          const tcEntry = { type: tcType, start: fmtTime(tcStartHr, 0), end: fmtTime(tcEndHr, 0), timeEntries: [] };
          if (tcType === 'covering') {
            tcEntry.timeEntries = [{ start: fmtTime(tcStartHr, 15), end: fmtTime(tcEndHr - 1 < tcStartHr ? tcStartHr + 1 : tcEndHr, 45) }];
          }
          shift.tempCoverage = [tcEntry];
        }

        data.shifts[dateStr] = shift;

        // Generate cases for this shift
        if (aType !== 'CRNA_supervision') {
          generateCasesForShift(dateStr, aType, timeEntries, isWeekend, procedures, physStatuses, nerveBlocks);
        }
      }
    }

    cur.setDate(cur.getDate() + 1);
  }
}

function generateCasesForShift(dateStr, aType, timeEntries, isWeekend, procedures, physStatuses, nerveBlocks) {
  const rand = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
  const pick = arr => arr[rand(0, arr.length - 1)];
  const pad2 = n => String(n).padStart(2, '0');
  const fmtTime = (h, m) => `${pad2(h)}:${pad2(m)}`;

  // Determine number of cases based on shift type
  let numCases;
  switch (aType) {
    case 'OR': numCases = rand(3, 6); break;
    case 'OB_restricted': numCases = rand(1, 4); break;
    case 'SF1': case 'SF2': numCases = rand(2, 5); break;
    case 'endo': numCases = rand(4, 8); break;
    case 'NORA': numCases = rand(3, 6); break;
    case 'ACS': numCases = rand(2, 5); break;
    case 'cardiac_liver': numCases = rand(1, 3); break;
    case 'mole': numCases = rand(2, 4); break;
    case '1st_call': case '2nd_call': case '3rd_call': case '4th_call':
      numCases = rand(0, 3); break;
    default: numCases = rand(2, 4);
  }

  // For endo shifts, mostly colonoscopies/EGDs
  const endoProcs = [
    { name: 'Colonoscopy', units: 4 },
    { name: 'EGD', units: 5 },
    { name: 'EGD + Colonoscopy', units: 5 },
    { name: 'Colonoscopy', units: 4 },
    { name: 'Colonoscopy', units: 4 }
  ];

  // Decide if we should include special case types
  const includeLabor = ['OB_restricted'].includes(aType) && Math.random() < 0.6;
  const includeAPS = Math.random() < 0.08;

  // Use first time entry start as case time baseline
  const entryStart = timeEntries[0].start;
  let caseHour = parseInt(entryStart.split(':')[0]);
  let caseMin = parseInt(entryStart.split(':')[1]) + rand(10, 30);
  if (caseMin >= 60) { caseHour++; caseMin -= 60; }

  for (let i = 0; i < numCases; i++) {
    const startH = caseHour;
    const startM = caseMin;

    // Determine case type
    let caseType = 'standard';
    if (i === 0 && includeLabor) caseType = 'labor_epidural';
    else if (i === numCases - 1 && includeAPS) caseType = 'aps_rounding';

    const c = {
      id: genId() + '_' + i + '_' + dateStr.replace(/-/g,''),
      shiftDate: dateStr,
      caseType: caseType,
      timestamp: new Date().toISOString()
    };

    if (caseType === 'standard') {
      const proc = aType === 'endo' ? pick(endoProcs) : pick(procedures);
      const duration = aType === 'endo' ? rand(15, 35) : rand(30, 180);
      const endTotalMin = startH * 60 + startM + duration;
      const endH = Math.min(Math.floor(endTotalMin / 60), 23);
      const endM = endTotalMin % 60;

      c.procedure = proc.name;
      c.baseUnits = proc.units;
      c.physicalStatus = pick(physStatuses);
      c.startTime = fmtTime(startH, startM);
      c.endTime = fmtTime(endH, endM);
      c.isEmergency = Math.random() < 0.05;
      c.isMedicalProc = false;
      c.medicalUnits = 0;
      c.isAcutePain = false;
      c.acutePainUnits = 0;
      c.isHighRiskPeds = Math.random() < 0.03;
      c.isORCase = ['SF1','SF2'].includes(aType) ? (Math.random() < 0.3) : false;
      c.nerveBlock = pick(nerveBlocks);
      c.hasCentralLine = Math.random() < 0.08;
      c.hasArterialLine = Math.random() < 0.12;
      c.hasPAC = Math.random() < 0.05;
      c.hasTEEAddOn = aType === 'cardiac_liver' ? (Math.random() < 0.3) : (Math.random() < 0.02);
      c.hasITMorphine = Math.random() < 0.06;
      c.isSharedCase = Math.random() < 0.08;
      c.sharedStartupPct = c.isSharedCase ? pick([50, 50, 50, 25, 75]) : 50;
      c.epiduralRounds = 0;
      c.painRounds = 0;
      c.notes = '';

      // Advance time for next case
      caseHour = endH;
      caseMin = endM + rand(10, 30);
      if (caseMin >= 60) { caseHour++; caseMin -= 60; }

    } else if (caseType === 'labor_epidural') {
      const duration = rand(60, 480);
      const endTotalMin = startH * 60 + startM + duration;
      const endH = Math.min(Math.floor(endTotalMin / 60), 23);
      const endM = endTotalMin % 60;

      c.procedure = 'Labor Epidural';
      c.baseUnits = '';
      c.physicalStatus = pick(['P1','P2','P2','P2','P3']);
      c.startTime = fmtTime(startH, startM);
      c.endTime = fmtTime(endH, endM);
      c.isEmergency = false;
      c.isMedicalProc = false;
      c.medicalUnits = 0;
      c.isAcutePain = false;
      c.acutePainUnits = 0;
      c.isHighRiskPeds = false;
      c.isORCase = false;
      c.nerveBlock = 'none';
      c.hasCentralLine = false;
      c.hasArterialLine = false;
      c.hasPAC = false;
      c.hasTEEAddOn = false;
      c.epiduralRounds = 0;
      c.painRounds = 0;
      c.notes = '';

      caseHour = endH;
      caseMin = endM + rand(10, 30);
      if (caseMin >= 60) { caseHour++; caseMin -= 60; }

    } else if (caseType === 'aps_rounding') {
      c.procedure = 'APS Rounding';
      c.baseUnits = '';
      c.physicalStatus = '';
      c.startTime = '';
      c.endTime = '';
      c.isEmergency = false;
      c.isMedicalProc = false;
      c.medicalUnits = 0;
      c.isAcutePain = false;
      c.acutePainUnits = 0;
      c.isHighRiskPeds = false;
      c.isORCase = false;
      c.nerveBlock = 'none';
      c.hasCentralLine = false;
      c.hasArterialLine = false;
      c.hasPAC = false;
      c.hasTEEAddOn = false;
      c.epiduralRounds = rand(2, 8);
      c.painRounds = rand(1, 6);
      c.notes = '';
    }

    data.cases.push(c);
  }
}

function downloadFile(content, filename, type) {
  const blob = new Blob([content], { type });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
}

// ================================================================
// SETTINGS
// ================================================================
const nameInput = document.getElementById('settingsName');
nameInput.value = settings.name || '';
nameInput.addEventListener('change', () => {
  settings.name = nameInput.value;
  saveSettings(settings);
  showToast('Name saved');
});

const pointValueInput = document.getElementById('settingsPointValue');
const dashPointValueInput = document.getElementById('dashPointValue');
pointValueInput.value = settings.pointValue || '';
dashPointValueInput.value = settings.pointValue || '';

function syncPointValue(source) {
  settings.pointValue = parseFloat(source.value) || 0;
  saveSettings(settings);
  // Keep both inputs in sync
  pointValueInput.value = source.value;
  dashPointValueInput.value = source.value;
  // Re-render projections that depend on $/pt
  renderStabilization();
  renderProjectedAnnual();
  renderMonthlyPace();
  renderPipelineChart();
  renderMonthlyChart();
}

pointValueInput.addEventListener('change', () => {
  syncPointValue(pointValueInput);
  showToast('Point value saved');
});

dashPointValueInput.addEventListener('change', () => {
  syncPointValue(dashPointValueInput);
  showToast('Point value saved');
});

document.getElementById('monthlyTrendToggle').addEventListener('click', () => {
  monthlyShowDollars = !monthlyShowDollars;
  renderMonthlyChart();
});

// December advance paycheck toggle
const decAdvToggle = document.getElementById('decAdvanceToggle');
decAdvToggle.checked = settings.decemberAdvance !== false;
decAdvToggle.addEventListener('change', () => {
  settings.decemberAdvance = decAdvToggle.checked;
  saveSettings(settings);
  renderStabilization();
  renderPipelineChart();
});

// Vision API key
const visionKeyInput = document.getElementById('settingsVisionKey');
visionKeyInput.value = settings.visionApiKey || '';
visionKeyInput.addEventListener('change', () => {
  settings.visionApiKey = visionKeyInput.value.trim();
  saveSettings(settings);
  showToast('Vision API key saved');
});

document.getElementById('pipelineProjectToggle').addEventListener('change', () => {
  renderPipelineChart();
});

// ================================================================
// HEADER POINTS
// ================================================================
function updateHeaderPoints() {
  const date = workingDate;
  const shift = data.shifts[date];
  const dailyPts = shift ? calcShiftTotal(shift).total : 0;
  // Monthly total
  const prefix = date.substring(0, 7);
  let monthPts = 0;
  const monthShifts = [];
  Object.values(data.shifts).forEach(s => {
    if (s.date && s.date.startsWith(prefix)) {
      monthPts += calcShiftTotal(s).total;
      monthShifts.push(s);
    }
  });
  monthPts = round2(monthPts);

  // Pace calculation — how far ahead/behind prior month average
  let paceHtml = '';
  const now = new Date();
  const thisPrefix = now.getFullYear() + '-' + String(now.getMonth() + 1).padStart(2, '0');
  if (prefix === thisPrefix) {
    const dayOfMonth = now.getDate();
    const daysInMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0).getDate();
    const vacDays = monthShifts.filter(s => s.assignmentType === 'vacation');
    const vacDaysPassed = vacDays.filter(s => parseInt(s.date.split('-')[2]) <= dayOfMonth).length;
    const workingDaysInMonth = daysInMonth - vacDays.length;
    const workingDaysElapsed = dayOfMonth - vacDaysPassed;
    const vacRatio = workingDaysInMonth / daysInMonth;

    const mt = getMonthlyTotals();
    let sumAtDay = 0;
    let curveCount = 0;
    for (let offset = 1; offset <= 6; offset++) {
      const d = new Date(now.getFullYear(), now.getMonth() - offset, 1);
      const key = d.getFullYear() + '-' + String(d.getMonth() + 1).padStart(2, '0');
      if (!mt[key]) continue;
      const mDays = new Date(d.getFullYear(), d.getMonth() + 1, 0).getDate();
      const shifts = Object.values(data.shifts).filter(s => s.date.startsWith(key));
      if (shifts.length === 0) continue;
      const dailyP = new Array(mDays + 1).fill(0);
      shifts.forEach(s => { dailyP[parseInt(s.date.split('-')[2])] += calcShiftTotal(s).total; });
      const cum = new Array(mDays + 1).fill(0);
      for (let i = 1; i <= mDays; i++) cum[i] = cum[i - 1] + dailyP[i];
      const frac = workingDaysInMonth > 0 ? workingDaysElapsed / workingDaysInMonth : 0;
      const mapped = frac * mDays;
      const lo = Math.floor(mapped);
      const hi = Math.min(Math.ceil(mapped), mDays);
      const f = mapped - lo;
      sumAtDay += lo >= 1 ? cum[lo] * (1 - f) + cum[hi] * f : cum[hi] * f;
      curveCount++;
    }
    if (curveCount > 0) {
      const expected = round2((sumAtDay / curveCount) * vacRatio);
      const delta = round2(monthPts - expected);
      const cls = delta >= 0 ? 'ahead' : 'behind';
      const sign = delta >= 0 ? '+' : '';
      paceHtml = `<span class="pace ${cls}">${sign}${delta.toFixed(0)} pace</span>`;
    }
  }

  const el = document.getElementById('headerPoints');
  el.innerHTML = `<span class="daily">${dailyPts.toFixed(1)} pts</span><br><span class="monthly">${monthPts.toFixed(0)} mo</span>` + (paceHtml ? `<br>${paceHtml}` : '');
}

// ================================================================
// RECONCILE PAGE — Tab switching
// ================================================================
// Main reconcile tabs
document.querySelectorAll('#dtab-reconcile > .tab-bar > .tab-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('#dtab-reconcile > .tab-bar > .tab-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    document.getElementById('rtab-qgenda').classList.toggle('hidden', btn.dataset.rtab !== 'qgenda');
    document.getElementById('rtab-production').classList.toggle('hidden', btn.dataset.rtab !== 'production');
  });
});


function renderReconTabs() {
  updateReconMonthLabels();
}

// ================================================================
// QGENDA RECONCILIATION
// ================================================================
let qgendaData = [];
let qYear = new Date().getFullYear();
let qMonth = new Date().getMonth();
let shiftReconDiffs = [];
let shiftReconCurrentDiff = 0;
let shiftReconDecisions = {};
let qgendaExpandedDays = {};

function loadShiftReconDecisions() {
  try {
    const raw = localStorage.getItem(SHIFT_RECON_DECISIONS_KEY);
    if (raw) shiftReconDecisions = JSON.parse(raw);
  } catch(e) { shiftReconDecisions = {}; }
}
function saveShiftReconDecisions() {
  localStorage.setItem(SHIFT_RECON_DECISIONS_KEY, JSON.stringify(shiftReconDecisions));
}

function updateReconMonthLabels() {
  const mn = ['January','February','March','April','May','June','July','August','September','October','November','December'];
  document.getElementById('qMonthLabel').textContent = `${mn[qMonth]} ${qYear}`;
  document.getElementById('pMonthLabel').textContent = `${mn[pMonth]} ${pYear}`;
}

document.getElementById('qPrevMonth').addEventListener('click', () => { qMonth--; if (qMonth < 0) { qMonth = 11; qYear--; } updateReconMonthLabels(); renderQgendaRecon(); });
document.getElementById('qNextMonth').addEventListener('click', () => { qMonth++; if (qMonth > 11) { qMonth = 0; qYear++; } updateReconMonthLabels(); renderQgendaRecon(); });

// Upload area
document.getElementById('qgendaUploadArea').addEventListener('click', () => document.getElementById('qgendaFile').click());

function processQgendaRows(rows) {
  qgendaData = rows.map(r => {
    let schedDate = parseExcelDate(r['Schedule Date']);
    let clockInDate = parseExcelDate(r['Effective Clock In Date']);
    let clockOutDate = parseExcelDate(r['Effective Clock Out Date']);
    return {
      scheduleDate: schedDate,
      clockInDate: clockInDate,
      clockInTime: parseExcelTime(r['Effective Clock In Time']),
      clockOutDate: clockOutDate,
      clockOutTime: parseExcelTime(r['Effective Clock Out Time']),
      duration: parseFloat(r['Duration']) || 0,
      task: String(r['Scheduled Task Abbreviation'] || ''),
      location: String(r['Location Name'] || ''),
      notes: String(r['Notes'] || '')
    };
  });
  localStorage.setItem(QGENDA_KEY, JSON.stringify(qgendaData));
  showToast(`Loaded ${qgendaData.length} QGenda entries`);
  if (qgendaData.length > 0 && qgendaData[0].scheduleDate) {
    const d = new Date(qgendaData[0].scheduleDate + 'T12:00:00');
    if (!isNaN(d)) { qYear = d.getFullYear(); qMonth = d.getMonth(); updateReconMonthLabels(); }
  }
  renderQgendaRecon();
}

function parseCSVRows(text) {
  const lines = text.split('\n').map(l => l.trim()).filter(l => l);
  if (lines.length < 2) return [];
  // Parse header row — handle quoted fields
  const parseCSVLine = (line) => {
    const fields = [];
    let current = '', inQuotes = false;
    for (let i = 0; i < line.length; i++) {
      const ch = line[i];
      if (ch === '"') { inQuotes = !inQuotes; }
      else if (ch === ',' && !inQuotes) { fields.push(current.trim()); current = ''; }
      else { current += ch; }
    }
    fields.push(current.trim());
    return fields;
  };
  const headers = parseCSVLine(lines[0]);
  const rows = [];
  for (let i = 1; i < lines.length; i++) {
    const vals = parseCSVLine(lines[i]);
    const obj = {};
    headers.forEach((h, idx) => { obj[h] = vals[idx] || ''; });
    rows.push(obj);
  }
  return rows;
}

document.getElementById('qgendaFile').addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const isImage = /\.(png|jpg|jpeg)$/i.test(file.name);
  const isCSV = /\.csv$/i.test(file.name);

  if (isImage) {
    try {
      showToast('Running OCR on image...');
      const text = await ocrImage(file);
      qgendaData = parseQgendaScreenshot(text);
      localStorage.setItem(QGENDA_KEY, JSON.stringify(qgendaData));
      showToast(`OCR found ${qgendaData.length} QGenda entries`);
      if (qgendaData.length > 0 && qgendaData[0].scheduleDate) {
        const d = new Date(qgendaData[0].scheduleDate + 'T12:00:00');
        if (!isNaN(d)) { qYear = d.getFullYear(); qMonth = d.getMonth(); updateReconMonthLabels(); }
      }
      renderQgendaRecon();
    } catch(err) {
      showToast('OCR error: ' + err.message);
    }
  } else if (isCSV) {
    const reader = new FileReader();
    reader.onload = (ev) => {
      try {
        const rows = parseCSVRows(ev.target.result);
        processQgendaRows(rows);
      } catch(err) {
        showToast('Error reading CSV: ' + err.message);
      }
    };
    reader.readAsText(file);
  } else {
    const reader = new FileReader();
    reader.onload = (ev) => {
      try {
        const wb = XLSX.read(ev.target.result, { type: 'array' });
        const ws = wb.Sheets[wb.SheetNames[0]];
        const rows = XLSX.utils.sheet_to_json(ws, { defval: '' });
        processQgendaRows(rows);
      } catch(err) {
        showToast('Error reading QGenda file: ' + err.message);
      }
    };
    reader.readAsArrayBuffer(file);
  }
  e.target.value = '';
});

function parseExcelDate(val) {
  if (!val && val !== 0) return '';
  // Excel serial number
  if (typeof val === 'number') {
    const d = new Date((val - 25569) * 86400 * 1000);
    return d.getUTCFullYear() + '-' + String(d.getUTCMonth()+1).padStart(2,'0') + '-' + String(d.getUTCDate()).padStart(2,'0');
  }
  // String like "1/2/2026" or "2026-01-02"
  const s = String(val).trim();
  if (s.includes('-') && s.length === 10) return s; // already YYYY-MM-DD
  const parts = s.split('/');
  if (parts.length === 3) {
    let [m, d, y] = parts.map(Number);
    if (y < 100) y += 2000;
    return y + '-' + String(m).padStart(2,'0') + '-' + String(d).padStart(2,'0');
  }
  return s;
}

function parseExcelTime(val) {
  if (!val && val !== 0) return '';
  // Excel fractional day (0.0 to ~1.0) or full serial date-time (extract fractional part)
  if (typeof val === 'number') {
    const frac = val >= 1 ? val - Math.floor(val) : val;
    const totalMin = Math.round(frac * 1440);
    const h = Math.floor(totalMin / 60) % 24;
    const m = totalMin % 60;
    return String(h).padStart(2,'0') + ':' + String(m).padStart(2,'0');
  }
  // String like "7:00" or "13:01"
  const s = String(val).trim();
  if (s.includes(':')) {
    const [h, m] = s.split(':').map(Number);
    return String(h).padStart(2,'0') + ':' + String(m || 0).padStart(2,'0');
  }
  return s;
}

function renderQgendaRecon() {
  // Load cached data if needed
  if (qgendaData.length === 0) {
    try {
      const cached = localStorage.getItem(QGENDA_KEY);
      if (cached) qgendaData = JSON.parse(cached);
    } catch(e) {}
  }
  loadShiftReconDecisions();

  const container = document.getElementById('qgendaResults');
  const prefix = `${qYear}-${String(qMonth+1).padStart(2,'0')}`;

  const qEntries = qgendaData.filter(e => e.scheduleDate && e.scheduleDate.startsWith(prefix));
  const trackerShifts = Object.values(data.shifts).filter(s => s.date.startsWith(prefix));

  if (qgendaData.length === 0) {
    container.innerHTML = '<div class="empty-state"><p>Upload a QGenda export file to begin reconciliation.</p></div>';
    return;
  }
  if (qEntries.length === 0 && trackerShifts.length === 0) {
    container.innerHTML = '<div class="empty-state"><p>No data for this month in QGenda or Tracker.</p></div>';
    return;
  }

  // Group QGenda by schedule date
  const qByDate = {};
  qEntries.forEach(e => {
    if (!qByDate[e.scheduleDate]) qByDate[e.scheduleDate] = [];
    qByDate[e.scheduleDate].push(e);
  });

  const allDates = new Set([...Object.keys(qByDate), ...trackerShifts.map(s => s.date)]);
  const sortedDates = [...allDates].sort();

  // Build diffs and totals
  let qTotalHours = 0, tTotalHours = 0, matchCount = 0;
  shiftReconDiffs = [];

  // Build per-day data for dashboard
  const dayData = [];

  sortedDates.forEach(date => {
    const qDay = qByDate[date] || [];
    const tShift = data.shifts[date];

    const qHours = qDay.reduce((s, e) => s + e.duration, 0);
    qTotalHours += qHours;

    let tHours = 0;
    if (tShift) {
      tHours = calcShiftHours(tShift);
      tTotalHours += tHours;
    }

    const forcedOffEntry = qDay.find(e => /FORCED?\s*OFF/i.test(e.task || ''));
    const qTask = forcedOffEntry ? forcedOffEntry.task : (qDay.length > 0 ? qDay[0].task : '');
    const qAssignType = qTask ? mapTaskToAssignmentType(qTask, date) : '';
    const tAssignType = tShift ? (tShift.forcedOff ? 'forced_off' : tShift.assignmentType) : '';
    const qIsForcedOff = qAssignType === 'forced_off' || !!forcedOffEntry;
    const tIsForcedOff = tAssignType === 'forced_off' || (tShift && tShift.forcedOff);

    const sortedQ = [...qDay].filter(e => e.clockInTime).sort((a, b) => a.clockInTime.localeCompare(b.clockInTime));
    const qTimeEntries = sortedQ.map(e => ({ start: e.clockInTime, end: e.clockOutTime || '' }));

    // Build virtual shift from QGenda entries for point comparison
    let qPoints = 0;
    if (qDay.length > 0) {
      const qVirtual = {
        date, assignmentType: qAssignType,
        startTime: sortedQ.length > 0 ? sortedQ[0].clockInTime : '',
        endTime: sortedQ.length > 0 ? sortedQ[sortedQ.length - 1].clockOutTime || '' : '',
        timeEntries: sortedQ.map(e => ({ start: e.clockInTime || '', end: e.clockOutTime || '' })),
        isHoliday: tShift ? tShift.isHoliday : false,
        forcedOff: qIsForcedOff,
        subspecCoverage: false, teeCount: 0,
        supervisionStart: '', supervisionEnd: '',
        preCallStart: '', preCallEnd: '', tempCoverage: []
      };
      qPoints = round2(calcShiftTotal(qVirtual).total);
    }
    const tPoints = tShift ? round2(calcShiftTotal(tShift).total) : 0;

    let dayStatus = 'match', diffType = '';
    if (qDay.length > 0 && tShift) {
      const hourDiff = Math.abs(qHours - tHours);
      const tHasNoTimes = !tShift.timeEntries || tShift.timeEntries.length === 0 || tShift.timeEntries.every(e => !e.start || !e.end);
      if (qIsForcedOff && tIsForcedOff) {
        matchCount++;
      } else if (qAssignType === tAssignType && (tHasNoTimes || tHours === 0 || qHours === 0)) {
        matchCount++;
      } else if (hourDiff <= 0.25 && qAssignType === tAssignType) {
        matchCount++;
      } else if (Math.abs(qPoints - tPoints) < 0.5 && qPoints > 0) {
        matchCount++;
      } else if (hourDiff > 0.25) {
        dayStatus = 'mismatch'; diffType = 'hour_mismatch';
      } else {
        dayStatus = 'close'; diffType = 'type_mismatch';
      }
      if (dayStatus !== 'match') {
        console.log('[RECON mismatch]', date, {
          qTask, qAssignType, tAssignType, qHours, tHours, hourDiff,
          qPoints, tPoints,
          qIsForcedOff, tIsForcedOff, tHasNoTimes,
          tForcedOff: tShift.forcedOff, tShiftType: tShift.assignmentType,
          qEntryTasks: qDay.map(e => e.task)
        });
      }
    } else if (qDay.length > 0 && !tShift) {
      dayStatus = 'missing'; diffType = 'missing_tracker';
    } else if (qDay.length === 0 && tShift) {
      if (tIsForcedOff) {
        dayStatus = 'match'; diffType = 'forced_off_verify';
        matchCount++;
      } else {
        dayStatus = 'missing'; diffType = 'missing_qgenda';
      }
    }

    const diffObj = {
      date, type: diffType || 'match',
      qgendaEntries: qDay, qgendaHours: qHours, qgendaTask: qTask,
      qgendaAssignmentType: qAssignType, qgendaTimeEntries: qTimeEntries,
      trackerShift: tShift, trackerHours: tHours, trackerAssignmentType: tAssignType,
      hourDiff: Math.abs(qHours - tHours)
    };

    if (dayStatus !== 'match') shiftReconDiffs.push(diffObj);
    const forcedOffVerify = diffType === 'forced_off_verify';
    dayData.push({ date, qDay, tShift, qHours, tHours, qTask, qAssignType, tAssignType, dayStatus, diffObj, qTimeEntries, qPoints, tPoints, forcedOffVerify });
  });

  // Tracker points for the month
  let tTotalPoints = 0;
  trackerShifts.forEach(s => { tTotalPoints += calcShiftTotal(s).total; });
  tTotalPoints = round2(tTotalPoints);

  const issueCount = shiftReconDiffs.length;

  // === Summary Dashboard ===
  let html = '<div class="card">';
  html += '<div class="recon-summary-bar">';
  html += `<div class="stat green"><div class="num">${matchCount}</div><div class="lbl">Matched</div></div>`;
  html += `<div class="stat yellow"><div class="num">${issueCount}</div><div class="lbl">Issues</div></div>`;
  html += `<div class="stat"><div class="num">${tTotalPoints.toFixed(0)}</div><div class="lbl">Tracker Pts</div></div>`;
  html += '</div>';
  html += '<div class="recon-pts-compare">';
  html += `<div>QGenda: <span style="color:var(--primary)">${qTotalHours.toFixed(1)}h</span></div>`;
  html += `<div>Tracker: <span style="color:var(--accent)">${tTotalHours.toFixed(1)}h</span></div>`;
  html += '</div>';
  html += '</div>';

  if (issueCount === 0 && matchCount > 0) {
    html += '<div class="card" style="text-align:center;padding:24px;"><p style="color:var(--accent);font-size:1.1rem;font-weight:600;">All shifts match!</p></div>';
  }

  // === Daily Breakdown (expandable days) ===
  html += '<div class="card"><h2>Daily Breakdown</h2>';
  dayData.forEach(dd => {
    const decision = shiftReconDecisions[dd.date];
    const isResolved = decision && (decision.accepted === 'qgenda' || decision.accepted === 'app');
    const isFlagged = decision && decision.flagged;
    let statusCls = dd.dayStatus;
    if (dd.forcedOffVerify) statusCls = 'close';
    if (isResolved) statusCls = 'match';

    const isExpanded = qgendaExpandedDays[dd.date] !== undefined ? qgendaExpandedDays[dd.date] : (dd.dayStatus !== 'match' || dd.forcedOffVerify);
    if (qgendaExpandedDays[dd.date] === undefined) qgendaExpandedDays[dd.date] = isExpanded;

    const qTimes = dd.qDay.map(e => `${e.clockInTime || '?'}-${e.clockOutTime || '?'}`).join(', ');
    const tEntries = dd.tShift && dd.tShift.timeEntries ? dd.tShift.timeEntries : (dd.tShift ? [{ start: dd.tShift.startTime, end: dd.tShift.endTime }] : []);
    const tTimes = tEntries.map(e => `${e.start || '?'}-${e.end || '?'}`).join(', ');

    // Status label
    const typeLabels = {
      match: 'Match', hour_mismatch: 'Hours', type_mismatch: 'Type',
      missing_tracker: 'No App', missing_qgenda: 'No QGenda'
    };

    html += `<div class="recon-day status-${statusCls}${isExpanded ? ' expanded' : ''}" data-date="${dd.date}">`;
    html += `<div class="recon-day-header" onclick="toggleQgendaDay('${dd.date}')">`;
    html += `<span class="day-date">${formatDateShort(dd.date)}</span>`;
    html += `<span class="day-info">${dd.qPoints.toFixed(1)}pt Q / ${dd.tPoints.toFixed(1)}pt App</span>`;
    html += `<span class="day-status s-${statusCls}">${isResolved ? 'Accepted' : (isFlagged ? 'Flagged' : (dd.forcedOffVerify ? 'Verify' : (typeLabels[dd.diffObj.type] || dd.dayStatus)))}</span>`;
    html += '<span class="day-chevron">&#9660;</span>';
    html += '</div>';

    // Day detail
    html += '<div class="recon-day-detail">';
    html += '<table class="recon-case-table"><thead><tr><th>Source</th><th>Type</th><th>Times</th><th>Hours</th></tr></thead><tbody>';
    if (dd.qDay.length > 0) {
      dd.qDay.forEach(entry => {
        const entryType = mapTaskToAssignmentType(entry.task || '', dd.date);
        const entryTimes = entry.clockInTime ? `${entry.clockInTime}-${entry.clockOutTime || '?'}` : '\u2014';
        html += `<tr><td style="color:var(--primary)">QGenda</td><td>${getAssignmentTypeName(entryType)}<br><small style="color:var(--muted)">${entry.task || ''}</small></td><td>${entryTimes}</td><td>${entry.duration.toFixed(1)}h</td></tr>`;
      });
      html += `<tr style="border-top:1px solid var(--border)"><td></td><td style="color:var(--primary);font-weight:600">QGenda Total</td><td></td><td style="font-weight:600">${dd.qHours.toFixed(1)}h (${dd.qPoints.toFixed(1)} pts)</td></tr>`;
    } else {
      if (dd.forcedOffVerify) {
        html += '<tr><td style="color:var(--primary)">QGenda</td><td colspan="3"><span style="color:var(--muted)">Force-off shifts are not included in QGenda time reports</span></td></tr>';
      } else {
        html += '<tr><td style="color:var(--primary)">QGenda</td><td colspan="3"><span style="color:var(--danger)">No entry</span></td></tr>';
      }
    }
    if (dd.tShift) {
      const shiftTotals = calcShiftTotal(dd.tShift);
      html += `<tr><td style="color:var(--accent)">App</td><td>${getAssignmentTypeName(dd.tAssignType)}</td><td>${tTimes}</td><td>${dd.tHours.toFixed(1)}h (${shiftTotals.total.toFixed(1)} pts)</td></tr>`;
    } else {
      html += '<tr><td style="color:var(--accent)">App</td><td colspan="3"><span style="color:var(--danger)">No shift</span></td></tr>';
    }
    html += '</tbody></table>';

    // Inline actions for issues
    if (dd.dayStatus !== 'match' && !isResolved && !isFlagged) {
      html += '<div class="case-actions" style="margin-top:8px;">';
      html += `<button onclick="shiftReconAcceptQgendaInline('${dd.date}')">Accept QGenda</button>`;
      if (dd.tShift) {
        html += `<button onclick="shiftReconAcceptAppInline('${dd.date}')">Accept App</button>`;
      }
      html += `<button class="act-flag" onclick="shiftReconFlagInline('${dd.date}')">Flag</button>`;
      html += '</div>';
    }
    html += '</div></div>';
  });
  html += '</div>';

  // === Flagged section ===
  html += '<div id="shiftReconFlaggedSection"></div>';

  container.innerHTML = html;
  renderShiftReconFlagged();
}

function toggleQgendaDay(dateStr) {
  qgendaExpandedDays[dateStr] = !qgendaExpandedDays[dateStr];
  const dayEl = document.querySelector(`#qgendaResults .recon-day[data-date="${dateStr}"]`);
  if (dayEl) dayEl.classList.toggle('expanded');
}

// Apply QGenda data to tracker shift (inline version)
function applyQgendaToShift(d) {
  if (d.type === 'missing_tracker') {
    const entries = d.qgendaEntries;
    const sortedEntries = [...entries].filter(e => e.clockInTime).sort((a, b) => a.clockInTime.localeCompare(b.clockInTime));
    const timeEntries = sortedEntries.map(e => ({ start: e.clockInTime, end: e.clockOutTime || '' }));
    let earliest = '23:59', latest = '00:00';
    entries.forEach(e => {
      if (e.clockInTime && e.clockInTime < earliest) earliest = e.clockInTime;
      if (e.clockOutTime && e.clockOutTime > latest) latest = e.clockOutTime;
    });
    const reconAssignType = d.qgendaAssignmentType || 'OR';
    const reconHasPager = getPagerPayWindow(reconAssignType, isWeekend(d.date)) !== null;
    const reconTimeEntries = timeEntries.length > 0 ? timeEntries : reconHasPager ? [] : [{ start: earliest, end: latest }];
    data.shifts[d.date] = {
      date: d.date, assignmentType: reconAssignType,
      startTime: timeEntries.length > 0 ? earliest : '',
      endTime: timeEntries.length > 0 ? latest : '',
      timeEntries: reconTimeEntries, isHoliday: false, forcedOff: false,
      subspecCoverage: false, teeCount: 0, supervisionStart: '', supervisionEnd: '',
      preCallStart: '', preCallEnd: '', tempCoverage: []
    };
    const pcPattern = /UVH\/SFH\s*WORK/i;
    const pcEntries = entries.filter(e => e.clockInTime && pcPattern.test(e.task || ''));
    if (pcEntries.length > 0 && ['mole','OB_restricted'].includes(reconAssignType)) {
      const sortedPC = [...pcEntries].sort((a, b) => a.clockInTime.localeCompare(b.clockInTime));
      data.shifts[d.date].preCallStart = sortedPC[0].clockInTime;
      data.shifts[d.date].preCallEnd = sortedPC[sortedPC.length - 1].clockOutTime || '';
    }
    showToast(`Created shift for ${formatDateShort(d.date)}`);
  } else if (d.type === 'hour_mismatch' || d.type === 'type_mismatch') {
    const shift = data.shifts[d.date];
    if (shift) {
      if (d.qgendaTimeEntries.length > 0) {
        shift.timeEntries = d.qgendaTimeEntries;
        let earliest = '23:59', latest = '00:00';
        d.qgendaEntries.forEach(e => {
          if (e.clockInTime && e.clockInTime < earliest) earliest = e.clockInTime;
          if (e.clockOutTime && e.clockOutTime > latest) latest = e.clockOutTime;
        });
        shift.startTime = earliest;
        shift.endTime = latest;
      }
      if (d.type === 'type_mismatch' && d.qgendaAssignmentType) {
        shift.assignmentType = d.qgendaAssignmentType;
      }
      showToast(`Updated shift for ${formatDateShort(d.date)}`);
    }
  } else if (d.type === 'missing_qgenda') {
    delete data.shifts[d.date];
    showToast(`Removed shift for ${formatDateShort(d.date)}`);
  }
  saveData(data);
  updateHeaderPoints();
}

function shiftReconAcceptQgendaInline(date) {
  const d = shiftReconDiffs.find(x => x.date === date);
  if (!d) return;
  applyQgendaToShift(d);
  shiftReconDecisions[date] = { accepted: 'qgenda', flagged: false };
  saveShiftReconDecisions();
  renderQgendaRecon();
}

function shiftReconAcceptAppInline(date) {
  shiftReconDecisions[date] = { accepted: 'app', flagged: false };
  saveShiftReconDecisions();
  renderQgendaRecon();
}

function shiftReconFlagInline(date) {
  shiftReconDecisions[date] = { accepted: '', flagged: true };
  saveShiftReconDecisions();
  renderQgendaRecon();
}

function renderShiftReconFlagged() {
  const section = document.getElementById('shiftReconFlaggedSection');
  if (!section) return;

  const mn = ['January','February','March','April','May','June','July','August','September','October','November','December'];
  const monthLabel = `${mn[qMonth]} ${qYear}`;

  const allFlagged = [];
  shiftReconDiffs.forEach(d => {
    const dec = shiftReconDecisions[d.date];
    if (dec && dec.flagged) allFlagged.push(d);
  });

  if (allFlagged.length === 0) {
    section.innerHTML = '';
    return;
  }

  let html = '<div class="card"><h2>Flagged Issues (' + allFlagged.length + ')</h2>';
  html += '<ul class="flagged-list">';
  allFlagged.forEach(f => {
    const qTimes = f.qgendaEntries.map(e => `${e.clockInTime || '?'}-${e.clockOutTime || '?'}`).join(', ');
    if (f.type === 'missing_tracker') {
      html += `<li>${formatDateShort(f.date)} — Missing from Tracker (QGenda: ${f.qgendaHours.toFixed(1)}h, ${qTimes})</li>`;
    } else if (f.type === 'missing_qgenda') {
      html += `<li>${formatDateShort(f.date)} — Missing from QGenda (App: ${getAssignmentTypeName(f.trackerAssignmentType)}, ${f.trackerHours.toFixed(1)}h)</li>`;
    } else if (f.type === 'type_mismatch') {
      html += `<li>${formatDateShort(f.date)} — Type mismatch: QGenda=${getAssignmentTypeName(f.qgendaAssignmentType)}, App=${getAssignmentTypeName(f.trackerAssignmentType)}</li>`;
    } else {
      html += `<li>${formatDateShort(f.date)} — QGenda: ${f.qgendaHours.toFixed(1)}h, App: ${f.trackerHours.toFixed(1)}h (${f.hourDiff.toFixed(1)}h diff)</li>`;
    }
  });
  html += '</ul>';

  html += '<div style="margin-top:16px;">';
  html += '<button class="btn btn-primary" onclick="generateShiftReconEmail()" style="width:100%;margin-bottom:8px;">Generate Email</button>';
  html += '<div id="shiftReconEmailPreview"></div>';
  html += '</div></div>';

  section.innerHTML = html;
}

function generateShiftReconEmail() {
  const mn = ['January','February','March','April','May','June','July','August','September','October','November','December'];
  const monthLabel = `${mn[qMonth]} ${qYear}`;
  const userName = settings.name || '[Your Name]';

  const allFlagged = [];
  shiftReconDiffs.forEach(d => {
    const dec = shiftReconDecisions[d.date];
    if (dec && dec.flagged) allFlagged.push(d);
  });

  let emailText = `Subject: QGenda Time Discrepancies — ${monthLabel}\n\nHi,\n\nI found the following time discrepancies during QGenda reconciliation for ${monthLabel}:\n\n`;

  allFlagged.forEach((f, i) => {
    const dateFormatted = f.date.replace(/(\d{4})-(\d{2})-(\d{2})/, '$2/$3/$1');
    const qTimes = f.qgendaEntries.map(e => `${e.clockInTime || '?'}-${e.clockOutTime || '?'}`).join(', ');
    const tEntries = f.trackerShift && f.trackerShift.timeEntries ? f.trackerShift.timeEntries : (f.trackerShift ? [{ start: f.trackerShift.startTime, end: f.trackerShift.endTime }] : []);
    const tTimes = tEntries.map(e => `${e.start || '?'}-${e.end || '?'}`).join(', ');

    if (f.type === 'missing_tracker') {
      emailText += `${i + 1}. Date: ${dateFormatted} — QGenda: ${f.qgendaHours.toFixed(1)}h (${qTimes}), not in app\n   Please verify this shift was recorded\n\n`;
    } else if (f.type === 'missing_qgenda') {
      emailText += `${i + 1}. Date: ${dateFormatted} — Shift missing from QGenda (App: ${getAssignmentTypeName(f.trackerAssignmentType)}, ${f.trackerHours.toFixed(1)}h)\n   Please verify this shift was recorded\n\n`;
    } else if (f.type === 'type_mismatch') {
      emailText += `${i + 1}. Date: ${dateFormatted} — Assignment type mismatch: QGenda=${getAssignmentTypeName(f.qgendaAssignmentType)}, App=${getAssignmentTypeName(f.trackerAssignmentType)}\n   App times are correct\n\n`;
    } else {
      emailText += `${i + 1}. Date: ${dateFormatted} — QGenda: ${f.qgendaHours.toFixed(1)}h (${qTimes}), App: ${f.trackerHours.toFixed(1)}h (${tTimes})\n   ${f.hourDiff.toFixed(1)}h difference — app times are correct\n\n`;
    }
  });

  emailText += `Please review and advise.\n\nThanks,\n${userName}`;

  const preview = document.getElementById('shiftReconEmailPreview');
  preview.innerHTML = `<div class="email-preview">${escHtml(emailText)}</div>`;
  preview.innerHTML += '<button class="btn btn-primary" onclick="copyShiftReconEmail()" style="width:100%;margin-top:8px;">Copy to Clipboard</button>';
  preview.dataset.emailText = emailText;
}

function copyShiftReconEmail() {
  const preview = document.getElementById('shiftReconEmailPreview');
  const text = preview.dataset.emailText || '';
  navigator.clipboard.writeText(text).then(() => {
    showToast('Email copied to clipboard!');
  }).catch(() => {
    showToast('Failed to copy — try selecting and copying manually');
  });
}

// ================================================================
// PRODUCTION RECONCILIATION (PDF)
// ================================================================
let prodData = [];
let pYear = new Date().getFullYear();
let pMonth = new Date().getMonth();

document.getElementById('pPrevMonth').addEventListener('click', () => { pMonth--; if (pMonth < 0) { pMonth = 11; pYear--; } updateReconMonthLabels(); renderProdRecon(); });
document.getElementById('pNextMonth').addEventListener('click', () => { pMonth++; if (pMonth > 11) { pMonth = 0; pYear++; } updateReconMonthLabels(); renderProdRecon(); });

document.getElementById('prodUploadArea').addEventListener('click', () => document.getElementById('prodFile').click());

document.getElementById('prodFile').addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const isImage = /\.(png|jpg|jpeg)$/i.test(file.name);

  try {
    if (isImage) {
      showToast('Running OCR on image...');
      const allText = await ocrImage(file);
      const normalized = allText.split('\n').map(line => line.replace(/\s{2,}/g, '\t')).join('\n');
      prodData = parseProdText(normalized);
    } else {
      showToast('Parsing PDF...');
      // Try coordinate-based extraction first
      const structured = await extractPDFTabular(file);
      if (structured.length > 0) {
        prodData = parseProdStructured(structured);
      }
      // Fallback to legacy text extraction if coordinate-based found nothing
      if (prodData.length === 0) {
        const allText = await extractPDFTextLegacy(file);
        prodData = parseProdText(allText);
      }
    }
    localStorage.setItem(PROD_KEY, JSON.stringify(prodData));
    showToast(`Loaded ${prodData.length} billing cases`);

    if (prodData.length > 0 && prodData[0].date) {
      const d = new Date(prodData[0].date + 'T12:00:00');
      if (!isNaN(d)) { pYear = d.getFullYear(); pMonth = d.getMonth(); updateReconMonthLabels(); }
    }
    renderProdRecon();
  } catch(err) {
    showToast('Error reading file: ' + err.message);
    console.error(err);
  }
  e.target.value = '';
});

// ================================================================
// TESSERACT OCR
// ================================================================
function loadTesseract() {
  if (window.Tesseract) return Promise.resolve();
  return new Promise((resolve, reject) => {
    const s = document.createElement('script');
    s.src = 'https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js';
    s.onload = resolve;
    s.onerror = () => reject(new Error('Failed to load Tesseract.js'));
    document.head.appendChild(s);
  });
}

async function ocrImage(file) {
  await loadTesseract();
  const worker = await Tesseract.createWorker('eng');
  const { data } = await worker.recognize(file);
  await worker.terminate();
  return data.text;
}

async function extractPDFTextLegacy(file) {
  if (!window.pdfjsLib) {
    const pdfjs = await import('https://cdn.jsdelivr.net/npm/pdfjs-dist@4.0.379/build/pdf.mjs');
    window.pdfjsLib = pdfjs;
    pdfjs.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@4.0.379/build/pdf.worker.mjs';
  }
  const arrayBuffer = await file.arrayBuffer();
  const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;

  // First try native text extraction
  let allText = '';
  for (let i = 1; i <= pdf.numPages; i++) {
    const page = await pdf.getPage(i);
    const textContent = await page.getTextContent();
    const items = textContent.items;
    const rows = {};
    items.forEach(item => {
      const y = Math.round(item.transform[5]);
      if (!rows[y]) rows[y] = [];
      rows[y].push({ x: item.transform[4], text: item.str });
    });
    const sortedYs = Object.keys(rows).map(Number).sort((a, b) => b - a);
    sortedYs.forEach(y => {
      const row = rows[y].sort((a, b) => a.x - b.x);
      allText += row.map(r => r.text).join('\t') + '\n';
    });
  }

  // Check if we got meaningful text (at least one date-like pattern)
  const hasContent = /\d{1,2}\/\d{1,2}\/\d{2,4}/.test(allText);
  if (hasContent) return allText;

  // Fallback: render pages to canvas and OCR each one
  showToast('Image-based PDF detected, running OCR...');
  await loadTesseract();
  const worker = await Tesseract.createWorker('eng');
  let ocrText = '';

  for (let i = 1; i <= pdf.numPages; i++) {
    showToast(`OCR page ${i} of ${pdf.numPages}...`);
    const page = await pdf.getPage(i);
    const viewport = page.getViewport({ scale: 2.0 });
    const canvas = document.createElement('canvas');
    canvas.width = viewport.width;
    canvas.height = viewport.height;
    const ctx = canvas.getContext('2d');
    await page.render({ canvasContext: ctx, viewport }).promise;
    const { data } = await worker.recognize(canvas);
    ocrText += data.text + '\n';
  }

  await worker.terminate();
  // Normalize OCR output: replace multiple spaces with tab
  ocrText = ocrText.split('\n').map(line => line.replace(/\s{2,}/g, '\t')).join('\n');
  return ocrText;
}

// ================================================================
// COORDINATE-BASED PDF EXTRACTION
// ================================================================
async function extractPDFTabular(file) {
  if (!window.pdfjsLib) {
    const pdfjs = await import('https://cdn.jsdelivr.net/npm/pdfjs-dist@4.0.379/build/pdf.mjs');
    window.pdfjsLib = pdfjs;
    pdfjs.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@4.0.379/build/pdf.worker.mjs';
  }
  const arrayBuffer = await file.arrayBuffer();
  const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;

  // Known column header tokens (in order) — the billing PDF uses these
  const HEADER_TOKENS = [
    'Date of', 'Patient', 'Loc', 'CPT', 'Start', 'End',
    'Shared', 'M.D.', 'Bonus', 'Time', 'Units', '20%', '37.5%', '50%', '100%', 'Total'
  ];

  const allRows = [];

  for (let p = 1; p <= pdf.numPages; p++) {
    const page = await pdf.getPage(p);
    const textContent = await page.getTextContent();
    const items = textContent.items.filter(it => it.str.trim());

    if (items.length === 0) continue;

    // Group items by Y-coordinate (±3 tolerance)
    const yGroups = [];
    const sorted = [...items].sort((a, b) => b.transform[5] - a.transform[5]); // top to bottom
    sorted.forEach(item => {
      const y = item.transform[5];
      let found = false;
      for (const g of yGroups) {
        if (Math.abs(g.y - y) <= 3) {
          g.items.push({ x: item.transform[4], text: item.str.trim(), width: item.width || 0 });
          g.y = (g.y * g.items.length + y) / (g.items.length); // running avg
          found = true;
          break;
        }
      }
      if (!found) {
        yGroups.push({ y, items: [{ x: item.transform[4], text: item.str.trim(), width: item.width || 0 }] });
      }
    });

    // Sort groups top-to-bottom, items left-to-right
    yGroups.sort((a, b) => b.y - a.y);
    yGroups.forEach(g => g.items.sort((a, b) => a.x - b.x));

    // Find header row: look for a row containing several of the known tokens
    let headerCols = null;
    for (const g of yGroups) {
      const rowText = g.items.map(it => it.text).join(' ');
      let tokenHits = 0;
      for (const tok of HEADER_TOKENS) {
        if (rowText.includes(tok)) tokenHits++;
      }
      if (tokenHits >= 5) {
        // Map header token positions
        headerCols = [];
        for (const tok of HEADER_TOKENS) {
          const match = g.items.find(it => it.text.includes(tok));
          if (match) {
            headerCols.push({ name: tok, x: match.x });
          }
        }
        headerCols.sort((a, b) => a.x - b.x);
        break;
      }
    }

    if (!headerCols || headerCols.length < 5) continue;

    // Build column boundaries: midpoint between consecutive headers
    const colBounds = headerCols.map((col, i) => {
      const left = i === 0 ? 0 : (headerCols[i - 1].x + col.x) / 2;
      const right = i === headerCols.length - 1 ? 9999 : (col.x + headerCols[i + 1].x) / 2;
      return { name: col.name, left, right };
    });

    // Process data rows (everything after header, skip totals)
    let pastHeader = false;
    for (const g of yGroups) {
      const rowText = g.items.map(it => it.text).join(' ');

      if (!pastHeader) {
        let tokenHits = 0;
        for (const tok of HEADER_TOKENS) {
          if (rowText.includes(tok)) tokenHits++;
        }
        if (tokenHits >= 5) { pastHeader = true; continue; }
        continue;
      }

      // Skip total rows
      if (/Day Total|Grand Total|Page\s+\d/i.test(rowText)) continue;
      // Skip empty-ish rows
      if (g.items.length < 2) continue;

      // Assign each item to a column
      const row = {};
      for (const item of g.items) {
        let bestCol = null, bestDist = 9999;
        for (const col of colBounds) {
          if (item.x >= col.left && item.x < col.right) { bestCol = col.name; break; }
          const dist = Math.min(Math.abs(item.x - col.left), Math.abs(item.x - col.right));
          if (dist < bestDist) { bestDist = dist; bestCol = col.name; }
        }
        if (bestCol) {
          row[bestCol] = row[bestCol] ? row[bestCol] + ' ' + item.text : item.text;
        }
      }

      allRows.push(row);
    }
  }

  return allRows;
}

function parseProdStructured(rows) {
  const cases = [];
  let currentDate = '';

  for (const row of rows) {
    // Carry-forward date
    const dateField = row['Date of'] || '';
    const dateMatch = dateField.match(/(\d{1,2})\/(\d{1,2})\/(\d{2,4})/);
    if (dateMatch) {
      let [, m, d, y] = dateMatch;
      y = parseInt(y);
      if (y < 100) y += 2000;
      currentDate = y + '-' + String(parseInt(m)).padStart(2, '0') + '-' + String(parseInt(d)).padStart(2, '0');
    }
    if (!currentDate) continue;

    // Extract fields
    const accountNumber = (row['Patient'] || '').replace(/\D/g, '').substring(0, 10) || '';
    const locCode = (row['Loc'] || '').replace(/[^A-Z]/gi, '').substring(0, 4) || '';
    const cptCode = ((row['CPT'] || '').match(/\d{5}/) || [''])[0];
    const startRaw = (row['Start'] || '').replace(/[^0-9:]/g, '');
    const endRaw = (row['End'] || '').replace(/[^0-9:]/g, '');
    const sharedRaw = (row['Shared'] || '').trim().toUpperCase();
    const isShared = sharedRaw === 'Y' || sharedRaw === 'YES';
    const mdMinutes = parseInt((row['M.D.'] || '').replace(/\D/g, '')) || 0;

    // Parse start/end times
    let startTime = '', endTime = '';
    if (startRaw) {
      const clean = startRaw.replace(':', '');
      if (clean.length >= 3 && clean.length <= 4) startTime = formatMilitaryTime(clean);
    }
    if (endRaw) {
      const clean = endRaw.replace(':', '');
      if (clean.length >= 3 && clean.length <= 4) endTime = formatMilitaryTime(clean);
    }

    // Parse numeric fields — grab from specific columns
    const unitsRaw = row['Units'] || '';
    const units = parseFloat(unitsRaw) || 0;
    const totalRaw = row['Total'] || '';
    const totalPoints = parseFloat(totalRaw) || 0;
    const timePointsRaw = row['Time'] || '';
    const timePoints = parseFloat(timePointsRaw) || 0;

    // Skip rows with no useful data
    if (!cptCode && !startTime && totalPoints === 0 && units === 0) continue;

    // Classify row type
    const addOnType = cptCode ? (CPT_ADDON_MAP[cptCode] || '') : '';
    const isRoundingCPT = cptCode === '01996' || cptCode === '99231';

    if (addOnType && !startTime && !endTime) {
      // Add-on row
      cases.push({
        date: currentDate, startTime: '', endTime: '',
        mdMinutes: 0, totalPoints, units,
        locCode, cptCode, accountNumber,
        isAddOn: true, addOnType, isShared, timePoints
      });
    } else if (isRoundingCPT && !startTime && !endTime) {
      // Rounding row
      cases.push({
        date: currentDate, startTime: '', endTime: '',
        mdMinutes, totalPoints, units,
        locCode, cptCode, accountNumber,
        isAddOn: false, addOnType: '', isRounding: true, isShared, timePoints
      });
    } else if (startTime || endTime || totalPoints > 0 || units > 0) {
      // Standard case row
      cases.push({
        date: currentDate, startTime, endTime,
        mdMinutes, totalPoints, units,
        locCode, cptCode, accountNumber,
        isAddOn: false, addOnType, isShared, timePoints
      });
    }
  }

  return cases;
}

// ================================================================
// QGENDA SCREENSHOT PARSER
// ================================================================
function parseQgendaScreenshot(text) {
  const lines = text.split('\n').map(l => l.trim()).filter(l => l);
  const entries = [];
  let currentYear = new Date().getFullYear();

  for (const line of lines) {
    // Look for date patterns: M/D, M/D/YY, M/D/YYYY
    const dateMatch = line.match(/(\d{1,2})\/(\d{1,2})(?:\/(\d{2,4}))?/);
    if (!dateMatch) continue;

    let [, month, day, year] = dateMatch;
    month = parseInt(month); day = parseInt(day);
    if (year) {
      year = parseInt(year);
      if (year < 100) year += 2000;
    } else {
      year = currentYear;
    }
    if (month < 1 || month > 12 || day < 1 || day > 31) continue;
    currentYear = year; // remember year for subsequent lines

    const dateStr = year + '-' + String(month).padStart(2,'0') + '-' + String(day).padStart(2,'0');

    // Look for military time pairs (H:MM or HH:MM)
    const times = line.match(/\d{1,2}:\d{2}/g);
    if (!times || times.length < 2) continue;

    // Parse time pairs
    for (let i = 0; i < times.length - 1; i += 2) {
      const clockIn = times[i].length === 4 ? '0' + times[i] : times[i];
      const clockOut = times[i+1].length === 4 ? '0' + times[i+1] : times[i+1];
      const inMin = timeToMinutes(clockIn);
      let outMin = timeToMinutes(clockOut);
      if (outMin <= inMin) outMin += 1440;
      const duration = (outMin - inMin) / 60;

      // Extract task abbreviation — text before or after the times
      const afterTimes = line.substring(line.lastIndexOf(times[i+1]) + times[i+1].length).trim();
      const beforeDate = line.substring(0, line.indexOf(dateMatch[0])).trim();
      const betweenDateAndTime = line.substring(line.indexOf(dateMatch[0]) + dateMatch[0].length, line.indexOf(times[i])).trim();
      const task = afterTimes || betweenDateAndTime || beforeDate || '';

      entries.push({
        scheduleDate: dateStr,
        clockInDate: dateStr,
        clockInTime: clockIn,
        clockOutDate: dateStr,
        clockOutTime: clockOut,
        duration: round2(duration),
        task: task.replace(/[^a-zA-Z0-9\s\/\-]/g, '').trim(),
        location: '',
        notes: ''
      });
    }
  }
  return entries;
}

// ================================================================
// IMPORT SHIFTS FROM QGENDA
// ================================================================
function mapTaskToAssignmentType(task, dateStr) {
  const t = (task || '').toUpperCase();
  // "UVH/SFH Work" → pre-call (standalone; when paired with mole/OB, import handler uses overlay)
  if (/UVH\/SFH\s*WORK/.test(t)) return 'pre_call';
  // "Post" anything → always general OR (Post 1-4, Post SF 1/2, etc.)
  if (/\bPOST\b/.test(t)) return 'OR';
  // SFH prefix → SF1 or SF2 (check before call keywords so "SFH 1st Call" → SF1)
  if (/\bSFH\b/.test(t)) {
    if (/2/.test(t)) return 'SF2';
    return 'SF1';
  }
  // Call shifts: check for 1st-4th call keywords (may be prefixed with "UVH")
  if (/4TH|4C/.test(t)) return (dateStr && isWeekend(dateStr)) ? '4th_call' : 'ACS';
  if (/3RD|3C/.test(t)) return '3rd_call';
  if (/2ND|2C/.test(t)) return '2nd_call';
  if (/1ST|1C/.test(t)) return '1st_call';
  // "UVH" + number (without call keyword) → general OR (e.g. "UVH 3", "UVH 7")
  if (/\bUVH\s*\d/.test(t)) return 'OR';
  if (t.includes('NORA')) return 'NORA';
  if (t.includes('ACS') || t.includes('TOCR')) return 'ACS';
  if (t.includes('C/L') || t.includes('CARDIAC')) return 'cardiac_liver';
  if (t.includes('MOLE')) return 'mole';
  if (t.includes('CRNA')) return 'CRNA_supervision';
  if (t.includes('ENDO')) return (dateStr && isWeekend(dateStr)) ? 'mole' : 'endo';
  if (t.includes('SF1') || t.includes('SF 1')) return 'SF1';
  if (t.includes('SF2') || t.includes('SF 2')) return 'SF2';
  if (t.includes('OB') || t.includes('UVOC')) return 'OB_restricted';
  if (/FORCED?\s*OFF/i.test(t)) return 'forced_off';
  if (t.includes('OR')) return 'OR';
  return 'OR'; // fallback
}

let importTimeData = [];

function showImportTimePreview() {
  const area = document.getElementById('importTimeAction');
  const preview = document.getElementById('importTimePreview');
  if (importTimeData.length === 0) {
    area.classList.add('hidden');
    preview.innerHTML = '';
    return;
  }
  area.classList.remove('hidden');

  // Group by date for preview
  const byDate = {};
  importTimeData.forEach(e => {
    const d = e.scheduleDate;
    if (!d) return;
    if (!byDate[d]) byDate[d] = [];
    byDate[d].push(e);
  });

  const dates = Object.keys(byDate).sort();
  const existing = dates.filter(d => data.shifts[d]).length;
  const newDates = dates.filter(d => !data.shifts[d]).length;

  let html = '<div class="card" style="margin-top:12px;"><h3>Preview</h3>';
  html += `<p style="font-size:0.8rem;color:var(--text-dim);margin-bottom:8px;">${dates.length} date${dates.length > 1 ? 's' : ''} found &mdash; ${newDates} new, ${existing} already exist</p>`;
  html += '<div style="max-height:250px;overflow-y:auto;font-size:0.8rem;">';
  dates.forEach(date => {
    const entries = byDate[date];
    const hasShift = data.shifts[date];
    const task = entries[0].task || '';
    const times = entries.map(e => `${e.clockInTime}-${e.clockOutTime}`).join(', ');
    const assignType = getAssignmentTypeName(mapTaskToAssignmentType(task, date));
    html += `<div style="padding:6px 0;border-bottom:1px solid var(--border);${hasShift ? 'opacity:0.5;' : ''}">`;
    html += `<strong>${formatDateShort(date)}</strong> &mdash; ${assignType}`;
    html += `<br><span style="color:var(--text-dim)">${times}${task ? ' (' + escHtml(task) + ')' : ''}${hasShift ? ' — already exists, will skip' : ''}</span>`;
    html += '</div>';
  });
  html += '</div></div>';
  preview.innerHTML = html;
}

// Import tab — time punch upload
document.getElementById('importTimeUploadArea').addEventListener('click', () => document.getElementById('importTimeFile').click());

document.getElementById('importTimeFile').addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const isImage = /\.(png|jpg|jpeg)$/i.test(file.name);
  const isCSV = /\.csv$/i.test(file.name);

  try {
    if (isImage) {
      showToast('Running OCR on image...');
      const text = await ocrImage(file);
      importTimeData = parseQgendaScreenshot(text);
      showToast(`OCR found ${importTimeData.length} entries`);
    } else if (isCSV) {
      const text = await file.text();
      const rows = parseCSVRows(text);
      importTimeData = rows.map(r => {
        let schedDate = parseExcelDate(r['Schedule Date']);
        return {
          scheduleDate: schedDate,
          clockInDate: parseExcelDate(r['Effective Clock In Date']),
          clockInTime: parseExcelTime(r['Effective Clock In Time']),
          clockOutDate: parseExcelDate(r['Effective Clock Out Date']),
          clockOutTime: parseExcelTime(r['Effective Clock Out Time']),
          duration: parseFloat(r['Duration']) || 0,
          timeClockTask: String(r['Time Clock Task'] || ''),
          task: String(r['Scheduled Task Abbreviation'] || ''),
          location: String(r['Location Name'] || ''),
          notes: String(r['Notes'] || '')
        };
      });
      showToast(`Loaded ${importTimeData.length} entries from CSV`);
    } else {
      const arrayBuffer = await file.arrayBuffer();
      const wb = XLSX.read(arrayBuffer, { type: 'array' });
      const ws = wb.Sheets[wb.SheetNames[0]];
      const rows = XLSX.utils.sheet_to_json(ws, { defval: '' });
      importTimeData = rows.map(r => {
        let schedDate = parseExcelDate(r['Schedule Date']);
        return {
          scheduleDate: schedDate,
          clockInDate: parseExcelDate(r['Effective Clock In Date']),
          clockInTime: parseExcelTime(r['Effective Clock In Time']),
          clockOutDate: parseExcelDate(r['Effective Clock Out Date']),
          clockOutTime: parseExcelTime(r['Effective Clock Out Time']),
          duration: parseFloat(r['Duration']) || 0,
          timeClockTask: String(r['Time Clock Task'] || ''),
          task: String(r['Scheduled Task Abbreviation'] || ''),
          location: String(r['Location Name'] || ''),
          notes: String(r['Notes'] || '')
        };
      });
      showToast(`Loaded ${importTimeData.length} entries from xlsx`);
    }
    showImportTimePreview();
  } catch(err) {
    showToast('Error reading file: ' + err.message);
    console.error(err);
  }
  e.target.value = '';
});

let pendingImportAction = null;

document.getElementById('importShiftsBtn').addEventListener('click', () => {
  // Group entries by date, pick earliest clock-in and latest clock-out
  const byDate = {};
  importTimeData.forEach(e => {
    const d = e.scheduleDate;
    if (!d) return;
    if (!byDate[d]) byDate[d] = [];
    byDate[d].push(e);
  });

  let toImport = 0, toSkip = 0;
  const shiftsToCreate = [];

  Object.keys(byDate).sort().forEach(date => {
    if (data.shifts[date]) { toSkip++; return; }
    const entries = byDate[date];
    // Separate work hours from supervision entries
    const workEntries = entries.filter(e => e.clockInTime && (e.timeClockTask || '').toUpperCase() !== 'CARE TEAM SUPERVISOR');
    const supEntries = entries.filter(e => e.clockInTime && (e.timeClockTask || '').toUpperCase() === 'CARE TEAM SUPERVISOR');
    const allClocked = [...entries].filter(e => e.clockInTime).sort((a, b) => a.clockInTime.localeCompare(b.clockInTime));
    const timeEntries = allClocked.map(e => ({ start: e.clockInTime, end: e.clockOutTime || '' }));
    let earliest = '23:59', latest = '00:00';
    const allTasks = [];
    entries.forEach(e => {
      if (e.clockInTime && e.clockInTime < earliest) earliest = e.clockInTime;
      if (e.clockOutTime && e.clockOutTime > latest) latest = e.clockOutTime;
      if (e.task) allTasks.push(e.task);
    });
    // Prefer call/mole/endo task over pre-call OR work (e.g. "UVH/SFH Work" + "Mole" → use "Mole")
    const callTaskPatterns = /MOLE|ENDO|1ST|2ND|3RD|4TH|CALL|SFH\s*\d/i;
    const task = allTasks.find(t => callTaskPatterns.test(t)) || allTasks[0] || '';
    // Detect CRNA supervision period
    let supervisionStart = '', supervisionEnd = '';
    if (supEntries.length > 0) {
      const sorted = [...supEntries].sort((a, b) => a.clockInTime.localeCompare(b.clockInTime));
      supervisionStart = sorted[0].clockInTime;
      supervisionEnd = sorted[sorted.length - 1].clockOutTime || '';
    }
    // If ALL entries are supervision (standalone CRNA shift), use CRNA_supervision type
    const assignmentType = workEntries.length === 0 && supEntries.length > 0
      ? 'CRNA_supervision'
      : mapTaskToAssignmentType(task, date);

    // Detect pre-call: "UVH/SFH Work" entries paired with mole/OB
    let preCallStart = '', preCallEnd = '';
    const preCallPattern = /UVH\/SFH\s*WORK/i;
    const preCallEntries = entries.filter(e => e.clockInTime && preCallPattern.test(e.task || ''));
    if (preCallEntries.length > 0 && ['mole','OB_restricted'].includes(assignmentType)) {
      const sortedPC = [...preCallEntries].sort((a, b) => a.clockInTime.localeCompare(b.clockInTime));
      preCallStart = sortedPC[0].clockInTime;
      preCallEnd = sortedPC[sortedPC.length - 1].clockOutTime || '';
    }

    // If no clock punches but shift type has pager pay, allow with empty time entries
    const hasPager = getPagerPayWindow(assignmentType, isWeekend(date)) !== null;
    const finalTimeEntries = timeEntries.length > 0
      ? timeEntries
      : hasPager ? [] : [{ start: earliest, end: latest }];
    shiftsToCreate.push({
      date, assignmentType,
      startTime: timeEntries.length > 0 ? earliest : '',
      endTime: timeEntries.length > 0 ? latest : '',
      timeEntries: finalTimeEntries,
      task, supervisionStart, supervisionEnd,
      preCallStart, preCallEnd
    });
    toImport++;
  });

  if (toImport === 0) {
    showToast(toSkip > 0 ? `All ${toSkip} dates already have shifts` : 'No shifts to import');
    return;
  }

  // Show confirmation modal
  const body = document.getElementById('importConfirmBody');
  body.innerHTML = `<p>Import <strong>${toImport}</strong> shift${toImport > 1 ? 's' : ''} from QGenda?</p>` +
    (toSkip > 0 ? `<p style="font-size:0.8rem;color:var(--text-dim);">${toSkip} date${toSkip > 1 ? 's' : ''} already have shifts and will be skipped.</p>` : '') +
    `<div style="max-height:200px;overflow-y:auto;margin-top:8px;font-size:0.8rem;">` +
    shiftsToCreate.map(s => `<div style="padding:4px 0;border-bottom:1px solid var(--border);">${formatDateShort(s.date)} &mdash; ${getAssignmentTypeName(s.assignmentType)}${s.startTime ? ` (${s.startTime}-${s.endTime})` : ' (pager only)'}</div>`).join('') +
    `</div>`;
  document.getElementById('importConfirmTitle').textContent = 'Import Shifts';

  pendingImportAction = () => {
    shiftsToCreate.forEach(s => {
      data.shifts[s.date] = {
        date: s.date,
        assignmentType: s.assignmentType,
        startTime: s.startTime,
        endTime: s.endTime,
        timeEntries: s.timeEntries || [{ start: s.startTime, end: s.endTime }],
        isHoliday: false,
        forcedOff: false,
        subspecCoverage: false,
        teeCount: 0,
        supervisionStart: s.supervisionStart || '',
        supervisionEnd: s.supervisionEnd || '',
        preCallStart: s.preCallStart || '',
        preCallEnd: s.preCallEnd || ''
      };
    });
    saveData(data);
    updateHeaderPoints();
    showToast(`Imported ${shiftsToCreate.length} shifts`);
    showImportTimePreview();
    renderQgendaRecon();
  };

  document.getElementById('importConfirmModal').classList.remove('hidden');
});

document.getElementById('confirmImport').addEventListener('click', () => {
  document.getElementById('importConfirmModal').classList.add('hidden');
  if (pendingImportAction) { pendingImportAction(); pendingImportAction = null; }
});

document.getElementById('cancelImport').addEventListener('click', () => {
  document.getElementById('importConfirmModal').classList.add('hidden');
  pendingImportAction = null;
});

// ================================================================
// CSV CASE IMPORT (Google Sheet export)
// ================================================================
document.getElementById('csvUploadArea').addEventListener('click', () => document.getElementById('csvFile').click());

document.getElementById('csvFile').addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const ext = file.name.split('.').pop().toLowerCase();

  try {
    let result;
    if (ext === 'xlsx' || ext === 'xls') {
      showToast('Parsing Excel file...');
      result = await parseCaseExcel(file);
    } else if (ext === 'pdf') {
      showToast('Parsing PDF...');
      result = await parseCasePDF(file);
    } else if (/^(png|jpg|jpeg)$/.test(ext)) {
      showToast('Running OCR on image...');
      const text = await ocrImage(file);
      result = parseGoogleSheetCSV(text);
    } else {
      // CSV (default)
      const text = await file.text();
      result = parseGoogleSheetCSV(text);
    }

    if (result.cases.length === 0) {
      showToast('No cases found in file');
      return;
    }
    showCSVImportConfirmation(result);
  } catch(err) {
    showToast('Error parsing file: ' + err.message);
    console.error(err);
  }
  e.target.value = '';
});

function convertAMPMToMilitary(timeStr) {
  if (!timeStr) return '';
  const s = timeStr.trim().toUpperCase();
  // Already military format?
  if (s.match(/^\d{1,2}:\d{2}$/) && !s.includes('AM') && !s.includes('PM')) {
    const [h, m] = s.split(':').map(Number);
    return String(h).padStart(2,'0') + ':' + String(m).padStart(2,'0');
  }
  const match = s.match(/(\d{1,2}):(\d{2})(?::\d{2})?\s*(AM|PM)/i);
  if (!match) return '';
  let [, h, m, ampm] = match;
  h = parseInt(h); m = parseInt(m);
  if (ampm === 'PM' && h !== 12) h += 12;
  if (ampm === 'AM' && h === 12) h = 0;
  return String(h).padStart(2,'0') + ':' + String(m).padStart(2,'0');
}

function buildCaseMonthSummary(cases) {
  const mn = ['January','February','March','April','May','June','July','August','September','October','November','December'];
  const buckets = {};
  cases.forEach(c => {
    if (!c.shiftDate) return;
    const [y, m] = c.shiftDate.split('-').map(Number);
    const key = y + '-' + String(m).padStart(2,'0');
    if (!buckets[key]) buckets[key] = { year: y, month: m, label: mn[m - 1] + ' ' + y, count: 0 };
    buckets[key].count++;
  });
  return Object.values(buckets).sort((a, b) => (a.year - b.year) || (a.month - b.month));
}

function parseDateField(raw) {
  if (!raw) return '';
  const s = raw.trim();
  const now = new Date();
  const curYear = now.getFullYear();
  const curMonth = now.getMonth() + 1;

  // M/D/YYYY or M/D/YY or M/D
  const slashMatch = s.match(/^(\d{1,2})\/(\d{1,2})(?:\/(\d{2,4}))?$/);
  if (slashMatch) {
    let [, month, day, year] = slashMatch;
    month = parseInt(month); day = parseInt(day);
    if (year) { year = parseInt(year); if (year < 100) year += 2000; }
    else { year = month > curMonth + 3 ? curYear - 1 : curYear; }
    return year + '-' + String(month).padStart(2,'0') + '-' + String(day).padStart(2,'0');
  }

  // D-Mon or D-Mon-YY (e.g., "1-Nov", "15-Jan", "3-Dec-25")
  const monNames = { jan:1, feb:2, mar:3, apr:4, may:5, jun:6, jul:7, aug:8, sep:9, oct:10, nov:11, dec:12 };
  const monMatch = s.match(/^(\d{1,2})-([A-Za-z]{3})(?:-(\d{2,4}))?$/);
  if (monMatch) {
    const day = parseInt(monMatch[1]);
    const mon = monNames[monMatch[2].toLowerCase()];
    if (!mon) return '';
    let year = monMatch[3] ? parseInt(monMatch[3]) : null;
    if (year !== null && year < 100) year += 2000;
    if (year === null) {
      // Infer year: if month is far ahead of current, likely previous year
      year = mon > curMonth + 3 ? curYear - 1 : curYear;
    }
    return year + '-' + String(mon).padStart(2,'0') + '-' + String(day).padStart(2,'0');
  }

  return '';
}

function parseGoogleSheetCSV(text) {
  const lines = text.split('\n').map(l => l.trim()).filter(l => l);
  const cases = [];

  for (const line of lines) {
    // Handle quoted CSV fields properly
    const cols = [];
    let inQuote = false, field = '';
    for (let i = 0; i < line.length; i++) {
      const ch = line[i];
      if (ch === '"') { inQuote = !inQuote; continue; }
      if (ch === ',' && !inQuote) { cols.push(field.trim()); field = ''; continue; }
      field += ch;
    }
    cols.push(field.trim());

    if (cols.length < 3) continue;

    const dateStr = parseDateField(cols[0]);
    if (!dateStr) continue;

    const surgeon = (cols[1] || '').trim();
    const baseUnits = parseFloat(cols[2]) || 0;
    const startTime = convertAMPMToMilitary(cols[3] || '');
    const endTime = convertAMPMToMilitary(cols[4] || '');
    const modifiers = cols.length > 5 ? (cols[5] || '') : '';
    const blockVal = cols.length > 6 ? (parseFloat(cols[6]) || 0) : 0;
    const shared = cols.length > 7 ? (cols[7] || '').trim() : '';

    // Detect special case types from surgeon column
    const surgeonUpper = surgeon.toUpperCase().trim();

    // Skip CRNA supervision entries (these are shift-level, not case-level)
    if (surgeonUpper.startsWith('SUPERVISING') || surgeonUpper === 'CRNA' || surgeonUpper === 'CRNAS') continue;

    // APS Rounding
    if (surgeonUpper === 'APS') {
      cases.push({
        id: genId(),
        caseType: 'aps_rounding',
        procedure: 'APS Rounding',
        baseUnits: 0,
        physicalStatus: 'P2',
        startTime: '', endTime: '',
        shiftDate: dateStr,
        isEmergency: false,
        isMedicalProc: false, medicalUnits: 0,
        isAcutePain: false, acutePainUnits: 0,
        isHighRiskPeds: false, isORCase: false,
        isSharedCase: false, sharedStartupPct: 100,
        nerveBlock: 'none',
        hasCentralLine: false, hasArterialLine: false,
        hasPAC: false, hasTEEAddOn: false, hasITMorphine: false,
        epiduralRounds: baseUnits === 3 ? 1 : 0,
        painRounds: baseUnits === 2 ? 1 : 0,
        notes: '', timestamp: new Date().toISOString()
      });
      continue;
    }

    // Labor epidural
    if (surgeonUpper === 'EPIDURAL' || surgeonUpper === 'LABOR EPIDURAL') {
      cases.push({
        id: genId(),
        caseType: 'labor_epidural',
        procedure: 'Labor Epidural',
        baseUnits: 0,
        physicalStatus: 'P2',
        startTime: startTime, endTime: endTime,
        shiftDate: dateStr,
        isEmergency: false,
        isMedicalProc: false, medicalUnits: 0,
        isAcutePain: false, acutePainUnits: 0,
        isHighRiskPeds: false, isORCase: false,
        isSharedCase: false, sharedStartupPct: 100,
        nerveBlock: 'none',
        hasCentralLine: false, hasArterialLine: false,
        hasPAC: false, hasTEEAddOn: false, hasITMorphine: false,
        notes: '', timestamp: new Date().toISOString()
      });
      continue;
    }

    // Modifiers: text "E" for emergency, "4"/"5" for physical status
    const isEmergency = /\bE\b/.test(modifiers);
    let physicalStatus = 'P2';
    const psMatch = modifiers.match(/\bASA\s*([45])\b/i) || modifiers.match(/^([45])$/);
    if (psMatch) physicalStatus = 'P' + psMatch[1];

    // If modifier column has a numeric value and block column is empty, it may be misplaced
    const modNum = parseFloat(modifiers) || 0;
    const effectiveBlock = blockVal > 0 ? blockVal : modNum;

    // Nerve block: detect from block point value (3=brachial plexus, 2.6=other)
    let nerveBlock = 'none';
    if (effectiveBlock >= 3) nerveBlock = 'brachial_plexus';
    else if (effectiveBlock >= 2.5) nerveBlock = 'other_nerve';

    // Arterial line: 0.6 in block or modifier column
    const hasArterialLine = Math.abs(effectiveBlock - 0.6) < 0.01;
    if (hasArterialLine) nerveBlock = 'none';

    // Central line: 0.8
    const hasCentralLine = Math.abs(effectiveBlock - 0.8) < 0.01;
    if (hasCentralLine) nerveBlock = 'none';

    // Shared case
    const isShared = shared.toUpperCase() === 'Y';

    if (baseUnits <= 0 && !startTime) continue;

    cases.push({
      id: genId(),
      caseType: 'standard',
      procedure: surgeon,
      baseUnits: baseUnits,
      physicalStatus: physicalStatus,
      startTime: startTime,
      endTime: endTime,
      shiftDate: dateStr,
      isEmergency: isEmergency,
      isMedicalProc: false, medicalUnits: 0,
      isAcutePain: false, acutePainUnits: 0,
      isHighRiskPeds: false, isORCase: false,
      isSharedCase: isShared,
      sharedStartupPct: isShared ? 50 : 100,
      nerveBlock: nerveBlock,
      hasCentralLine: hasCentralLine,
      hasArterialLine: hasArterialLine,
      hasPAC: false, hasTEEAddOn: false, hasITMorphine: false,
      notes: surgeon,
      timestamp: new Date().toISOString()
    });
  }

  return { cases, months: buildCaseMonthSummary(cases) };
}

function showCSVImportConfirmation(result) {
  const { cases, months } = result;

  // Check for duplicates
  const existingKeys = new Set(data.cases.map(c => c.shiftDate + '|' + c.startTime));
  const newCases = cases.filter(c => !existingKeys.has(c.shiftDate + '|' + c.startTime));
  const dupes = cases.length - newCases.length;

  if (newCases.length === 0) {
    showToast(`All ${cases.length} cases already exist`);
    return;
  }

  const monthLabel = months.length === 1 ? months[0].label : months.length + ' months';
  let monthBreakdown = '';
  if (months.length > 1) {
    monthBreakdown = '<ul style="margin:8px 0;padding-left:20px;font-size:0.85rem;">' +
      months.map(m => `<li>${m.label}: ${m.count} case${m.count > 1 ? 's' : ''}</li>`).join('') + '</ul>';
  }

  const body = document.getElementById('importConfirmBody');
  body.innerHTML = `<p>Found <strong>${cases.length}</strong> cases across <strong>${monthLabel}</strong>.</p>` +
    monthBreakdown +
    (dupes > 0 ? `<p style="font-size:0.8rem;color:var(--text-dim);">${dupes} duplicate${dupes > 1 ? 's' : ''} will be skipped.</p>` : '') +
    `<p>Import <strong>${newCases.length}</strong> new case${newCases.length > 1 ? 's' : ''}?</p>`;
  document.getElementById('importConfirmTitle').textContent = 'Import Cases';

  pendingImportAction = () => {
    // Create placeholder shifts for dates without one
    const caseDates = {};
    newCases.forEach(c => {
      if (!caseDates[c.shiftDate]) caseDates[c.shiftDate] = { earliest: '23:59', latest: '00:00' };
      if (c.startTime && c.startTime < caseDates[c.shiftDate].earliest) caseDates[c.shiftDate].earliest = c.startTime;
      if (c.endTime && c.endTime > caseDates[c.shiftDate].latest) caseDates[c.shiftDate].latest = c.endTime;
    });

    let shiftsCreated = 0;
    Object.keys(caseDates).forEach(date => {
      if (!data.shifts[date]) {
        const st = caseDates[date].earliest || '07:00';
        const en = caseDates[date].latest || '17:00';
        data.shifts[date] = {
          date, assignmentType: 'OR',
          startTime: st, endTime: en,
          timeEntries: [{ start: st, end: en }],
          isHoliday: false,
          forcedOff: false, subspecCoverage: false,
          teeCount: 0, supervisionStart: '', supervisionEnd: '', preCallStart: '', preCallEnd: '', tempCoverage: []
        };
        shiftsCreated++;
      }
    });

    data.cases.push(...newCases);
    saveData(data);
    updateHeaderPoints();
    showToast(`Imported ${newCases.length} cases` + (shiftsCreated > 0 ? ` and created ${shiftsCreated} placeholder shifts` : ''));
  };

  document.getElementById('importConfirmModal').classList.remove('hidden');
}

async function parseCaseExcel(file) {
  const arrayBuffer = await file.arrayBuffer();
  const wb = XLSX.read(arrayBuffer, { type: 'array' });
  const ws = wb.Sheets[wb.SheetNames[0]];
  const rows = XLSX.utils.sheet_to_json(ws, { defval: '' });
  if (rows.length === 0) return { cases: [], months: [] };

  // Flexible column header matching
  const headers = Object.keys(rows[0]);
  const findCol = (...patterns) => headers.find(h => patterns.some(p => h.toLowerCase().includes(p.toLowerCase()))) || '';
  const dateCol = findCol('date', 'dos', 'Date');
  const surgeonCol = findCol('surgeon', 'provider', 'attending');
  const unitsCol = findCol('units', 'points', 'base');
  const startCol = findCol('start', 'begin');
  const endCol = findCol('end', 'stop', 'finish');
  const modCol = findCol('modifier', 'mod');
  const sharedCol = findCol('shared', 'split');
  const procCol = findCol('procedure', 'proc', 'description', 'case');

  if (!dateCol) throw new Error('No date column found. Expected: Date, DOS, or similar.');

  const cases = [];
  for (const row of rows) {
    const dateVal = row[dateCol];
    if (!dateVal && dateVal !== 0) continue;
    const dateStr = parseExcelDate(dateVal);
    if (!dateStr || dateStr.length !== 10) continue;

    const baseUnits = parseFloat(row[unitsCol]) || 0;
    const startTime = startCol ? parseExcelTime(row[startCol]) : '';
    const endTime = endCol ? parseExcelTime(row[endCol]) : '';
    if (baseUnits <= 0 && !startTime) continue;

    const surgeon = surgeonCol ? String(row[surgeonCol]) : '';
    const modifiers = modCol ? String(row[modCol]) : '';
    const shared = sharedCol ? String(row[sharedCol]) : '';
    const procedure = procCol ? String(row[procCol]) : '';

    const isEmergency = /\bE\b/i.test(modifiers);
    let physicalStatus = 'P3';
    const psMatch = modifiers.match(/\b([45])\b/);
    if (psMatch) physicalStatus = 'P' + psMatch[1];

    cases.push({
      id: genId(),
      caseType: 'standard',
      procedure: procedure,
      baseUnits: baseUnits,
      physicalStatus: physicalStatus,
      startTime: startTime,
      endTime: endTime,
      shiftDate: dateStr,
      isEmergency: isEmergency,
      isMedicalProcedure: false,
      medicalProcedureUnits: 0,
      isAcutePain: false,
      acutePainUnits: 0,
      isHighRiskPeds: false,
      isORCase: false,
      nerveBlock: 'none',
      centralLine: false,
      arterialLine: false,
      pac: false,
      teeAddOn: false,
      notes: surgeon + (shared && /^y/i.test(shared) ? ' (shared)' : ''),
      timestamp: new Date().toISOString()
    });
  }
  return { cases, months: buildCaseMonthSummary(cases) };
}

async function parseCasePDF(file) {
  const allText = await extractPDFTextLegacy(file);

  const prodCases = parseProdText(allText);
  // Convert production format to case import format, skipping add-on rows
  const cases = [];
  for (const pc of prodCases) {
    if (pc.isAddOn) continue;
    cases.push({
      id: genId(),
      caseType: 'standard',
      procedure: pc.cptCode || '',
      baseUnits: pc.units || 0,
      physicalStatus: 'P2',
      startTime: pc.startTime || '',
      endTime: pc.endTime || '',
      shiftDate: pc.date,
      isEmergency: false,
      isMedicalProcedure: false,
      medicalProcedureUnits: 0,
      isAcutePain: false,
      acutePainUnits: 0,
      isHighRiskPeds: false,
      isORCase: false,
      nerveBlock: 'none',
      centralLine: false,
      arterialLine: false,
      pac: false,
      teeAddOn: false,
      notes: pc.cptCode ? 'CPT ' + pc.cptCode : '',
      timestamp: new Date().toISOString()
    });
  }
  return { cases, months: buildCaseMonthSummary(cases) };
}

const CPT_ADDON_MAP = {
  '64415': 'brachial_plexus', '64416': 'brachial_plexus', '64417': 'brachial_plexus',
  '64400': 'other_nerve', '64405': 'other_nerve', '64408': 'other_nerve',
  '64418': 'other_nerve', '64420': 'other_nerve', '64421': 'other_nerve',
  '64425': 'other_nerve', '64430': 'other_nerve', '64435': 'other_nerve',
  '64445': 'other_nerve', '64446': 'other_nerve', '64447': 'other_nerve',
  '64448': 'other_nerve', '64449': 'other_nerve', '64450': 'other_nerve',
  '64461': 'other_nerve', '64462': 'other_nerve', '64463': 'other_nerve',
  '64466': 'other_nerve', '64467': 'other_nerve', '64468': 'other_nerve',
  '64469': 'other_nerve', '64472': 'other_nerve', '64474': 'other_nerve',
  '64486': 'other_nerve', '64487': 'other_nerve', '64488': 'other_nerve',
  '64489': 'other_nerve',
  '62322': 'it_morphine', '62323': 'it_morphine',
  '36620': 'arterial_line',
  '36556': 'central_line',
  // 01996 (epidural rounding) and 99231 (pain rounding) are tracked as cases in the app,
  // not add-ons — they are matched at the case level during reconciliation
  '93312': 'tee', '93313': 'tee', '93314': 'tee',
  '93315': 'tee', '93316': 'tee', '93355': 'tee',
  '99241': 'pac', '99242': 'pac', '99243': 'pac',
  '99244': 'pac', '99245': 'pac'
};

function parseProdText(text) {
  const lines = text.split('\n');
  const cases = [];
  let currentDate = '';

  for (const line of lines) {
    const cols = line.split('\t').map(c => c.trim());

    // Try to find date of service pattern: M/D/YY or M/D/YYYY
    const dateMatch = cols[0] && cols[0].match(/^(\d{1,2})\/(\d{1,2})\/(\d{2,4})$/);
    if (dateMatch) {
      let [, m, d, y] = dateMatch;
      y = parseInt(y);
      if (y < 100) y += 2000;
      currentDate = y + '-' + String(parseInt(m)).padStart(2,'0') + '-' + String(parseInt(d)).padStart(2,'0');
    }

    if (!currentDate) continue;

    // Extract CPT code first (5-digit number)
    let cptCode = '';
    for (const c of cols) {
      if (c.match(/^\d{5}$/)) { cptCode = c; break; }
    }

    // Extract account number — numeric string 6-10 digits, not a CPT code or time
    let accountNumber = '';
    for (const c of cols) {
      if (c.match(/^\d{6,10}$/) && c !== cptCode) {
        accountNumber = c;
        break;
      }
    }

    // Scan columns for military time (3-4 digit number between 0 and 2359)
    let startTime = '', endTime = '';
    for (let i = 0; i < cols.length; i++) {
      const val = cols[i].replace(/[^0-9]/g, '');
      if (val.length >= 3 && val.length <= 4) {
        const num = parseInt(val);
        if (num >= 0 && num <= 2359) {
          if (!startTime) startTime = val;
          else if (!endTime) { endTime = val; break; }
        }
      }
    }

    // Check if this is an add-on row (CPT maps to add-on type AND no start/end times)
    const addOnType = cptCode ? (CPT_ADDON_MAP[cptCode] || '') : '';
    if (addOnType && (!startTime || !endTime)) {
      // Extract points for add-on rows
      const nums = cols.filter(c => c && !isNaN(parseFloat(c)));
      const totalPoints = nums.length > 0 ? parseFloat(nums[nums.length - 1]) || 0 : 0;
      let units = 0;
      for (const c of cols) {
        const n = parseFloat(c);
        if (!isNaN(n) && n >= 1 && n <= 30 && Number.isInteger(n)) { units = n; break; }
      }
      cases.push({
        date: currentDate, startTime: '', endTime: '',
        mdMinutes: 0, totalPoints, units,
        locCode: '', cptCode, accountNumber,
        isAddOn: true, addOnType
      });
      continue;
    }

    // Rounding CPT codes (01996, 99231) — these are cases, not add-ons,
    // even if they lack start/end times on the billing document
    const isRoundingCPT = cptCode === '01996' || cptCode === '99231';
    if (isRoundingCPT && (!startTime || !endTime)) {
      const nums = cols.filter(c => c && !isNaN(parseFloat(c)));
      const totalPoints = nums.length > 0 ? parseFloat(nums[nums.length - 1]) || 0 : 0;
      let units = 0;
      for (const c of cols) {
        const n = parseFloat(c);
        if (!isNaN(n) && n >= 1 && n <= 30 && Number.isInteger(n)) { units = n; break; }
      }
      cases.push({
        date: currentDate, startTime: '', endTime: '',
        mdMinutes: 0, totalPoints, units,
        locCode: '', cptCode, accountNumber,
        isAddOn: false, addOnType: '',
        isRounding: true
      });
      continue;
    }

    // Standard case row — needs start/end times
    const lastNum = cols.filter(c => c && !isNaN(parseFloat(c)));
    if (lastNum.length >= 2 && startTime && endTime) {
      let totalPoints = parseFloat(lastNum[lastNum.length - 1]) || 0;
      let units = 0, locCode = '';
      for (const c of cols) {
        const n = parseFloat(c);
        if (!isNaN(n) && n >= 1 && n <= 30 && Number.isInteger(n) && c !== startTime && c !== endTime) { units = n; break; }
      }
      for (const c of cols) {
        if (c.match(/^[A-Z]{2,4}$/) && c !== 'Y') { locCode = c; break; }
      }

      if (totalPoints !== 0 || units > 0) {
        cases.push({
          date: currentDate,
          startTime: formatMilitaryTime(startTime),
          endTime: formatMilitaryTime(endTime),
          mdMinutes: 0, totalPoints, units, locCode, cptCode, accountNumber,
          isAddOn: false, addOnType: addOnType
        });
      }
    }
  }

  // Keep add-on rows (no times) + rounding rows (no times) + case rows (with times)
  return cases.filter(c => c.isAddOn || c.isRounding || (c.startTime && c.endTime));
}

function formatMilitaryTime(val) {
  const s = val.padStart(4, '0');
  return s.substring(0, 2) + ':' + s.substring(2, 4);
}

// Reconciliation state
let reconDifferences = [];
let reconFlaggedItems = [];
let reconAutoAdjusted = [];
let reconCurrentDiff = 0;
let reconDecisions = {};
let reconMatchesByDate = {}; // { date: [{ billing, tracker, score, status, ptsDiff }] }
let reconExpandedDays = {}; // { date: true/false }

function loadReconDecisions() {
  try {
    const raw = localStorage.getItem(RECON_DECISIONS_KEY);
    if (raw) reconDecisions = JSON.parse(raw);
  } catch(e) { reconDecisions = {}; }
}
function saveReconDecisions() {
  localStorage.setItem(RECON_DECISIONS_KEY, JSON.stringify(reconDecisions));
}

function getAddOnTypeName(type) {
  const names = {
    brachial_plexus: 'Brachial Plexus Block', other_nerve: 'Other Nerve Block',
    it_morphine: 'IT Morphine', arterial_line: 'Arterial Line',
    central_line: 'Central Line', epidural_round: 'Epidural Rounding',
    pain_round: 'Pain Rounding', tee: 'TEE', pac: 'PAC'
  };
  return names[type] || type;
}

function countAppAddOns(trackerCases, date) {
  const dayCases = trackerCases.filter(c => c.shiftDate === date);
  const counts = {};
  dayCases.forEach(c => {
    if (c.nerveBlock === 'brachial_plexus') counts.brachial_plexus = (counts.brachial_plexus || 0) + 1;
    else if (c.nerveBlock === 'other') counts.other_nerve = (counts.other_nerve || 0) + 1;
    if (c.hasCentralLine) counts.central_line = (counts.central_line || 0) + 1;
    if (c.hasArterialLine) counts.arterial_line = (counts.arterial_line || 0) + 1;
    if (c.hasPAC) counts.pac = (counts.pac || 0) + 1;
    if (c.hasTEEAddOn) counts.tee = (counts.tee || 0) + 1;
    if (c.hasITMorphine) counts.it_morphine = (counts.it_morphine || 0) + 1;
  });
  return counts;
}

function renderAddOnTally(billingCases, trackerCases, prefix) {
  const billingAddOns = billingCases.filter(c => c.isAddOn);
  if (billingAddOns.length === 0) return '';

  // Group billing add-ons by date and type
  const bByDateType = {};
  billingAddOns.forEach(c => {
    const key = `${c.date}|${c.addOnType}`;
    bByDateType[key] = (bByDateType[key] || 0) + 1;
  });

  // Get all unique dates and types
  const allDates = new Set(billingAddOns.map(c => c.date));
  trackerCases.filter(c => c.shiftDate && c.shiftDate.startsWith(prefix)).forEach(c => allDates.add(c.shiftDate));
  const sortedDates = [...allDates].sort();

  const allTypes = new Set(billingAddOns.map(c => c.addOnType));

  // Per-date app add-on counts
  const appCountsByDate = {};
  sortedDates.forEach(d => { appCountsByDate[d] = countAppAddOns(trackerCases, d); });

  // Also check app for types not in billing
  sortedDates.forEach(d => {
    Object.keys(appCountsByDate[d]).forEach(t => allTypes.add(t));
  });

  // Build discrepancy rows
  const rows = [];
  sortedDates.forEach(date => {
    const appCounts = appCountsByDate[date] || {};
    allTypes.forEach(type => {
      const bCount = bByDateType[`${date}|${type}`] || 0;
      const aCount = appCounts[type] || 0;
      if (bCount !== aCount) {
        rows.push({ date, type, billing: bCount, app: aCount });
      }
    });
  });

  // Monthly summary totals
  const monthBilling = {}, monthApp = {};
  allTypes.forEach(type => {
    monthBilling[type] = 0;
    monthApp[type] = 0;
  });
  sortedDates.forEach(date => {
    allTypes.forEach(type => {
      monthBilling[type] += bByDateType[`${date}|${type}`] || 0;
      monthApp[type] += (appCountsByDate[date] || {})[type] || 0;
    });
  });

  let html = '<div class="card"><h2>Additional Procedure Tally</h2>';

  // Monthly summary
  html += '<table class="addon-tally-table"><thead><tr><th>Procedure</th><th>Billing</th><th>App</th><th>Diff</th></tr></thead><tbody>';
  allTypes.forEach(type => {
    const b = monthBilling[type], a = monthApp[type];
    const diff = b - a;
    const cls = diff === 0 ? 'addon-match' : Math.abs(diff) === 1 ? 'addon-warn' : 'addon-miss';
    html += `<tr class="${cls}"><td>${getAddOnTypeName(type)}</td><td>${b}</td><td>${a}</td><td>${diff > 0 ? '+' : ''}${diff}</td></tr>`;
  });
  html += '</tbody></table>';

  // Per-day discrepancies
  if (rows.length > 0) {
    html += '<h3 style="margin-top:16px;font-size:0.85rem;">Daily Discrepancies</h3>';
    html += '<table class="addon-tally-table"><thead><tr><th>Date</th><th>Procedure</th><th>Billing</th><th>App</th><th>Action</th></tr></thead><tbody>';
    rows.forEach((r, idx) => {
      const diff = Math.abs(r.billing - r.app);
      const cls = diff === 1 ? 'addon-warn' : 'addon-miss';
      let actionHtml = '';
      if (r.billing > r.app) {
        // App is missing — offer to add to a case
        const dayCases = data.cases.filter(c => c.shiftDate === r.date);
        if (dayCases.length > 0) {
          actionHtml = `<select class="addon-select" id="addonSelect_${idx}" data-date="${r.date}" data-type="${r.type}">`;
          actionHtml += '<option value="">Add to Case...</option>';
          dayCases.forEach(c => {
            actionHtml += `<option value="${c.id}">${c.startTime || ''} ${escHtml(c.procedure || c.caseType).substring(0,20)}</option>`;
          });
          actionHtml += '</select>';
        } else {
          actionHtml = '<span style="font-size:0.7rem;color:var(--text-dim)">No cases for date</span>';
        }
      } else {
        // Billing is missing — flag for office
        actionHtml = `<button class="addon-action-btn" onclick="flagAddonForOffice('${r.date}','${r.type}',${r.app},${r.billing})">Flag for Office</button>`;
      }
      html += `<tr class="${cls}"><td>${formatDateShort(r.date)}</td><td>${getAddOnTypeName(r.type)}</td><td>${r.billing}</td><td>${r.app}</td><td>${actionHtml}</td></tr>`;
    });
    html += '</tbody></table>';
  } else {
    html += '<p style="color:var(--accent);font-size:0.8rem;margin-top:8px;">All additional procedures match!</p>';
  }

  html += '</div>';
  return html;
}

function flagAddonForOffice(date, type, appCount, billingCount) {
  reconFlaggedItems.push({
    type: 'addon',
    date, addOnType: type,
    description: `${getAddOnTypeName(type)}: App has ${appCount}, billing has ${billingCount}`
  });
  showToast('Flagged for office');
  renderProdRecon();
}

// ================================================================
// SCORED MATCHING ALGORITHM
// ================================================================
function matchCases(bDay, tDay, shift) {
  // Score all billing-tracker pairs
  const pairs = [];
  bDay.forEach((bc, bi) => {
    tDay.forEach((tc, ti) => {
      let score = 0;

      // Date always matches within a day
      score += 100;

      // CPT code match: billing CPT matches tracker case type or ASA code
      if (bc.cptCode) {
        const tcType = tc.caseType || '';
        if (bc.cptCode === tcType) score += 50;
        else if (bc.isRounding && tc.caseType === 'aps_rounding') score += 40;
      }

      // Start time proximity
      const bStart = timeToMinutes(bc.startTime);
      const tStart = timeToMinutes(tc.startTime || '');
      if (bStart > 0 && tStart > 0) {
        const timeDiff = Math.abs(bStart - tStart);
        if (timeDiff <= 30) score += 30 - timeDiff;
      }

      // Both shared
      if (bc.isShared && tc.isSharedCase) score += 10;

      // Location match
      if (bc.locCode && tc.location && bc.locCode === tc.location) score += 5;

      pairs.push({ bi, ti, score });
    });
  });

  // Greedy assignment: sort by score descending, assign best non-conflicting match
  pairs.sort((a, b) => b.score - a.score);
  const usedBilling = new Set();
  const usedTracker = new Set();
  const matches = [];

  for (const pair of pairs) {
    if (usedBilling.has(pair.bi) || usedTracker.has(pair.ti)) continue;
    if (pair.score < 50) continue; // threshold

    usedBilling.add(pair.bi);
    usedTracker.add(pair.ti);

    const bc = bDay[pair.bi];
    const tc = tDay[pair.ti];
    const tcPts = calcCasePoints(tc, shift);
    const ptsDiff = Math.abs(bc.totalPoints - tcPts);

    let status;
    if (ptsDiff < 3) status = 'match';
    else if (ptsDiff <= 10) status = 'close';
    else status = 'mismatch';

    matches.push({
      billing: bc, tracker: tc, score: pair.score,
      status, billingPts: bc.totalPoints, trackerPts: tcPts, ptsDiff
    });
  }

  // Unmatched billing cases
  bDay.forEach((bc, bi) => {
    if (usedBilling.has(bi)) return;
    matches.push({
      billing: bc, tracker: null, score: 0,
      status: 'missing', billingPts: bc.totalPoints, trackerPts: 0, ptsDiff: bc.totalPoints,
      missingFrom: 'tracker'
    });
  });

  // Unmatched tracker cases
  tDay.forEach((tc, ti) => {
    if (usedTracker.has(ti)) return;
    const tcPts = calcCasePoints(tc, shift);
    matches.push({
      billing: null, tracker: tc, score: 0,
      status: 'missing', billingPts: 0, trackerPts: tcPts, ptsDiff: tcPts,
      missingFrom: 'billing'
    });
  });

  return matches;
}

function getMatchKey(m) {
  const date = m.billing ? m.billing.date : m.tracker.shiftDate;
  const time = m.billing ? (m.billing.startTime || 'none') : (m.tracker.startTime || 'tc');
  const cpt = m.billing ? (m.billing.cptCode || '') : '';
  return `${date}_${time}_${cpt}`;
}

function batchAcceptAllMatches() {
  let count = 0;
  for (const date of Object.keys(reconMatchesByDate)) {
    const matches = reconMatchesByDate[date];
    const shift = data.shifts[date];
    for (const m of matches) {
      if (m.status !== 'match') continue;
      const key = getMatchKey(m);
      if (reconDecisions[key] && (reconDecisions[key].accepted || reconDecisions[key].flagged)) continue;
      reconDecisions[key] = { accepted: 'match', flagged: false };
      count++;
    }
  }
  saveReconDecisions();
  showToast(`Accepted ${count} matching cases`);
  renderProdRecon();
}

function toggleReconDay(dateStr) {
  reconExpandedDays[dateStr] = !reconExpandedDays[dateStr];
  const dayEl = document.querySelector(`.recon-day[data-date="${dateStr}"]`);
  if (dayEl) dayEl.classList.toggle('expanded');
}

function renderProdRecon() {
  loadReconDecisions();
  reconFlaggedItems = [];
  reconAutoAdjusted = [];

  if (prodData.length === 0) {
    try {
      const cached = localStorage.getItem(PROD_KEY);
      if (cached) prodData = JSON.parse(cached);
    } catch(e) {}
  }

  const container = document.getElementById('prodResults');
  const prefix = `${pYear}-${String(pMonth+1).padStart(2,'0')}`;
  const mn = ['January','February','March','April','May','June','July','August','September','October','November','December'];
  const monthLabel = `${mn[pMonth]} ${pYear}`;

  const allBilling = prodData.filter(c => c.date && c.date.startsWith(prefix));
  const billingCases = allBilling.filter(c => !c.isAddOn);
  const trackerCases = data.cases.filter(c => c.shiftDate && c.shiftDate.startsWith(prefix));

  if (prodData.length === 0) {
    container.innerHTML = '<div class="empty-state"><p>Upload a Charge Detail PDF to begin reconciliation.</p></div>';
    return;
  }
  if (allBilling.length === 0 && trackerCases.length === 0) {
    container.innerHTML = '<div class="empty-state"><p>No data for this month.</p></div>';
    return;
  }

  // Group by date (cases only, not add-on rows)
  const bByDate = {};
  billingCases.forEach(c => { if (!bByDate[c.date]) bByDate[c.date] = []; bByDate[c.date].push(c); });
  const tByDate = {};
  trackerCases.forEach(c => { if (!tByDate[c.shiftDate]) tByDate[c.shiftDate] = []; tByDate[c.shiftDate].push(c); });

  const allDates = new Set([...Object.keys(bByDate), ...Object.keys(tByDate)]);
  const sortedDates = [...allDates].sort();

  // Run scored matching for each day
  reconMatchesByDate = {};
  let totalMatched = 0, totalClose = 0, totalMismatch = 0, totalMissing = 0;
  let bTotalPts = 0, tTotalPts = 0;

  sortedDates.forEach(date => {
    const bDay = bByDate[date] || [];
    const tDay = tByDate[date] || [];
    const shift = data.shifts[date];

    const matches = matchCases(bDay, tDay, shift);
    reconMatchesByDate[date] = matches;

    // Auto-adjust shared cases with small differences
    matches.forEach(m => {
      if (m.status === 'close' && m.tracker && m.billing && m.tracker.isSharedCase && m.ptsDiff < 5) {
        const tc = m.tracker;
        const bc = m.billing;
        const oldPts = m.trackerPts;
        const isOBShift = shift && ['OB_restricted','SF1','SF2'].includes(shift.assignmentType);
        const obMult = (isOBShift && !tc.isORCase) ? 2 : 1;
        const addOns = calcAddOnPoints(tc);
        let caseStartMin = timeToMinutes(tc.startTime);
        let caseEndMin = timeToMinutes(tc.endTime);
        if (caseEndMin <= caseStartMin) caseEndMin += 1440;
        const caseHours = (caseEndMin - caseStartMin) / 60;
        const tm = getTimeMultiplier(tc.physicalStatus, shift ? shift.isHoliday : false, shift ? isWeekend(shift.date) : false, caseStartMin, tc.isHighRiskPeds);
        const timePts = caseHours * tm * 6;
        const emergPts = tc.isEmergency ? 1 : 0;
        const medPts = tc.isMedicalProc ? 0.20 * (parseFloat(tc.medicalUnits) || 0) : 0;
        const acutePts = tc.isAcutePain ? 0.375 * (parseFloat(tc.acutePainUnits) || 0) : 0;
        const targetBase = bc.totalPoints / obMult - timePts - medPts - acutePts - emergPts - addOns;
        const pct = (parseFloat(tc.sharedStartupPct) || 50) / 100;
        if (pct > 0) {
          tc.baseUnits = String(round2(targetBase / (0.5 * pct)));
          const realCase = data.cases.find(c => c.id === tc.id);
          if (realCase) realCase.baseUnits = tc.baseUnits;
          saveData(data);
          m.status = 'match';
          m.trackerPts = bc.totalPoints;
          m.ptsDiff = 0;
          reconAutoAdjusted.push({ date, startTime: tc.startTime, procedure: tc.procedure, oldPts, newPts: bc.totalPoints });
        }
      }
    });

    matches.forEach(m => {
      bTotalPts += m.billingPts;
      tTotalPts += m.trackerPts;
      if (m.status === 'match') totalMatched++;
      else if (m.status === 'close') totalClose++;
      else if (m.status === 'mismatch') totalMismatch++;
      else if (m.status === 'missing') totalMissing++;
    });
  });

  const unresolvedCount = totalClose + totalMismatch + totalMissing;

  // === Summary Dashboard ===
  let html = '<div class="card">';
  html += '<div class="recon-summary-bar">';
  html += `<div class="stat green"><div class="num">${totalMatched}</div><div class="lbl">Matched</div></div>`;
  html += `<div class="stat yellow"><div class="num">${totalClose + totalMismatch}</div><div class="lbl">Discrepancies</div></div>`;
  html += `<div class="stat purple"><div class="num">${totalMissing}</div><div class="lbl">Missing</div></div>`;
  html += '</div>';
  html += '<div class="recon-pts-compare">';
  html += `<div>Billing: <span style="color:var(--primary)">${bTotalPts.toFixed(1)} pts</span></div>`;
  html += `<div>Tracker: <span style="color:var(--accent)">${tTotalPts.toFixed(1)} pts</span></div>`;
  html += '</div>';

  // Batch actions
  if (totalMatched > 0) {
    const unacceptedMatches = Object.values(reconMatchesByDate).flat().filter(m => {
      if (m.status !== 'match') return false;
      const key = getMatchKey(m);
      return !reconDecisions[key] || (!reconDecisions[key].accepted && !reconDecisions[key].flagged);
    }).length;
    if (unacceptedMatches > 0) {
      html += '<div class="recon-batch-actions">';
      html += `<button class="btn btn-accept-app" onclick="batchAcceptAllMatches()" style="padding:10px 16px;font-size:0.85rem;">Accept All Matches (${unacceptedMatches})</button>`;
      html += '</div>';
    }
  }
  html += '</div>';

  // === Auto-adjusted shared cases ===
  if (reconAutoAdjusted.length > 0) {
    html += '<div class="card"><h2>Auto-Adjusted Shared Cases</h2>';
    html += `<p style="font-size:0.8rem;color:var(--accent);margin-bottom:8px;">${reconAutoAdjusted.length} shared case${reconAutoAdjusted.length > 1 ? 's' : ''} auto-adjusted to match billing</p>`;
    html += '<details><summary style="cursor:pointer;font-size:0.8rem;color:var(--primary);">Show details</summary>';
    html += '<table class="recon-table"><thead><tr><th>Date</th><th>Case</th><th>Old</th><th>New</th></tr></thead><tbody>';
    reconAutoAdjusted.forEach(a => {
      html += `<tr class="match"><td>${formatDateShort(a.date)}</td><td>${a.startTime} ${escHtml(a.procedure || '')}</td><td>${a.oldPts.toFixed(1)} pts</td><td>${a.newPts.toFixed(1)} pts</td></tr>`;
    });
    html += '</tbody></table></details></div>';
  }

  // === Add-on tally ===
  html += renderAddOnTally(allBilling, data.cases, prefix);

  // === Daily Breakdown (expandable days) ===
  html += '<div class="card"><h2>Daily Breakdown</h2>';
  sortedDates.forEach(date => {
    const matches = reconMatchesByDate[date];
    const dayBPts = matches.reduce((s, m) => s + m.billingPts, 0);
    const dayTPts = matches.reduce((s, m) => s + m.trackerPts, 0);
    const caseCount = matches.length;

    // Determine day status
    const hasIssue = matches.some(m => m.status !== 'match');
    const hasMissing = matches.some(m => m.status === 'missing');
    const hasMismatch = matches.some(m => m.status === 'mismatch');
    let dayStatus, dayStatusCls;
    if (hasMissing) { dayStatus = 'Missing'; dayStatusCls = 'missing'; }
    else if (hasMismatch) { dayStatus = 'Mismatch'; dayStatusCls = 'mismatch'; }
    else if (hasIssue) { dayStatus = 'Close'; dayStatusCls = 'close'; }
    else { dayStatus = 'Match'; dayStatusCls = 'match'; }

    // Expand by default if issues, collapse if match
    const isExpanded = reconExpandedDays[date] !== undefined ? reconExpandedDays[date] : (dayStatusCls !== 'match');
    if (reconExpandedDays[date] === undefined) reconExpandedDays[date] = isExpanded;

    html += `<div class="recon-day status-${dayStatusCls}${isExpanded ? ' expanded' : ''}" data-date="${date}">`;
    html += `<div class="recon-day-header" onclick="toggleReconDay('${date}')">`;
    html += `<span class="day-date">${formatDateShort(date)}</span>`;
    html += `<span class="day-info">${caseCount} case${caseCount !== 1 ? 's' : ''} &middot; ${dayBPts.toFixed(1)} pts</span>`;
    html += `<span class="day-status s-${dayStatusCls}">${dayStatus}</span>`;
    html += '<span class="day-chevron">&#9660;</span>';
    html += '</div>';

    // Day detail (case table)
    html += '<div class="recon-day-detail">';
    html += renderReconDayDetail(date, matches);
    html += '</div>';
    html += '</div>';
  });
  html += '</div>';

  // === Flagged section ===
  html += '<div id="reconFlaggedSection"></div>';

  container.innerHTML = html;

  // Wire up add-on select dropdowns
  container.querySelectorAll('.addon-select').forEach(sel => {
    sel.addEventListener('change', function() {
      const caseId = this.value;
      if (!caseId) return;
      const type = this.dataset.type;
      const c = data.cases.find(x => x.id === caseId);
      if (!c) return;
      if (type === 'brachial_plexus') c.nerveBlock = 'brachial_plexus';
      else if (type === 'other_nerve') c.nerveBlock = 'other';
      else if (type === 'central_line') c.hasCentralLine = true;
      else if (type === 'arterial_line') c.hasArterialLine = true;
      else if (type === 'it_morphine') c.hasITMorphine = true;
      else if (type === 'pac') c.hasPAC = true;
      else if (type === 'tee') c.hasTEEAddOn = true;
      saveData(data);
      showToast(`Added ${getAddOnTypeName(type)} to case`);
      renderProdRecon();
    });
  });

  renderFlaggedSection(monthLabel);
}

function renderReconDayDetail(date, matches) {
  let html = '<table class="recon-case-table"><thead><tr>';
  html += '<th>Time</th><th>CPT</th><th>Billing</th><th>App</th><th>Status</th><th>Action</th>';
  html += '</tr></thead><tbody>';

  matches.forEach((m, idx) => {
    const key = getMatchKey(m);
    const decision = reconDecisions[key];
    const isResolved = decision && (decision.accepted || decision.flagged);
    const rowCls = `case-${m.status}`;

    // Time column
    const timeStr = m.billing
      ? `${m.billing.startTime || '-'}-${m.billing.endTime || '-'}`
      : (m.tracker ? `${m.tracker.startTime || '-'}-${m.tracker.endTime || '-'}` : '-');

    // CPT column
    const cptStr = m.billing ? (m.billing.cptCode || '-') : '-';

    // Billing pts
    const bPtsStr = m.billing ? m.billingPts.toFixed(1) : '<span style="color:var(--danger);font-size:0.7rem">Missing</span>';

    // App pts
    const aPtsStr = m.tracker ? m.trackerPts.toFixed(1) : '<span style="color:var(--danger);font-size:0.7rem">Missing</span>';

    // Status
    let statusStr;
    if (m.status === 'match') statusStr = '<span style="color:var(--accent)">Match</span>';
    else if (m.status === 'close') statusStr = `<span style="color:var(--accent2)">${m.ptsDiff.toFixed(1)} diff</span>`;
    else if (m.status === 'mismatch') statusStr = `<span style="color:var(--danger)">${m.ptsDiff.toFixed(1)} diff</span>`;
    else if (m.missingFrom === 'tracker') statusStr = '<span style="color:#a78bfa">Not in app</span>';
    else statusStr = '<span style="color:#a78bfa">Not in billing</span>';

    // Action column
    let actionHtml;
    if (isResolved) {
      if (decision.flagged) actionHtml = '<span class="case-resolved" style="color:var(--accent2)">Flagged</span>';
      else actionHtml = '<span class="case-resolved">Accepted</span>';
    } else if (m.status === 'match') {
      actionHtml = '<span style="color:var(--accent)">&#10003;</span>';
    } else {
      const escDate = date.replace(/'/g, "\\'");
      actionHtml = '<div class="case-actions">';
      if (m.billing && m.tracker) {
        actionHtml += `<button onclick="reconAcceptBillingInline('${escDate}',${idx})">Billing</button>`;
        actionHtml += `<button onclick="reconAcceptAppInline('${escDate}',${idx})">App</button>`;
      }
      actionHtml += `<button class="act-flag" onclick="reconFlagInline('${escDate}',${idx})">Flag</button>`;
      actionHtml += '</div>';
    }

    html += `<tr class="${rowCls}"><td>${timeStr}</td><td>${cptStr}</td><td>${bPtsStr}</td><td>${aPtsStr}</td><td>${statusStr}</td><td>${actionHtml}</td></tr>`;
  });

  html += '</tbody></table>';
  return html;
}

// Inline action handlers for the new dashboard UI
function reconAcceptBillingInline(date, idx) {
  const matches = reconMatchesByDate[date];
  if (!matches || !matches[idx]) return;
  const m = matches[idx];
  const key = getMatchKey(m);

  if (m.tracker && m.billing) {
    const tc = m.tracker;
    const shift = data.shifts[date];
    const isOBShift = shift && ['OB_restricted','SF1','SF2'].includes(shift.assignmentType);
    const obMult = (isOBShift && !tc.isORCase) ? 2 : 1;
    const addOns = calcAddOnPoints(tc);
    let caseStartMin = timeToMinutes(tc.startTime);
    let caseEndMin = timeToMinutes(tc.endTime);
    if (caseEndMin <= caseStartMin) caseEndMin += 1440;
    const caseHours = (caseEndMin - caseStartMin) / 60;
    const tm = getTimeMultiplier(tc.physicalStatus, shift ? shift.isHoliday : false, shift ? isWeekend(shift.date) : false, caseStartMin, tc.isHighRiskPeds);
    const timePts = caseHours * tm * 6;
    const emergPts = tc.isEmergency ? 1 : 0;
    const medPts = tc.isMedicalProc ? 0.20 * (parseFloat(tc.medicalUnits) || 0) : 0;
    const acutePts = tc.isAcutePain ? 0.375 * (parseFloat(tc.acutePainUnits) || 0) : 0;
    const targetBase = m.billing.totalPoints / obMult - timePts - medPts - acutePts - emergPts - addOns;
    const pct = tc.isSharedCase ? ((parseFloat(tc.sharedStartupPct) || 50) / 100) : 1;
    if (pct > 0) {
      tc.baseUnits = String(round2(targetBase / (0.5 * pct)));
    }
    const realCase = data.cases.find(c => c.id === tc.id);
    if (realCase) realCase.baseUnits = tc.baseUnits;
    saveData(data);
    showToast(`Case updated to match billing (${m.billing.totalPoints.toFixed(1)} pts)`);
  }

  reconDecisions[key] = { accepted: 'billing', flagged: false };
  saveReconDecisions();
  updateHeaderPoints();
  renderProdRecon();
}

function reconAcceptAppInline(date, idx) {
  const matches = reconMatchesByDate[date];
  if (!matches || !matches[idx]) return;
  const m = matches[idx];
  const key = getMatchKey(m);
  reconDecisions[key] = { accepted: 'app', flagged: false };
  saveReconDecisions();
  renderProdRecon();
}

function reconFlagInline(date, idx) {
  const matches = reconMatchesByDate[date];
  if (!matches || !matches[idx]) return;
  const m = matches[idx];
  const key = getMatchKey(m);
  reconDecisions[key] = { accepted: '', flagged: true };
  saveReconDecisions();
  renderProdRecon();
}

function renderFlaggedSection(monthLabel) {
  const section = document.getElementById('reconFlaggedSection');
  if (!section) return;

  if (!monthLabel) {
    const mn = ['January','February','March','April','May','June','July','August','September','October','November','December'];
    monthLabel = `${mn[pMonth]} ${pYear}`;
  }

  // Collect all flagged from match decisions
  const allFlagged = [];
  for (const date of Object.keys(reconMatchesByDate)) {
    const matches = reconMatchesByDate[date];
    matches.forEach(m => {
      const key = getMatchKey(m);
      if (reconDecisions[key] && reconDecisions[key].flagged) {
        allFlagged.push({
          type: 'case', date,
          startTime: m.billing ? m.billing.startTime : (m.tracker ? m.tracker.startTime : ''),
          endTime: m.billing ? m.billing.endTime : (m.tracker ? m.tracker.endTime : ''),
          accountNumber: m.billing ? (m.billing.accountNumber || '') : '',
          billingPts: m.billingPts, trackerPts: m.trackerPts,
          diffType: m.missingFrom === 'tracker' ? 'missing_tracker' : (m.missingFrom === 'billing' ? 'missing_billing' : 'mismatch')
        });
      }
    });
  }

  // Also include addon flags
  reconFlaggedItems.filter(f => f.type === 'addon').forEach(f => allFlagged.push(f));

  if (allFlagged.length === 0) {
    section.innerHTML = '';
    return;
  }

  let html = '<div class="card"><h2>Flagged Issues (' + allFlagged.length + ')</h2>';
  html += '<ul class="flagged-list">';
  allFlagged.forEach(f => {
    if (f.type === 'case') {
      const acct = f.accountNumber ? ` — Acct# ${f.accountNumber}` : '';
      if (f.diffType === 'missing_billing') {
        html += `<li>${formatDateShort(f.date)} — ${f.startTime || '?'}-${f.endTime || '?'}${acct} — Missing from billing (App: ${f.trackerPts.toFixed(1)} pts)</li>`;
      } else if (f.diffType === 'missing_tracker') {
        html += `<li>${formatDateShort(f.date)} — ${f.startTime || '?'}-${f.endTime || '?'}${acct} — Missing from app (Billing: ${f.billingPts.toFixed(1)} pts)</li>`;
      } else {
        html += `<li>${formatDateShort(f.date)} — ${f.startTime || '?'}-${f.endTime || '?'}${acct} — Billing: ${f.billingPts.toFixed(1)} pts, App: ${f.trackerPts.toFixed(1)} pts (${Math.abs(f.billingPts - f.trackerPts).toFixed(1)} diff)</li>`;
      }
    } else if (f.type === 'addon') {
      html += `<li>${formatDateShort(f.date)} — ${f.description}</li>`;
    }
  });
  html += '</ul>';

  // Email generation
  html += '<div style="margin-top:16px;">';
  html += '<button class="btn btn-primary" onclick="generateReconEmail()" style="width:100%;margin-bottom:8px;">Generate Email</button>';
  html += '<div id="reconEmailPreview"></div>';
  html += '</div></div>';

  section.innerHTML = html;
}

function generateReconEmail() {
  const mn = ['January','February','March','April','May','June','July','August','September','October','November','December'];
  const monthLabel = `${mn[pMonth]} ${pYear}`;
  const userName = settings.name || '[Your Name]';

  // Collect all flagged
  const allFlagged = [];
  for (const date of Object.keys(reconMatchesByDate)) {
    const matches = reconMatchesByDate[date];
    matches.forEach(m => {
      const key = getMatchKey(m);
      if (reconDecisions[key] && reconDecisions[key].flagged) {
        allFlagged.push({
          type: 'case', date,
          startTime: m.billing ? m.billing.startTime : (m.tracker ? m.tracker.startTime : ''),
          endTime: m.billing ? m.billing.endTime : (m.tracker ? m.tracker.endTime : ''),
          accountNumber: m.billing ? (m.billing.accountNumber || '') : '',
          billingPts: m.billingPts, trackerPts: m.trackerPts,
          diffType: m.missingFrom === 'tracker' ? 'missing_tracker' : (m.missingFrom === 'billing' ? 'missing_billing' : 'mismatch')
        });
      }
    });
  }
  reconFlaggedItems.filter(f => f.type === 'addon').forEach(f => allFlagged.push(f));

  let emailText = `Subject: Billing Discrepancies — ${monthLabel}\n\nHi,\n\nI found the following discrepancies during reconciliation for ${monthLabel}:\n\n`;

  allFlagged.forEach((f, i) => {
    if (f.type === 'case') {
      const dateFormatted = f.date.replace(/(\d{4})-(\d{2})-(\d{2})/, '$2/$3/$1');
      const acct = f.accountNumber ? `, Account: ${f.accountNumber}` : '';
      if (f.diffType === 'missing_billing') {
        emailText += `${i + 1}. Date: ${dateFormatted}, Time: ${f.startTime || '?'}-${f.endTime || '?'}${acct}\n   Case not found in billing document (App: ${f.trackerPts.toFixed(1)} pts)\n\n`;
      } else if (f.diffType === 'missing_tracker') {
        emailText += `${i + 1}. Date: ${dateFormatted}, Time: ${f.startTime || '?'}-${f.endTime || '?'}${acct}\n   Case not found in app (Billing: ${f.billingPts.toFixed(1)} pts)\n\n`;
      } else {
        const diff = Math.abs(f.billingPts - f.trackerPts);
        emailText += `${i + 1}. Date: ${dateFormatted}, Time: ${f.startTime || '?'}-${f.endTime || '?'}${acct}\n   Billing: ${f.billingPts.toFixed(1)} pts | App: ${f.trackerPts.toFixed(1)} pts (${diff.toFixed(1)} pt difference)\n\n`;
      }
    } else if (f.type === 'addon') {
      emailText += `${i + 1}. Add-on discrepancy on ${f.date.replace(/(\d{4})-(\d{2})-(\d{2})/, '$2/$3/$1')}: ${f.description}\n\n`;
    }
  });

  emailText += `Please review and advise.\n\nThanks,\n${userName}`;

  const preview = document.getElementById('reconEmailPreview');
  preview.innerHTML = `<div class="email-preview">${escHtml(emailText)}</div>`;
  preview.innerHTML += '<button class="btn btn-primary" onclick="copyReconEmail()" style="width:100%;margin-top:8px;">Copy to Clipboard</button>';
  preview.dataset.emailText = emailText;
}

function copyReconEmail() {
  const preview = document.getElementById('reconEmailPreview');
  const text = preview.dataset.emailText || '';
  navigator.clipboard.writeText(text).then(() => {
    showToast('Email copied to clipboard!');
  }).catch(() => {
    showToast('Failed to copy — try selecting and copying manually');
  });
}

// ================================================================
// BILLING SHEET SCAN — ASA CODE LOOKUP
// ================================================================
const ASA_BASE_UNITS = {
  // Head
  '00100': 5, '00102': 6, '00103': 5, '00104': 4, '00120': 5, '00124': 4,
  '00126': 4, '00140': 5, '00142': 4, '00144': 6, '00145': 6, '00147': 4,
  '00148': 4, '00160': 7, '00162': 7, '00164': 4, '00170': 5, '00172': 6,
  '00174': 6, '00176': 7, '00190': 5, '00192': 7,
  // Neck
  '00210': 11, '00211': 11, '00212': 5, '00214': 4, '00215': 5, '00216': 7,
  '00218': 10, '00220': 6, '00222': 6,
  // Thorax
  '00300': 5, '00320': 5, '00322': 6, '00326': 6, '00350': 5, '00352': 5,
  '00400': 6, '00402': 6, '00404': 6, '00406': 8, '00410': 7, '00450': 5,
  '00454': 4, '00470': 10, '00472': 10, '00474': 13,
  // Spine & spinal cord
  '00500': 10, '00520': 5, '00522': 4, '00524': 10, '00528': 6, '00530': 6,
  '00532': 5, '00534': 13, '00537': 6, '00539': 10, '00540': 6, '00541': 6,
  '00542': 6, '00546': 7, '00548': 10, '00550': 7,
  // Upper abdomen
  '00600': 4, '00604': 4, '00620': 7, '00625': 7, '00626': 7, '00630': 7,
  '00632': 7, '00634': 7, '00635': 5, '00640': 7, '00670': 5, '00700': 4,
  '00702': 4,
  // Lower abdomen
  '00730': 5, '00731': 5, '00732': 5, '00740': 6, '00750': 4, '00752': 6,
  '00754': 7, '00756': 7, '00770': 7, '00790': 7, '00792': 7, '00794': 8,
  '00796': 7, '00797': 9,
  // Perineum
  '00800': 3, '00802': 5, '00810': 4, '00812': 5, '00820': 3, '00830': 5,
  '00832': 5, '00834': 4, '00836': 4, '00840': 6, '00842': 7, '00844': 7,
  '00846': 7, '00848': 4, '00851': 7, '00860': 5, '00862': 7, '00864': 4,
  '00865': 6, '00866': 6, '00868': 5, '00870': 5, '00872': 5, '00873': 7,
  '00880': 5, '00882': 5, '00902': 7, '00904': 5, '00906': 3, '00908': 4,
  '00910': 5, '00912': 5, '00914': 4, '00916': 5, '00918': 4, '00920': 3,
  '00921': 4, '00922': 4, '00924': 4, '00926': 4, '00928': 3, '00930': 5,
  '00932': 3, '00934': 5, '00936': 5, '00938': 3, '00940': 5, '00942': 5,
  '00944': 4, '00948': 4, '00950': 5, '00952': 5,
  // Upper leg
  '01200': 4, '01202': 7, '01210': 3, '01212': 5, '01214': 4, '01215': 5,
  '01220': 5, '01230': 3, '01232': 4, '01234': 4, '01250': 5, '01260': 7,
  '01270': 4, '01272': 8,
  // Knee & popliteal
  '01320': 5, '01340': 3, '01360': 5, '01380': 3, '01382': 7, '01390': 4,
  '01392': 4, '01400': 3, '01402': 6, '01404': 4, '01420': 5, '01430': 4,
  '01432': 3, '01440': 4, '01442': 7, '01444': 6,
  // Lower leg, ankle & foot
  '01462': 3, '01464': 4, '01470': 3, '01472': 3, '01474': 5, '01480': 3,
  '01482': 3, '01484': 3, '01486': 4, '01490': 3, '01500': 3, '01502': 3,
  '01520': 5, '01522': 4,
  // Shoulder & axilla
  '01610': 3, '01620': 5, '01622': 4, '01630': 4, '01634': 4, '01636': 4,
  '01638': 4, '01650': 4, '01652': 5, '01654': 5, '01656': 4, '01670': 4,
  // Upper arm & elbow
  '01710': 3, '01712': 5, '01714': 4, '01716': 4, '01730': 3, '01732': 5,
  '01740': 4, '01742': 6, '01744': 5, '01756': 3, '01758': 3, '01760': 3,
  '01770': 4, '01772': 4, '01780': 5, '01782': 7,
  // Forearm, wrist & hand
  '01810': 3, '01820': 3, '01829': 3, '01830': 3, '01832': 4, '01840': 3,
  '01842': 4, '01844': 3, '01850': 3, '01852': 3, '01860': 3, '01916': 5,
  '01920': 7, '01922': 7, '01924': 10, '01925': 7, '01926': 8, '01930': 5,
  '01931': 5, '01932': 5, '01933': 7, '01935': 5, '01936': 5, '01951': 3,
  '01952': 3, '01953': 5, '01958': 3, '01960': 3, '01961': 3, '01962': 5,
  '01963': 8, '01965': 5, '01966': 3, '01967': 5, '01968': 5, '01969': 7,
  '01990': 7, '01991': 7, '01992': 7, '01996': 3, '01999': 0,
  // Burn excisions / debridement
  '01951': 3, '01952': 3, '01953': 5,
  // Radiological
  '01916': 5, '01920': 7, '01922': 7, '01924': 10, '01925': 7, '01926': 8,
  // Obstetric
  '01958': 3, '01960': 3, '01961': 3, '01962': 5, '01963': 8, '01967': 5, '01968': 5, '01969': 7,
  // Other
  '01990': 7, '01991': 7, '01992': 7, '01999': 0,
  // Invasive / cardiac
  '00560': 15, '00561': 15, '00562': 15, '00563': 15, '00566': 25, '00567': 15,
  '00580': 10
};

// ================================================================
// BILLING SHEET SCAN — PARSER
// ================================================================
function parseBillingSheetText(text) {
  const cases = [];
  // Normalize common OCR misreads before parsing
  let cleaned = text
    .replace(/[OoQD](?=\d{4})/g, '0')    // O/o/Q/D before 4 digits → 0 (ASA codes start with 0)
    .replace(/(?<=\d{3})[OoQD](?=\d)/g, '0') // O in middle of digit sequences → 0
    .replace(/[Il|](?=\d{3,4})/g, '1')    // I/l/| before digits → 1
    .replace(/[Ss](?=\d{4})/g, '5')       // S before 4 digits → 5
    .replace(/[Bb](?=\d{3})/g, '8');       // B before 3 digits → 8
  const lines = cleaned.split('\n').map(l => l.trim()).filter(l => l.length > 0);
  const fullText = lines.join('\n');

  // Strategy: Look for ASA codes (5-digit numbers starting with 0) and times
  // The sheet has 4 case blocks; each block has a code, start/stop, and modifiers

  // Find all 5-digit ASA codes (00xxx or 01xxx) — also try common OCR variants
  const asaPattern = /\b(0[01]\d{3})\b/g;
  const asaMatches = [];
  let m;
  while ((m = asaPattern.exec(fullText)) !== null) {
    asaMatches.push({ code: m[1], index: m.index });
  }

  if (asaMatches.length === 0) return cases;

  // Find all military times (4-digit HHMM or HH:MM)
  // Build set of ASA codes found to filter them out of time matches
  const asaCodeSet = new Set(asaMatches.map(a => a.code));
  const timePattern = /\b(\d{2}):?(\d{2})\b/g;
  const allTimes = [];
  while ((m = timePattern.exec(fullText)) !== null) {
    const h = parseInt(m[1]), min = parseInt(m[2]);
    if (h >= 0 && h <= 23 && min >= 0 && min <= 59 && h + min > 0) {
      const digits = m[1] + m[2];
      // Skip if it matches an ASA code or looks like a year (19xx, 20xx)
      if (asaCodeSet.has(digits)) continue;
      if (digits.startsWith('19') || digits.startsWith('20')) continue;
      allTimes.push({ time: String(h).padStart(2, '0') + ':' + String(min).padStart(2, '0'), index: m.index });
    }
  }

  // Segment text by ASA code positions — each code starts a new case block
  for (let i = 0; i < asaMatches.length; i++) {
    const blockStart = asaMatches[i].index;
    const blockEnd = i + 1 < asaMatches.length ? asaMatches[i + 1].index : fullText.length;
    const blockText = fullText.substring(blockStart, blockEnd);
    const blockTextUpper = blockText.toUpperCase();

    const asaCode = asaMatches[i].code;
    const baseUnits = ASA_BASE_UNITS[asaCode] || 0;

    // Find valid times in this block (ASA codes and years already filtered above)
    const validTimes = allTimes.filter(t => t.index > blockStart && t.index < blockEnd);

    let startTime = '', endTime = '';
    // Look for Start: and Stop: labels
    const startMatch = blockText.match(/start[:\s]*(\d{2}):?(\d{2})/i);
    const stopMatch = blockText.match(/stop[:\s]*(\d{2}):?(\d{2})/i);
    if (startMatch) {
      startTime = String(parseInt(startMatch[1])).padStart(2, '0') + ':' + String(parseInt(startMatch[2])).padStart(2, '0');
    }
    if (stopMatch) {
      endTime = String(parseInt(stopMatch[1])).padStart(2, '0') + ':' + String(parseInt(stopMatch[2])).padStart(2, '0');
    }
    // Fallback: use first two times if labels not found
    if (!startTime && validTimes.length >= 1) startTime = validTimes[0].time;
    if (!endTime && validTimes.length >= 2) endTime = validTimes[1].time;

    // Check modifiers — broadened checkbox symbols for OCR variance
    const checkMark = /[xXvV✓✗☒☑√✔✘|/\\+><\])]/;
    const isEmergency = /emergency/i.test(blockText) && checkMark.test(
      blockText.substring(blockText.search(/emergency/i) - 8, blockText.search(/emergency/i) + 15)
    ) || /[xXvV✓✗☒☑√✔✘]\s*emergency/i.test(blockText);
    const isShared = /shared/i.test(blockText) && checkMark.test(
      blockText.substring(Math.max(0, blockText.search(/shared/i) - 8), blockText.search(/shared/i) + 12)
    ) || /[xXvV✓✗☒☑√✔✘]\s*shared/i.test(blockText);

    // Check nerve block types — "PLXS" matches the actual form label "Brachial PLXS"
    let nerveBlock = 'none';
    const nbChecks = [
      { pattern: /brachial\s*pl[xks]+/i, type: 'brachial_plexus' },
      { pattern: /sciatic/i, type: 'other' },
      { pattern: /femoral/i, type: 'other' },
      { pattern: /abdominal\s*n?b?/i, type: 'other' },
      { pattern: /chest\s*wall/i, type: 'other' },
      { pattern: /paravertebral|esp/i, type: 'other' }
    ];
    for (const nb of nbChecks) {
      if (nb.pattern.test(blockText)) {
        const nbIdx = blockText.search(nb.pattern);
        const nbRegion = blockText.substring(Math.max(0, nbIdx - 12), nbIdx + 25);
        if (checkMark.test(nbRegion)) {
          nerveBlock = nb.type;
          break;
        }
      }
    }

    // Lumbar INJ / Thoracic INJ — check for single vs continuous
    let hasITMorphine = false;
    if (/lumbar\s*inj|thoracic\s*inj/i.test(blockText)) {
      const injIdx = blockText.search(/lumbar\s*inj|thoracic\s*inj/i);
      const injRegion = blockText.substring(Math.max(0, injIdx - 12), injIdx + 25);
      if (checkMark.test(injRegion)) {
        if (/single/i.test(blockTextUpper) && checkMark.test(
          blockText.substring(Math.max(0, blockText.search(/single/i) - 8), blockText.search(/single/i) + 15)
        )) {
          hasITMorphine = true;
        }
      }
    }

    // Other services — "Art" pattern requires nearby context to avoid false positives
    let hasCentralLine = false, hasArterialLine = false, hasTEE = false, hasBloodPatch = false, hasEmergIntub = false;
    const svcChecks = [
      { pattern: /\bCVC\b/i, set: () => hasCentralLine = true },
      { pattern: /\bArt(?:erial)?\b(?!\w)/i, set: () => hasArterialLine = true },
      { pattern: /\bTEE\b/i, set: () => hasTEE = true },
      { pattern: /blood\s*patch/i, set: () => hasBloodPatch = true },
      { pattern: /emerg\w*\s*intub/i, set: () => hasEmergIntub = true }
    ];
    for (const svc of svcChecks) {
      if (svc.pattern.test(blockText)) {
        const sIdx = blockText.search(svc.pattern);
        const sRegion = blockText.substring(Math.max(0, sIdx - 12), sIdx + 20);
        if (checkMark.test(sRegion)) svc.set();
      }
    }

    // Extract notes
    let notes = '';
    const notesMatch = blockText.match(/notes[:\s]+(.*?)(?:\n|$)/i);
    if (notesMatch && notesMatch[1].trim().length > 1) {
      notes = notesMatch[1].trim();
    }

    // Determine case type
    let caseType = 'standard';
    if (hasBloodPatch) caseType = 'epidural_blood_patch';
    else if (hasEmergIntub) caseType = 'emergency_intubation';

    cases.push({
      asaCode: asaCode,
      baseUnits: baseUnits,
      startTime: startTime,
      endTime: endTime,
      caseType: caseType,
      isEmergency: isEmergency,
      isShared: isShared,
      nerveBlock: nerveBlock,
      hasITMorphine: hasITMorphine,
      hasCentralLine: hasCentralLine,
      hasArterialLine: hasArterialLine,
      hasTEE: hasTEE,
      notes: notes
    });
  }

  return cases;
}

// ================================================================
// BILLING SHEET SCAN — PAGE LOGIC
// ================================================================
let scanParsedCases = [];
let scanImageBlob = null;

function initScanPage() {
  const dateInput = document.getElementById('scanDate');
  if (!dateInput.value) dateInput.value = workingDate || todayStr();
}

document.getElementById('scanFileInput').addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;
  scanImageBlob = file;
  const preview = document.getElementById('scanPreviewImg');
  preview.src = URL.createObjectURL(file);
  preview.classList.remove('hidden');
  document.getElementById('scanActions').classList.remove('hidden');
  document.getElementById('scanResultsArea').classList.add('hidden');
  setScanStatus('');
});

document.getElementById('scanRetakeBtn').addEventListener('click', () => {
  scanImageBlob = null;
  document.getElementById('scanFileInput').value = '';
  document.getElementById('scanPreviewImg').classList.add('hidden');
  document.getElementById('scanActions').classList.add('hidden');
  document.getElementById('scanResultsArea').classList.add('hidden');
  setScanStatus('');
  scanParsedCases = [];
});

// Preprocess image: upscale 2x, grayscale, adaptive binarization for OCR
function preprocessScanImage(file) {
  return new Promise((resolve) => {
    const img = new Image();
    img.onload = () => {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      // Upscale 2x — Tesseract needs ~300 DPI, phone photos are often low-res
      const scale = Math.max(2, Math.min(3, 2400 / Math.max(img.width, img.height)));
      canvas.width = Math.round(img.width * scale);
      canvas.height = Math.round(img.height * scale);
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

      // Pass 1: Convert to grayscale
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const d = imageData.data;
      const grayArr = new Uint8Array(canvas.width * canvas.height);
      for (let i = 0; i < d.length; i += 4) {
        const gray = Math.round(0.299 * d[i] + 0.587 * d[i+1] + 0.114 * d[i+2]);
        grayArr[i / 4] = gray;
      }

      // Pass 2: Adaptive threshold — compare each pixel to local average
      // This handles uneven lighting and preserves handwritten strokes
      const w = canvas.width, h = canvas.height;
      const blockSize = Math.round(Math.max(w, h) / 30) | 1; // ensure odd
      const half = Math.floor(blockSize / 2);
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          // Compute local mean in a window around this pixel
          let sum = 0, count = 0;
          const y0 = Math.max(0, y - half), y1 = Math.min(h - 1, y + half);
          const x0 = Math.max(0, x - half), x1 = Math.min(w - 1, x + half);
          // Sample every other pixel for speed
          for (let sy = y0; sy <= y1; sy += 2) {
            for (let sx = x0; sx <= x1; sx += 2) {
              sum += grayArr[sy * w + sx];
              count++;
            }
          }
          const localMean = sum / count;
          const idx = y * w + x;
          const pixel = grayArr[idx];
          // Pixel is "ink" if it's significantly darker than local mean
          const out = pixel < localMean - 15 ? 0 : 255;
          const pi = idx * 4;
          d[pi] = d[pi+1] = d[pi+2] = out;
        }
      }
      ctx.putImageData(imageData, 0, 0);
      canvas.toBlob(blob => resolve(blob), 'image/png');
      URL.revokeObjectURL(img.src);
    };
    img.src = URL.createObjectURL(file);
  });
}

document.getElementById('scanProcessBtn').addEventListener('click', async () => {
  if (!scanImageBlob) { showToast('No image selected'); return; }

  const apiKey = settings.visionApiKey;
  if (!apiKey) {
    setScanStatus('error', 'No Vision API key set. Go to Settings to add your Google Cloud Vision API key.');
    return;
  }

  setScanStatus('processing', 'Calling Vision API...');
  try {
    // Convert image to base64 (Vision API handles raw photos natively — no preprocessing needed)
    const base64 = await new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result.split(',')[1]);
      reader.onerror = () => reject(new Error('Failed to read image'));
      reader.readAsDataURL(scanImageBlob);
    });

    const response = await fetch('https://vision.googleapis.com/v1/images:annotate?key=' + encodeURIComponent(apiKey), {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        requests: [{
          image: { content: base64 },
          features: [{ type: 'DOCUMENT_TEXT_DETECTION' }]
        }]
      })
    });

    if (!response.ok) {
      const errBody = await response.json().catch(() => ({}));
      const errMsg = errBody.error?.message || response.statusText;
      throw new Error('Vision API (' + response.status + '): ' + errMsg);
    }

    const result = await response.json();
    const annotation = result.responses?.[0];
    if (annotation?.error) {
      throw new Error('Vision API: ' + annotation.error.message);
    }

    const ocrText = annotation?.fullTextAnnotation?.text || '';
    const wordCount = ocrText.split(/\s+/).filter(w => w.length > 0).length;
    console.log('Vision API words detected:', wordCount);
    console.log('Vision API text:', ocrText);

    if (!ocrText || ocrText.trim().length < 10) {
      setScanStatus('error', 'Could not read text from image. Try a clearer photo.');
      showScanOCRDebug(ocrText, wordCount);
      return;
    }

    setScanStatus('processing', 'Parsing billing sheet...');
    scanParsedCases = parseBillingSheetText(ocrText);

    if (scanParsedCases.length === 0) {
      setScanStatus('error', 'No cases found. Make sure the ASA codes are clearly visible.');
      showScanOCRDebug(ocrText, wordCount);
      return;
    }

    setScanStatus('success', `Found ${scanParsedCases.length} case${scanParsedCases.length > 1 ? 's' : ''} (${wordCount} words detected)`);
    showScanOCRDebug(ocrText, wordCount);
    renderScanCaseCards();
  } catch (err) {
    console.error('Scan error:', err);
    setScanStatus('error', err.message);
  }
});

function setScanStatus(type, msg) {
  const el = document.getElementById('scanStatus');
  if (!type) { el.classList.add('hidden'); el.innerHTML = ''; return; }
  el.classList.remove('hidden');
  el.className = 'scan-status ' + type;
  if (type === 'processing') {
    el.innerHTML = '<div class="spinner"></div><span>' + msg + '</span>';
  } else {
    el.innerHTML = '<span>' + msg + '</span>';
  }
}

function showScanOCRDebug(ocrText, wordCount) {
  const area = document.getElementById('scanResultsArea');
  area.classList.remove('hidden');
  let debugEl = document.getElementById('scanOCRDebug');
  if (!debugEl) {
    debugEl = document.createElement('details');
    debugEl.id = 'scanOCRDebug';
    debugEl.style.cssText = 'margin-top:12px;';
    area.prepend(debugEl);
  }
  debugEl.innerHTML = `<summary style="cursor:pointer;font-size:0.8rem;color:var(--text-dim);">Raw OCR Text (${wordCount} words detected)</summary><pre style="background:var(--bg);border:1px solid var(--border);border-radius:8px;padding:12px;font-size:0.72rem;white-space:pre-wrap;max-height:200px;overflow-y:auto;margin-top:8px;color:var(--text-dim);">${escHtml(ocrText || '(empty)')}</pre>`;
}

function renderScanCaseCards() {
  const area = document.getElementById('scanResultsArea');
  const container = document.getElementById('scanCaseCards');
  const countEl = document.getElementById('scanCaseCount');
  area.classList.remove('hidden');
  countEl.textContent = scanParsedCases.length + ' case' + (scanParsedCases.length !== 1 ? 's' : '');

  container.innerHTML = '';
  scanParsedCases.forEach((c, idx) => {
    const unitLabel = ASA_BASE_UNITS[c.asaCode] ? c.asaCode : 'Unknown';
    const tags = [];
    if (c.isEmergency) tags.push('<span class="scc-tag emergency">Emergency</span>');
    if (c.isShared) tags.push('<span class="scc-tag shared">Shared</span>');
    if (c.nerveBlock !== 'none') tags.push('<span class="scc-tag active">' + (c.nerveBlock === 'brachial_plexus' ? 'Brachial Plexus' : 'Nerve Block') + '</span>');
    if (c.hasITMorphine) tags.push('<span class="scc-tag active">IT Morphine</span>');
    if (c.hasCentralLine) tags.push('<span class="scc-tag active">CVC</span>');
    if (c.hasArterialLine) tags.push('<span class="scc-tag active">Art Line</span>');
    if (c.hasTEE) tags.push('<span class="scc-tag active">TEE</span>');

    const card = document.createElement('div');
    card.className = 'scan-case-card';
    card.innerHTML = `
      <div class="scc-header">
        <h4>Case ${idx + 1}</h4>
        <button class="scc-remove" data-idx="${idx}" title="Remove">&times;</button>
      </div>
      <div class="scc-row">
        <div class="scc-field">
          <label>ASA Code</label>
          <input type="text" value="${c.asaCode}" data-idx="${idx}" data-field="asaCode" maxlength="5">
        </div>
        <div class="scc-field">
          <label>Base Units</label>
          <input type="number" value="${c.baseUnits}" data-idx="${idx}" data-field="baseUnits" min="0" max="30">
        </div>
      </div>
      <div class="scc-row">
        <div class="scc-field">
          <label>Start</label>
          <input type="text" value="${c.startTime}" data-idx="${idx}" data-field="startTime" placeholder="HH:MM" maxlength="5">
        </div>
        <div class="scc-field">
          <label>Stop</label>
          <input type="text" value="${c.endTime}" data-idx="${idx}" data-field="endTime" placeholder="HH:MM" maxlength="5">
        </div>
      </div>
      <div class="scc-row">
        <div class="scc-field">
          <label>Case Type</label>
          <select data-idx="${idx}" data-field="caseType">
            <option value="standard" ${c.caseType === 'standard' ? 'selected' : ''}>Standard</option>
            <option value="epidural_blood_patch" ${c.caseType === 'epidural_blood_patch' ? 'selected' : ''}>Epidural Blood Patch</option>
            <option value="emergency_intubation" ${c.caseType === 'emergency_intubation' ? 'selected' : ''}>Emergency Intubation</option>
          </select>
        </div>
        <div class="scc-field">
          <label>Notes</label>
          <input type="text" value="${c.notes}" data-idx="${idx}" data-field="notes" placeholder="Surgeon, etc.">
        </div>
      </div>
      <div class="scc-tags">${tags.join('')}</div>
      <div style="margin-top:8px;display:flex;flex-wrap:wrap;gap:6px;">
        <label style="font-size:0.75rem;color:var(--text-dim);display:flex;align-items:center;gap:4px;">
          <input type="checkbox" data-idx="${idx}" data-field="isEmergency" ${c.isEmergency ? 'checked' : ''}> Emergency
        </label>
        <label style="font-size:0.75rem;color:var(--text-dim);display:flex;align-items:center;gap:4px;">
          <input type="checkbox" data-idx="${idx}" data-field="isShared" ${c.isShared ? 'checked' : ''}> Shared
        </label>
        <label style="font-size:0.75rem;color:var(--text-dim);display:flex;align-items:center;gap:4px;">
          <input type="checkbox" data-idx="${idx}" data-field="hasITMorphine" ${c.hasITMorphine ? 'checked' : ''}> IT Morphine
        </label>
        <label style="font-size:0.75rem;color:var(--text-dim);display:flex;align-items:center;gap:4px;">
          <input type="checkbox" data-idx="${idx}" data-field="hasCentralLine" ${c.hasCentralLine ? 'checked' : ''}> CVC
        </label>
        <label style="font-size:0.75rem;color:var(--text-dim);display:flex;align-items:center;gap:4px;">
          <input type="checkbox" data-idx="${idx}" data-field="hasArterialLine" ${c.hasArterialLine ? 'checked' : ''}> Art Line
        </label>
        <label style="font-size:0.75rem;color:var(--text-dim);display:flex;align-items:center;gap:4px;">
          <input type="checkbox" data-idx="${idx}" data-field="hasTEE" ${c.hasTEE ? 'checked' : ''}> TEE
        </label>
      </div>
      <div style="margin-top:6px;">
        <label style="font-size:0.75rem;color:var(--text-dim);">Nerve Block</label>
        <select data-idx="${idx}" data-field="nerveBlock" style="width:100%;padding:4px 6px;background:var(--bg);border:1px solid var(--border);border-radius:6px;color:var(--text);font-size:0.8rem;margin-top:2px;">
          <option value="none" ${c.nerveBlock === 'none' ? 'selected' : ''}>None</option>
          <option value="brachial_plexus" ${c.nerveBlock === 'brachial_plexus' ? 'selected' : ''}>Brachial Plexus</option>
          <option value="other_nerve" ${c.nerveBlock === 'other_nerve' ? 'selected' : ''}>Other Nerve Block</option>
        </select>
      </div>
    `;
    container.appendChild(card);
  });

  // Bind events
  container.querySelectorAll('.scc-remove').forEach(btn => {
    btn.addEventListener('click', () => {
      const idx = parseInt(btn.dataset.idx);
      scanParsedCases.splice(idx, 1);
      renderScanCaseCards();
    });
  });

  container.querySelectorAll('input[data-field], select[data-field]').forEach(el => {
    const handler = () => {
      const idx = parseInt(el.dataset.idx);
      const field = el.dataset.field;
      if (!scanParsedCases[idx]) return;
      if (el.type === 'checkbox') {
        scanParsedCases[idx][field] = el.checked;
      } else if (el.type === 'number') {
        scanParsedCases[idx][field] = parseInt(el.value) || 0;
      } else {
        scanParsedCases[idx][field] = el.value;
      }
      // Auto-lookup base units when ASA code changes
      if (field === 'asaCode' && el.value.length === 5) {
        const units = ASA_BASE_UNITS[el.value];
        if (units !== undefined) {
          scanParsedCases[idx].baseUnits = units;
          const unitsInput = container.querySelector(`input[data-idx="${idx}"][data-field="baseUnits"]`);
          if (unitsInput) unitsInput.value = units;
        }
      }
    };
    el.addEventListener('change', handler);
    if (el.type === 'text' || el.type === 'number') el.addEventListener('input', handler);
  });

  // Bind military time formatting on start/stop inputs
  container.querySelectorAll('input[data-field="startTime"], input[data-field="endTime"]').forEach(inp => {
    bindMilTimeInput(inp);
  });
}

document.getElementById('scanImportBtn').addEventListener('click', () => {
  if (scanParsedCases.length === 0) { showToast('No cases to import'); return; }

  const scanDate = document.getElementById('scanDate').value;
  if (!scanDate) { showToast('Please set the sheet date'); return; }

  const newCases = [];
  const existingKeys = new Set(data.cases.map(c => c.shiftDate + '|' + c.startTime));

  for (const sc of scanParsedCases) {
    if (!sc.startTime) continue; // skip cases with no start time
    const key = scanDate + '|' + sc.startTime;
    if (existingKeys.has(key)) continue; // skip duplicates

    newCases.push({
      id: genId(),
      caseType: sc.caseType || 'standard',
      procedure: sc.asaCode || '',
      baseUnits: sc.baseUnits || 0,
      physicalStatus: 'P2',
      startTime: sc.startTime || '',
      endTime: sc.endTime || '',
      shiftDate: scanDate,
      isEmergency: sc.isEmergency || false,
      isMedicalProc: false,
      medicalUnits: 0,
      isAcutePain: false,
      acutePainUnits: 0,
      isHighRiskPeds: false,
      isORCase: false,
      isSharedCase: sc.isShared || false,
      sharedStartupPct: 50,
      nerveBlock: sc.nerveBlock || 'none',
      hasCentralLine: sc.hasCentralLine || false,
      hasArterialLine: sc.hasArterialLine || false,
      hasPAC: false,
      hasTEEAddOn: sc.hasTEE || false,
      hasITMorphine: sc.hasITMorphine || false,
      notes: sc.notes || '',
      timestamp: new Date().toISOString()
    });
  }

  if (newCases.length === 0) {
    showToast('No new cases to import (all duplicates or missing start times)');
    return;
  }

  // Create placeholder shift if none exists
  if (!data.shifts[scanDate]) {
    let earliest = '23:59', latest = '00:00';
    newCases.forEach(c => {
      if (c.startTime && c.startTime < earliest) earliest = c.startTime;
      if (c.endTime && c.endTime > latest) latest = c.endTime;
    });
    const st = earliest || '07:00';
    const en = latest || '17:00';
    data.shifts[scanDate] = {
      date: scanDate, assignmentType: 'OR',
      startTime: st, endTime: en,
      timeEntries: [{ start: st, end: en }],
      isHoliday: false, forcedOff: false, subspecCoverage: false,
      teeCount: 0, supervisionStart: '', supervisionEnd: '', preCallStart: '', preCallEnd: '', tempCoverage: []
    };
    showToast(`Created placeholder OR shift for ${formatDateShort(scanDate)}`);
  }

  data.cases.push(...newCases);
  saveData(data);
  updateHeaderPoints();

  const skipped = scanParsedCases.length - newCases.length;
  let msg = `Imported ${newCases.length} case${newCases.length > 1 ? 's' : ''}`;
  if (skipped > 0) msg += ` (${skipped} skipped)`;
  showToast(msg);

  // Reset scan page
  scanParsedCases = [];
  document.getElementById('scanResultsArea').classList.add('hidden');
  document.getElementById('scanPreviewImg').classList.add('hidden');
  document.getElementById('scanActions').classList.add('hidden');
  document.getElementById('scanFileInput').value = '';
  setScanStatus('success', msg);
});

// ================================================================
// SERVICE WORKER REGISTRATION
// ================================================================
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('sw.js').catch(() => {});
}

// ================================================================
// AUTH — SIGN IN / SIGN OUT
// ================================================================
document.getElementById('googleSignInBtn').addEventListener('click', async () => {
  const errEl = document.getElementById('authError');
  const loadEl = document.getElementById('authLoading');
  errEl.classList.add('hidden');
  loadEl.classList.remove('hidden');
  try {
    const provider = new firebase.auth.GoogleAuthProvider();
    await auth.signInWithPopup(provider);
  } catch(err) {
    console.error('Sign-in error:', err);
    loadEl.classList.add('hidden');
    errEl.textContent = err.message || 'Sign-in failed';
    errEl.classList.remove('hidden');
  }
});

document.getElementById('signOutBtn').addEventListener('click', async () => {
  if (!confirm('Sign out? Your data is saved in the cloud.')) return;
  firestoreSyncEnabled = false;
  currentUser = null;
  await auth.signOut();
  document.getElementById('authOverlay').classList.remove('hidden');
});

function updateAccountUI(user) {
  if (!user) return;
  const photo = document.getElementById('accountPhoto');
  const name = document.getElementById('accountName');
  const email = document.getElementById('accountEmail');
  photo.src = user.photoURL || '';
  photo.style.display = user.photoURL ? '' : 'none';
  name.textContent = user.displayName || 'User';
  email.textContent = user.email || '';
}

// ================================================================
// AUTH STATE LISTENER
// ================================================================
auth.onAuthStateChanged(async (user) => {
  if (user) {
    currentUser = user;
    document.getElementById('authLoading').classList.add('hidden');

    // Load data from Firestore
    const result = await loadFromFirestore(user.uid);
    await loadSettingsFromFirestore(user.uid);

    firestoreSyncEnabled = true;
    updateAccountUI(user);
    document.getElementById('authOverlay').classList.add('hidden');

    // Re-run migration & init with cloud data
    migrateData(data);
    initApp();

    if (result === 'migrated') {
      showToast('Local data synced to cloud');
    } else if (result === 'loaded') {
      showToast('Data loaded from cloud');
    }

    // Show tutorial for brand-new users (no data at all)
    if (Object.keys(data.shifts).length === 0 && data.cases.length === 0) {
      showTutorial();
    }

    // Auto-sync calendar if last sync was >24 hours ago
    const lastSync = data.calendarLastSync ? new Date(data.calendarLastSync).getTime() : 0;
    if (Date.now() - lastSync > 24 * 60 * 60 * 1000) {
      syncCalendarEvents(true);
    }
  } else {
    // Not signed in — show auth overlay
    currentUser = null;
    firestoreSyncEnabled = false;
    document.getElementById('authOverlay').classList.remove('hidden');
  }
});

// ================================================================
// INIT
// ================================================================
function initApp() {
  initMilTimeInputs();
  setWorkingDate(todayStr());
  renderTemplates();
  updateHeaderPoints();
  updateReconMonthLabels();
  updateCLMonthLabel();
  updateSupervisionOverlayVisibility();
  checkEndTimeNotification();
}

// Run init immediately with localStorage data (will re-run after auth)
initApp();
</script>

</body>
</html>
